%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{目录}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}


	    % Use some font with UTF-8 support with XeLaTeX
        \usepackage[UTF8]{ctex}
     

\title{Fong Documentation}
\date{May 02, 2019}
\release{alpha}
\author{fong}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{文中可能存在错误，欢迎 PR。}

\sphinxurl{https://github.com/fongyk}

\sphinxurl{https://github.com/fongyq}
\end{sphinxadmonition}


\chapter{C/C++}
\label{\detokenize{cpp/index:c-c}}\label{\detokenize{cpp/index::doc}}\label{\detokenize{cpp/index:id1}}

\section{main函数}
\label{\detokenize{cpp/01_main:main}}\label{\detokenize{cpp/01_main::doc}}

\subsection{返回值}
\label{\detokenize{cpp/01_main:id1}}
C++ main函数的返回值必须是 \sphinxcode{\sphinxupquote{int}} ，即整型类型。在大多数系统中，main 的返回值被用来指示状态，返回值 \sphinxcode{\sphinxupquote{0}} 表示执行成功，非0的返回值含义由系统定义，通常用来指出错误类型。

Windows系统下运行可执行文件(如launch.exe)可以直接忽略其扩展名 \sphinxcode{\sphinxupquote{.exe}} ：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{launch}
\end{sphinxVerbatim}

Unix系统下需要使用全文件名，包括扩展名：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
./a.out
\end{sphinxVerbatim}

访问main函数返回之后的方法依赖于系统。在Windows和Unix系统中，执行完一个程序之后，都可以通过 \sphinxcode{\sphinxupquote{echo}} 命令来获取返回值。

Windows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo} \PYGZpc{}ERRORLEVEL\PYGZpc{}
\end{sphinxVerbatim}

Unix:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}?}
\end{sphinxVerbatim}


\subsection{处理命令行选项}
\label{\detokenize{cpp/01_main:id2}}
main函数的形参列表有两种形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

第一种形参 \sphinxcode{\sphinxupquote{*argv{[}{]}}} 中，\sphinxcode{\sphinxupquote{argv}} 是一个数组，它的元素是指向C风格的字符串的指针；
第二种形参 \sphinxcode{\sphinxupquote{**argv}} 中，\sphinxcode{\sphinxupquote{argv}} 指向 \sphinxcode{\sphinxupquote{char*}} 。
参数 \sphinxcode{\sphinxupquote{argc}} 表示数组中字符串的数量。

当实参传给main函数之后，\sphinxcode{\sphinxupquote{argv}} 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。
例如，执行：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{launch} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{ofile} \PYG{n}{data}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{launch}} 是可执行文件。那么， \sphinxcode{\sphinxupquote{argc=5}} ，\sphinxcode{\sphinxupquote{argv}} 包含如下的C风格字符串：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{launch}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}o}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ofile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
当使用 \sphinxcode{\sphinxupquote{argv}} 中的实参时，实参是从 \sphinxcode{\sphinxupquote{argv{[}1{]}}} 开始的； \sphinxcode{\sphinxupquote{argv{[}0{]}}} 保存的是程序名，而非用户输入。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/01_main:id3}}
《C++ Primer 第5版 中文版》 Page 2, Page 197。


\section{数组}
\label{\detokenize{cpp/02_array::doc}}\label{\detokenize{cpp/02_array:id1}}

\subsection{动态数组}
\label{\detokenize{cpp/02_array:id2}}
声明与定义一个动态数组的格式一般如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{da} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{da}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

內存释放：

\fvset{hllines={, 4, 7,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{da}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 释放指针指向的内存空间}
    \PYG{n}{da}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;} \PYG{c+c1}{// 置为空指针，防止出现‘野指针’}
\PYG{p}{\PYGZcb{}}
\PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{da}\PYG{p}{;}
\PYG{n}{da} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\end{sphinxVerbatim}

内存组织形式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
动态数组在堆(heap)区分配内存，静态数组在栈(stack)区分配內存。
\end{sphinxVerbatim}

假如我们已经得到一个3x4的动态数组da，其指针关系如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_dynamicArray}.png}\hspace*{\fill}}

其中，da{[}0{]}、da{[}1{]}、da{[}2{]}的地址是连续的，依次相差 \sphinxcode{\sphinxupquote{sizeof(da{[}0{]})}} (一个指针的大小，32位编译器下为4，64位编译器下为8)，比如:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZam{}}\PYG{n}{da}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{da}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{o}{\PYGZam{}}\PYG{n}{da}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

如果把da看作3行4列的二维数组，那么da的每一行元素的地址是连续的，依次相差 \sphinxcode{\sphinxupquote{sizeof(da{[}0{]}{[}0{]})}} ；但是行与行之间的地址是不连续的，比如:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
da[0][0], da[0][1], da[0][2], da[0][3]地址连续；
da[1][0], da[1][1], da[1][2], da[1][3]地址连续；
da[0][3]与da[1][0]地址不连续；
\end{sphinxVerbatim}

另外:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZam{}da, \PYGZam{}da[0], \PYGZam{}da[0][0]三者的数值是不相等的。
如果数组是静态数组，则\PYGZam{}da, \PYGZam{}da[0], \PYGZam{}da[0][0]三者的数值是相等的；
且静态数组的行与行之间的地址连续。
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
对于动态数组，指针的地址和指针的值不能混淆，我们讲da{[}0{]}、da{[}1{]}、da{[}2{]}的地址是连续的，但是他们本身的值没有关系，即 \sphinxcode{\sphinxupquote{da{[}0{]} + sizeof(da{[}0{]}) != da{[}1{]}}} 。
注意有没有 \sphinxcode{\sphinxupquote{\&}} 的区别。
\end{sphinxadmonition}

如果想要定义连续内存空间的动态数组，可以按如下方式进行：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// int** f; // f的声明}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{Init2DArray}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*}\PYG{o}{*} \PYG{o}{\PYGZam{}}\PYG{n}{f}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{row}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{col}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{f} \PYG{o}{=} \PYG{k}{new} \PYG{n}{T}\PYG{o}{*}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{k}{new} \PYG{n}{T}\PYG{p}{[}\PYG{n}{row} \PYG{o}{*} \PYG{n}{col}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{col}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{f}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{col} \PYG{o}{*} \PYG{n}{i}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

内存释放方式如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{Delete2DArray}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*}\PYG{o}{*} \PYG{o}{\PYGZam{}}\PYG{n}{f}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{f} \PYG{o}{!}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{f}\PYG{p}{;}
        \PYG{n}{f} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

上面的 \sphinxcode{\sphinxupquote{Init2DArray}} 在申请内存的时候，建立了row x col的二维动态数组。实际上，二维动态数组不强求列对齐，即各行的长度可以不一样，
因此可以下面像这样定义:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{offset\PYGZus{}i}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{offset\PYGZus{}i是第i行首地址相对于第0行首地址的偏移量}
\end{sphinxVerbatim}


\subsection{另类的数组表达}
\label{\detokenize{cpp/02_array:id3}}
有如下程序：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}

\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{l+m+mi}{9}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;}
\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\end{sphinxVerbatim}

这些表达式能够正常编译和执行，是因为对于C/C++而言:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{n}{等价于}\PYG{o}{*}\PYG{n}{a等价于}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{n}{等价于}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{+}\PYG{n}{a}\PYG{p}{)} \PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{等价于0}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

所以可以推出二维表达式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{[}\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{数组实参}
\label{\detokenize{cpp/02_array:id4}}
以 \sphinxstylestrong{非引用} 类型传递数组实参时，数组会退化为指针，形参复制的是这个指针的值(指向数组的第一个元素)。通过指针形参做的任何改变，都是在修改数组元素本身。

如果以 \sphinxstylestrong{引用} 形式传递数组实参，那么编译器不会将数组实参转化为指针，而是传递数组的引用本身。

编译器会检查数组实参的大小与形参大小是否匹配。

非引用形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 函数可能会改变数组}
\PYG{k+kt}{void} \PYG{n+nf}{func2}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 不能改变数组}

\PYG{k+kt}{void} \PYG{n+nf}{func3}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}\PYG{c+c1}{// 4}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// int arr[100];}
\PYG{c+c1}{// func3(arr); // 调用func3}
\end{sphinxVerbatim}

引用形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func4}\PYG{p}{(}\PYG{k+kt}{int} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}\PYG{c+c1}{// 100}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// int arr[100];}
\PYG{c+c1}{// func4(arr); // 调用func4}
\end{sphinxVerbatim}


\subsection{数组地址与加法}
\label{\detokenize{cpp/02_array:id5}}
假设我们已经定义了一个数组：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Type} \PYG{n}{a}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]}\PYG{p}{[}\PYG{n}{M}\PYG{p}{]}\PYG{p}{[}\PYG{n}{N}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{1}. \sphinxcode{\sphinxupquote{a}} , \sphinxcode{\sphinxupquote{a{[}0{]}}} , \sphinxcode{\sphinxupquote{a{[}0{]}{[}0{]}}} , \sphinxcode{\sphinxupquote{\&a}} , \sphinxcode{\sphinxupquote{\&a{[}0{]}}} , \sphinxcode{\sphinxupquote{\&a{[}0{]}{[}0{]}}} , \sphinxcode{\sphinxupquote{\&a{[}0{]}{[}0{]}{[}0{]}}} 的数值都是一样的。

\sphinxstylestrong{2}. \sphinxcode{\sphinxupquote{\&a}} 是4级指针, 类型是 \sphinxcode{\sphinxupquote{int (*){[}L{]}{[}M{]}{[}N{]}}} ，指向a这个数组。

\sphinxstylestrong{3}. \sphinxcode{\sphinxupquote{a}} 是3级指针，类型是 \sphinxcode{\sphinxupquote{int (*){[}M{]}{[}N{]}}} ，三维数组的数组名，是数组a的首地址。

\sphinxstylestrong{4}. 大小计算如下:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sizeof(\PYGZam{}a) = 4;// 指针的大小，32位编译器
sizeof(a[0][0][0]) = sizeof(Type);
sizeof(a[0][0]) = N * sizeof(Type);
sizeof(a[0]) = M * N * sizeof(Type);
sizeof(a) = L * M * N * sizeof(Type);// 整个数组的大小
\end{sphinxVerbatim}

\sphinxstylestrong{5}. 加法运算:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
a + i = a + i * sizeof(a[0]);
\PYGZam{}a + i = a + i * sizeof(a);
这里（\PYGZam{}a + 1）就已经跳过了整个数组。
\end{sphinxVerbatim}

\sphinxstylestrong{6}. 定义指针 \sphinxcode{\sphinxupquote{int *ptr = (int *)(\&a + 1)}} ，则 \sphinxcode{\sphinxupquote{(ptr - 1)}} 指向数组a的最后一个元素。


\subsection{malloc/free与new/delete}
\label{\detokenize{cpp/02_array:malloc-freenew-delete}}

\subsubsection{相同点}
\label{\detokenize{cpp/02_array:id6}}
都可用于申请动态内存和释放内存。


\subsubsection{不同点}
\label{\detokenize{cpp/02_array:id7}}\begin{enumerate}
\item {} 
属性
\begin{quote}

\sphinxcode{\sphinxupquote{malloc/free}} 是C/C++的 \sphinxstylestrong{库函数} ，在头文件 \sphinxcode{\sphinxupquote{stdlib.h}} 中声明。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{o}{*}\PYG{n+nf}{malloc}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{size}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{free}\PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{pointer}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

因为malloc()函数的返回值类型为 \sphinxcode{\sphinxupquote{void*}} ，所以需要在函数前面进行相应的强制类型转换。

\sphinxcode{\sphinxupquote{new/delete}} 是C++的 \sphinxstylestrong{运算符} 。
\end{quote}

\item {} 
参数
\begin{quote}

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
int *pi=new int[n]; //指针pi指向长度为n的数组，未初始化
\end{sphinxVerbatim}

而malloc则需要显式地指出所需内存的尺寸。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{o}{*}\PYG{n}{p}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{int} \PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{n}{sizeof}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/}\PYG{n}{指向整型的指针p指向一个25个int整型空间的地址}
\PYG{n+nb}{int} \PYG{o}{*}\PYG{n}{p}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{int} \PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{l+m+mi}{99}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/}\PYG{n}{指向整型的指针p指向一个大小为99字节的内存的地址}
\end{sphinxVerbatim}

malloc可以分配任意字节，new 只能分配实例所占内存的整数倍数大小。
\end{quote}

\item {} 
分配失败
\begin{quote}

new内存分配失败时，会抛出 \sphinxcode{\sphinxupquote{bad\_alloc}} 异常；malloc分配内存失败时返回 \sphinxcode{\sphinxupquote{NULL}} 。
\end{quote}

\item {} 
功能
\begin{quote}

new做两件事，先分配内存，再调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。

对于内部数据类型(如 \sphinxcode{\sphinxupquote{int}} , \sphinxcode{\sphinxupquote{char}} 等)的对象，没有构造和析构的过程，对它们而言， \sphinxcode{\sphinxupquote{malloc/free}} 和 \sphinxcode{\sphinxupquote{new/delete}} 等价。

对于非内部数据类型的对象而言， \sphinxcode{\sphinxupquote{malloc/free}} 无法满足动态对象的要求。
\end{quote}

\item {} 
重载(overload)
\begin{quote}

\sphinxcode{\sphinxupquote{new/delete}} 可以重载成为函数，可以自定义申请过程，比如记录申请内存的长度以及跟踪每个对象的指针。

\sphinxcode{\sphinxupquote{malloc/free}} 不能重载。
\end{quote}

\end{enumerate}


\subsection{参考资料}
\label{\detokenize{cpp/02_array:id8}}\begin{enumerate}
\item {} 
静态数组与动态数组：

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/liupeng900605/article/details/7526753}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
浅谈new/delete和malloc/free的用法与区别：

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/maluning/p/7944231.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
malloc/free与new/delete的区别：

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/hackbuteer1/article/details/6789164}
\end{quote}


\section{数据类型}
\label{\detokenize{cpp/03_typeSize::doc}}\label{\detokenize{cpp/03_typeSize:id1}}

\subsection{常用内置数据类型的大小}
\label{\detokenize{cpp/03_typeSize:id2}}
以下结果若非特别指出，均在Windows系统下由编译器Visual Studio测试得到。


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
类型
&\sphinxstyletheadfamily 
size/32位编译器
&\sphinxstyletheadfamily 
size/64位编译器
\\
\hline
char
&
1
&
1
\\
\hline
char*
&
4
&
8
\\
\hline
int
&
4
&
4
\\
\hline
int*
&
4
&
8
\\
\hline
short
&
2
&
2
\\
\hline
long
&
4
&
4 (8/linux)
\\
\hline
long*
&
4
&
8
\\
\hline
long long
&
8
&
8
\\
\hline
float
&
4
&
4
\\
\hline
double
&
8
&
8
\\
\hline
size\_t
&
4
&
8
\\
\hline
size\_type
&
4
&
8
\\
\hline
bool
&
1
&
1
\\
\hline
string
&
28
&
40
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{sizeof与strlen}
\label{\detokenize{cpp/03_typeSize:sizeofstrlen}}\begin{enumerate}
\item {} 
sizeof
\begin{quote}

\sphinxcode{\sphinxupquote{sizeof()}} 是 \sphinxstylestrong{运算符} ，计算的是分配的内存空间大小(单位为字节)，编译时就会计算，不受里面存储内容的影响。

\sphinxcode{\sphinxupquote{sizeof()}} 可以用数据类型、数组、字符串等做参数。
\end{quote}

\item {} 
strlen
\begin{quote}

\sphinxcode{\sphinxupquote{strlen()}} 是 \sphinxstylestrong{函数} ，计算的是字符串的实际长度(字符的个数)，以 \sphinxcode{\sphinxupquote{'\textbackslash{}0'}} 结束但长度 \sphinxstylestrong{不包括} \sphinxcode{\sphinxupquote{'\textbackslash{}0'}} ，程序执行时才计算结果。
\sphinxcode{\sphinxupquote{strlen()}} 只能用 \sphinxcode{\sphinxupquote{char*}} 类型做参数。
\end{quote}

\item {} 
实例
\begin{quote}

定义以下变量：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{strA} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdef}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strB}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdef}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strC}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strD}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strE}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strF}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

结果如下:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sizeof(strA) = 4 : 指针的大小
sizeof(strB) = 7 : 该字符数组用字符串初始化，因此strB就是一个字符串，字符串以\PYGZsq{}\PYGZbs{}0\PYGZsq{}结尾，则大小为6+1=7
sizeof(strC) = 5 : 字符数组所占内存为5字节
sizeof(strD) = 3 : 字符数组所占内存为3字节
sizeof(strE) = 3 : 字符数组中有3个字符
sizeof(strF) = 4 : 字符数组中有4个字符，包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
sizeof(y) = 12 : 4 * 3 = 12 字节

strlen(strA) = 6 : 字符串长度为6，不包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
strlen(strB) = 6 : 字符串长度为6，不包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
strlen(strC) = 1 : 字符数组中只有1个字符
strlen(strD)不定，因为数组strD末尾没有人为补\PYGZsq{}\PYGZbs{}0\PYGZsq{}，因此strD是一个普通的字符数组，而不是字符串
strlen(strE)不定，因为数组strE末尾没有人为补\PYGZsq{}\PYGZbs{}0\PYGZsq{}，因此strD是一个普通的字符数组，而不是字符串
strlen(strF) = 3 : 字符串长度为3，不包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
如果字符数组以字符常量进行初始化且字符个数大于1，如上例中的 \sphinxcode{\sphinxupquote{strD}} 和 \sphinxcode{\sphinxupquote{strE}} ，
如果不在末尾人为添加 \sphinxcode{\sphinxupquote{'\textbackslash{}0'}} ，则该字符数组不是字符串，
使用函数 \sphinxcode{\sphinxupquote{strlen}} 求得的大小不定，且该字符数组的内容也是未知的。
虽然 \sphinxcode{\sphinxupquote{strD}} 只有3个字节空间且刚好包含3个字符，但是 \sphinxcode{\sphinxupquote{cout\textless{}\textless{}strD}} 的结果也是不定的。
正确的定义应该是 \sphinxcode{\sphinxupquote{strF}} 。
\end{sphinxadmonition}
\end{quote}

\end{enumerate}


\subsection{参考资料}
\label{\detokenize{cpp/03_typeSize:id3}}\begin{enumerate}
\item {} 
数据类型的数值范围

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qianbitou000/article/details/51939055/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
关于strlen与sizeof的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zhengqijun\_/article/details/51815081}
\end{quote}


\section{类的大小}
\label{\detokenize{cpp/04_classSize::doc}}\label{\detokenize{cpp/04_classSize:id1}}
计算类的大小遵循以下原则：
\begin{itemize}
\item {} 
内存对齐。

\item {} 
类的大小与普通数据成员有关，与成员函数、静态成员无关。即普通成员函数、静态成员函数、静态数据成员均对类的大小无影响。

\item {} 
虚函数对类的大小的影响体现在 \sphinxstylestrong{虚函数表指针} 的大小。

\item {} 
虚继承对类的大小的影响体现在 \sphinxstylestrong{虚基类表指针} 的大小。

\end{itemize}

以下结果均是在32位 Visual Studio 2013 下编译得到。


\subsection{空类}
\label{\detokenize{cpp/04_classSize:id2}}
C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。这是由于：
\begin{itemize}
\item {} 
new需要分配不同的内存地址，不能分配内存大小为0的空间 。

\item {} 
避免除以sizeof(*)时得到除以0错误

\end{itemize}

每个类在内存中都有唯一的标识，因此空类被实例化时，编译器会隐含地为其添加一个字节，以作区分。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Empty}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Empty) = 1}
\end{sphinxVerbatim}


\subsection{普通数据成员}
\label{\detokenize{cpp/04_classSize:id3}}
遵循内存对齐原则。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(A) = 4 + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{B}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(B) = 8 + 8 = 16}
\end{sphinxVerbatim}


\subsection{普通继承}
\label{\detokenize{cpp/04_classSize:id4}}
普通类的继承，派生类的大小=派生类数据成员大小+基类数据成员大小。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{B}\PYG{o}{:} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{ch}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{b}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(B) = 8 + 8 = 16 (对齐： 4+1 \PYGZhy{}\PYGZgt{} 8)}

\PYG{k}{class} \PYG{n+nc}{C}\PYG{o}{:} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{c}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{ch}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(C) = 8 + 8 + 8 = 24 (对齐： 4 \PYGZhy{}\PYGZgt{} 8, 1 \PYGZhy{}\PYGZgt{} 8)}
\end{sphinxVerbatim}


\subsubsection{继承空类}
\label{\detokenize{cpp/04_classSize:id5}}
派生类继承空类后，派生类如果有自己的数据成员，而空基类的一个字节并不会加到派生类中去。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Empty}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{A}\PYG{o}{:} \PYG{k}{public} \PYG{n}{Empty}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(A) = 4}
\end{sphinxVerbatim}


\subsubsection{类包含空类对象数据成员}
\label{\detokenize{cpp/04_classSize:id6}}
空类的1字节是会被计算进去的。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Empty}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Empty} \PYG{n}{e}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(A) = 4 + 4 = 8}
\end{sphinxVerbatim}


\subsection{虚函数与继承}
\label{\detokenize{cpp/04_classSize:id7}}
虚函数（Virtual Function）是通过一张 \sphinxstylestrong{虚函数表（Virtual Table, vtable）} 来实现的。
每当 \sphinxstylestrong{创建一个包含有虚函数的类} 或 \sphinxstylestrong{从包含有虚函数的类派生一个类} 时，编译器就会为这个类创建一个虚函数表保存该类 \sphinxstylestrong{所有虚函数} 的地址。

当一个类中包含虚函数时，会有一个指向其虚函数表的指针vptr，系统为类指针分配大小为4个字节(即使有多个虚函数)。
当构造该派生类对象时，其成员vptr被初始化指向该派生类的vtable。
所以可以认为vtable是该类的所有对象共有的，在定义该类时被初始化；而vptr则是每个类对象都有独立一份的，且在该类对象被构造时被初始化。


\subsubsection{单继承}
\label{\detokenize{cpp/04_classSize:id8}}
派生类的大小 = 派生类的普通数据成员的大小 + 1个vptr指针的大小

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Base}
\PYG{p}{\PYGZob{}}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Base) = 4}

\PYG{k}{class} \PYG{n+nc}{Derived}\PYG{o}{:} \PYG{k}{public} \PYG{n}{Base}
\PYG{p}{\PYGZob{}}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 覆盖了基类中的f1()， **多态**}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Derived) = 4 + 4 = 8}
\end{sphinxVerbatim}


\subsubsection{多继承}
\label{\detokenize{cpp/04_classSize:id9}}
每个基类都有自己的虚表(vtable)。

派生类的成员函数被放到了第一个基类的表中。

派生类的大小 = 派生类的普通数据成员的大小 + 基类的普通数据成员的大小 + \sphinxstylestrong{n} 个vptr指针的大小。 \sphinxstylestrong{n} 是继承的基类的个数。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(A) = 1}

\PYG{k}{class} \PYG{n+nc}{B}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{ch}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f0}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(B) = 4 + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{C}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{ch1}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{ch2}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(C) = 4 + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{D}\PYG{o}{:} \PYG{k}{public} \PYG{n}{A}\PYG{p}{,} \PYG{k}{public} \PYG{n}{C}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{d}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(D) = 4 + 4 + 1*4 = 12}

\PYG{k}{class} \PYG{n+nc}{E}\PYG{o}{:} \PYG{k}{public} \PYG{n}{B}\PYG{p}{,} \PYG{k}{public} \PYG{n}{C}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{e}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f0}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(E) = 4 + 4 + 4 + 2*4 = 20}
\end{sphinxVerbatim}


\subsection{虚继承}
\label{\detokenize{cpp/04_classSize:id10}}
尽管派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接
继承某个基类，然后通过另一个基类再一次间接继承该类。

在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现多次，则派生类中将包含该类的多个子对象。这会导致两个问题：第一，
浪费存储空间；第二，存在二义性。

虚继承可以解决上述问题。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{04_virtualInheritance}.png}\hspace*{\fill}}

虚继承的目的是令某个类做出声明，承诺共享它的基类。其中，共享的基类子对象称为 \sphinxstylestrong{虚基类} (上图中的类 \sphinxstylestrong{A} )。
在这种机制下，不论虚基类在继承体系中
出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。

虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现。
每个虚继承的子类都有一个 \sphinxstylestrong{虚基类指针(Virtual Base Table Pointer，vbptr，占用一个指针的存储空间)} 和虚基类表( \sphinxstylestrong{不占用} 类对象的存储空间)
(需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了)。

实际上，vbptr指向了一个 \sphinxstylestrong{虚基类表(Virtual Table)} ，虚基类表中记录了虚基类与本类的偏移地址。
通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类(虚基类)的两份同样的拷贝，节省了存储空间。

当虚继承的子类被当做父类继承时，虚基类指针也会被继承。上图中，C继承了B1，B2，也就继承了2个虚基类指针。

总体需要考虑：数据成员的大小、虚基类指针的大小 、虚函数指针的大小。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A} \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(A) = 4}

\PYG{k}{class} \PYG{n+nc}{B} \PYG{o}{:}\PYG{k}{virtual} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
      \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{myfunB}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(B) = 16}

\PYG{k}{class} \PYG{n+nc}{C} \PYG{o}{:}\PYG{k}{virtual} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{double} \PYG{n}{c}\PYG{p}{;}
      \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{myfunC}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(C) = 28}

\PYG{k}{class} \PYG{n+nc}{D} \PYG{o}{:}\PYG{k}{public} \PYG{n}{B}\PYG{p}{,} \PYG{k}{public} \PYG{n}{C}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{d}\PYG{p}{;}
      \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{myfunD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(D) = 52}
\end{sphinxVerbatim}


\subsection{内存对齐}
\label{\detokenize{cpp/04_classSize:id11}}\begin{description}
\item[{内存对齐，是为了让内存存取更有效率而采用的一种编译阶段优化内存存取的手段。}] \leavevmode\begin{itemize}
\item {} 
内存对齐是指首地址对齐，而不是说每个变量大小对齐。

\item {} 
分配内存的顺序是按照声明的顺序。

\item {} 
每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，如果不是整数倍则空出内存，直到偏移量是整数倍为止。

\item {} 
结构体内存对齐要求结构体内每一个成员变量都是内存对齐的。

\item {} 
整个结构体的大小必须是结构体里面变量类型最大值的整数倍。

\item {} 
如果一个结构里有某些结构体成员，则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。比如，struct A里存有struct B，B里有char, int, double等类型的成员变量，那B应该从8的整数倍开始存储。

\end{itemize}

\item[{内存对齐的作用：}] \leavevmode\begin{itemize}
\item {} 
平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

\item {} 
性能原因：经过内存对齐后，CPU的内存访问速度大大提升。

\end{itemize}

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Data}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{d}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Data) = 1 + (3) + 4 + 1 + (3) = 12，括号内表示补齐的字节数。}

\PYG{k}{class} \PYG{n+nc}{Data}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{d}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Data) = 1 + 1 + (2) + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{BigData}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{char} \PYG{n}{array}\PYG{p}{[}\PYG{l+m+mi}{33}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BigData) = 33}

\PYG{k}{class} \PYG{n+nc}{Data}
\PYG{p}{\PYGZob{}}
      \PYG{n}{BigData} \PYG{n}{bd}\PYG{p}{;}
      \PYG{c+c1}{//int integer; // 不管有没有注释这一行，sizeof(Data)结果一样}
      \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{;} \PYG{c+c1}{// d的起始偏移量必须为8的倍数，且大于33，则其偏移量为40}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Data) = 48}
\end{sphinxVerbatim}


\subsection{位域}
\label{\detokenize{cpp/04_classSize:id12}}
C/C++中以一定区域内的位(bit)为单位来表示的数据成为位域，位域必须指明具体的数目。
位域的作用主要是节省内存资源，使数据结构更紧凑。
\begin{enumerate}
\item {} 
一个位域必须存储在同一个字节中，不能跨两个字节，故位域的长度不能大于一个字节的长度

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{BitField}
 \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int}  \PYG{o}{:}\PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{//空位域,自动置0;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位,从第二个字节存储单元开始存放;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{d}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{;}  \PYG{c+c1}{//占用5个二进制位,剩余的3个bit不够存储4个bit的数据,从下一个存储单元开始存放;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int}  \PYG{o}{:}\PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{//空位域,自动置0;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{e}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位,从第三个字节存储单元开始存放;}
 \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
取地址操作符\&不能应用在位域字段上

\item {} 
位域字段不能是类的静态成员

\item {} 
位域字段在内存中的位置是按照从低位向高位的顺序放置的

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{BitField}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}  \PYG{c+c1}{//最低位;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}  \PYG{c+c1}{//最高位;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
位域的对齐

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{BFA}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BFA) = 1}

\PYG{k}{struct} \PYG{n}{BFB}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int}  \PYG{n+nl}{d}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BFA) = 1 + (3) + 4 = 8}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
一个例子

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{num}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{struct} \PYG{n}{num} \PYG{n}{n} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{.}\PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{.}\PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{.}\PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\(8 = (00001000)_2\) ， \(8\) 在计算机中的补码也是 \sphinxcode{\sphinxupquote{00001000}} ， \(a\) 用3位表示，取低位为 \sphinxcode{\sphinxupquote{000}} ( \sphinxcode{\sphinxupquote{00000000}} )，原码也是 \sphinxcode{\sphinxupquote{00000000}} ，则 \(a = 0\) 。

\item {} 
\(-6 = (10000110)_2\) ， \(-6\) 在计算机中的补码是 \sphinxcode{\sphinxupquote{11111010}} ， \(b\) 用2位表示，取低位为 \sphinxcode{\sphinxupquote{10}} ( \sphinxcode{\sphinxupquote{11111110}} )，原码是 \sphinxcode{\sphinxupquote{10000010}} ，则 \(b = -2\) 。

\item {} 
\(5 = (00000101)_2\) ， \(5\) 在计算机中的补码也是 \sphinxcode{\sphinxupquote{00000101}} ， \(c\) 用1位表示，取低位为 \sphinxcode{\sphinxupquote{1}} ( \sphinxcode{\sphinxupquote{11111111}} )，原码是 \sphinxcode{\sphinxupquote{10000001}} ，则 \(c = -1\) 。

\end{itemize}
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
C++标准库提供了一个 \sphinxstylestrong{bitset} 类模板，它可以辅助操纵位的集合。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/04_classSize:id13}}\begin{enumerate}
\item {} 
c++ 类大小问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/sz-leez/p/7119232.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
c++类的大小计算

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/fengxinlinux/article/details/72836199}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
虚继承

\end{enumerate}
\begin{quote}

《C++ Primer 第5版 中文版》 Page 717-718。
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
C++中虚继承的作用及底层实现原理

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/bxw1992/article/details/77726390}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
c++中的内存对齐

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/suntp/p/MemAlignment.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
C/C++ 内存对齐原则及作用

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/chy19911123/article/details/48894579}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
C/C++位域知识小结

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/pure/archive/2013/04/22/3034818.html}
\end{quote}


\section{交换函数swap}
\label{\detokenize{cpp/05_swap::doc}}\label{\detokenize{cpp/05_swap:swap}}
\sphinxstylestrong{1}. 库函数，包含在头文件 \sphinxcode{\sphinxupquote{\textless{}algorithm\textgreater{}}} 中。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{2}. 指针。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{T} \PYG{o}{*}\PYG{n}{x}\PYG{p}{,} \PYG{n}{T} \PYG{o}{*}\PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{T} \PYG{n}{tmp} \PYG{o}{=} \PYG{o}{*}\PYG{n}{x}\PYG{p}{;}
    \PYG{o}{*}\PYG{n}{x} \PYG{o}{=} \PYG{o}{*}\PYG{n}{y}\PYG{p}{;}
    \PYG{o}{*}\PYG{n}{y} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{3}. 引用。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{T} \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{4}. 异或。适用于整型/字符/枚举类型，浮点型不适用。 \sphinxcode{\sphinxupquote{swap(a, a)}} 会导致 \sphinxcode{\sphinxupquote{a=0}} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define swap(a, b) a\PYGZca{}=b\PYGZca{}=a\PYGZca{}=b;}
\end{sphinxVerbatim}

\sphinxstylestrong{4}. 赋值。受编译器影响，先执行 \sphinxcode{\sphinxupquote{a+b}} 还是先执行 \sphinxcode{\sphinxupquote{b=a}} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define swap(a, b) a=a+b\PYGZhy{}(b=a);}
\end{sphinxVerbatim}

\sphinxstylestrong{5}. 加减。无需申请额外空间。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{数组形参}
\label{\detokenize{cpp/06_arrayArg::doc}}\label{\detokenize{cpp/06_arrayArg:id1}}

\subsection{非引用}
\label{\detokenize{cpp/06_arrayArg:id2}}
当数组以 \sphinxstylestrong{非引用} 类型传递，数组会悄悄退化为指针，形参复制的是这个指针的值（指向数组第一个元素）。通过该形参做的任何改变都是在修改数组元素本身。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 指针的大小为4（32位编译器）}
    \PYG{c+cm}{/*}
\PYG{c+cm}{        function body}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{func2}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 指针的大小为4（32位编译器）}
    \PYG{c+cm}{/*}
\PYG{c+cm}{        function body}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{func2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{引用}
\label{\detokenize{cpp/06_arrayArg:id3}}
如果形参是数组的 \sphinxstylestrong{引用} ，编译器不会将数组实参转化为指针，而是传递数组的引用本身。编译器会检查数组实参的大小与形参是否匹配。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 大小为4*10=40（32位编译器）}
    \PYG{c+cm}{/*}
\PYG{c+cm}{        function body}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{func2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{指针与引用}
\label{\detokenize{cpp/07_pointerReference::doc}}\label{\detokenize{cpp/07_pointerReference:id1}}
\sphinxstylestrong{1}. \sphinxstylestrong{非常量} 指针可以被重新赋值，指向另一个对象；引用是对象的别名，必须初始化并总是指向（代表）最初绑定的那个对象。

\sphinxstylestrong{2}. 有 \sphinxcode{\sphinxupquote{null pointer}} ，没有 \sphinxcode{\sphinxupquote{null reference}} ，故使用前无需检查是非为空。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{rValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{pValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{p} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{3}. 例子。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{string} \PYG{n+nf}{s1}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nancy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{s2}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{candy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{rs} \PYG{o}{=} \PYG{n}{s1}\PYG{p}{;}
\PYG{n}{string}\PYG{o}{*} \PYG{n}{ps} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{s2}\PYG{p}{;}
\PYG{n}{rs} \PYG{o}{=} \PYG{n}{s2}\PYG{p}{;} \PYG{c+c1}{// rs仍指向s1，但是s1值变为\PYGZdq{}candy\PYGZdq{}。}
\PYG{n}{ps} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{s2}\PYG{p}{;} \PYG{c+c1}{// ps指向s2，s1无变化}
\end{sphinxVerbatim}


\section{重载，覆盖，隐藏}
\label{\detokenize{cpp/08_overload::doc}}\label{\detokenize{cpp/08_overload:id1}}

\subsection{重载}
\label{\detokenize{cpp/08_overload:id2}}
同一可访问区内被声明的几个具有不同参数列表（参数个数，参数类型，参数顺序）的同名函数。不关心函数返回类型。


\subsection{覆盖}
\label{\detokenize{cpp/08_overload:id3}}
基类中被重写的函数，用 \sphinxcode{\sphinxupquote{virtual}} 修饰。派生类重写的函数与被重写的函数保持同样的函数名、参数列表、返回类型。


\subsection{隐藏}
\label{\detokenize{cpp/08_overload:id4}}
派生类中的函数屏蔽了基类中的同名函数，不管参数列表是否相同。当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被覆盖。


\subsection{参考资料}
\label{\detokenize{cpp/08_overload:id5}}\begin{enumerate}
\item {} 
C++中重载、重写（覆盖）和隐藏的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zx3517288/article/details/48976097}
\end{quote}


\section{strcpy函数}
\label{\detokenize{cpp/09_strcpy:strcpy}}\label{\detokenize{cpp/09_strcpy::doc}}
函数定义：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{char}\PYG{o}{*} \PYG{n+nf}{strcpy}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{dst}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{src}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cp} \PYG{o}{=} \PYG{n}{dst}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(} \PYG{o}{*}\PYG{n}{cp}\PYG{o}{+}\PYG{o}{+} \PYG{o}{=} \PYG{o}{*}\PYG{n}{src}\PYG{o}{+}\PYG{o}{+} \PYG{p}{)}\PYG{p}{;}  \PYG{c+cm}{/* Copy src over dst */}
    \PYG{k}{return}\PYG{p}{(} \PYG{n}{dst} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{char} \PYG{n}{src}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{dst}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{copy} \PYG{o}{=} \PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{dst}\PYG{p}{,} \PYG{n}{src}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{形参src}
\label{\detokenize{cpp/09_strcpy:src}}
形参 \sphinxcode{\sphinxupquote{src}} 定义为  \sphinxcode{\sphinxupquote{const}} ，防止函数对其进行修改。


\subsection{额外指针cp}
\label{\detokenize{cpp/09_strcpy:cp}}
\sphinxcode{\sphinxupquote{cp++}} 导致复制结束时， \sphinxcode{\sphinxupquote{cp}} 指向的是 \sphinxcode{\sphinxupquote{dst}} 绑定的字符串的尾部，因此不能直接返回 \sphinxcode{\sphinxupquote{cp}} 。


\subsection{返回值}
\label{\detokenize{cpp/09_strcpy:id1}}
为了实现链式操作，将目的地址返回。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{length} \PYG{o}{=} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{strcpy}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello World}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{cpp/09_strcpy:id2}}\begin{enumerate}
\item {} 
标准的strcpy函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/elisha-blogs/p/4125799.html}
\end{quote}


\section{强制类型转换}
\label{\detokenize{cpp/10_cast::doc}}\label{\detokenize{cpp/10_cast:id1}}

\subsection{static\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:static-cast-type-expr}}
\sphinxstylestrong{1}. \sphinxcode{\sphinxupquote{static\_cast}} 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，
所以这类型的强制转换和C语言风格的强制转换都有安全隐患。

\sphinxstylestrong{2}. 用于基本数据类型之间的转换，如把 \sphinxcode{\sphinxupquote{int}} 转换成 \sphinxcode{\sphinxupquote{char}} ，把 \sphinxcode{\sphinxupquote{int}} 转换成 \sphinxcode{\sphinxupquote{enum}} 。这种转换的安全性需要开发者来维护。

\sphinxstylestrong{3}. C++ 的任何的隐式转换都是使用 \sphinxcode{\sphinxupquote{static\_cast}} 来实现。

\sphinxstylestrong{4}. 基类和子类之间转换：其中子类指针转换成父类指针是安全的；但父类指针转换成子类指针是不安全的。(基类和子类之间的动态类型转换建议用dynamic\_cast)

\sphinxstylestrong{5}. 把空指针转换成目标类型的空指针。

\sphinxstylestrong{6}. 把任何类型的表达式转换成void类型。


\subsection{dynamic\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:dynamic-cast-type-expr}}
有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)：

\sphinxstylestrong{1}. 安全的基类和子类之间转换。

\sphinxstylestrong{2}. 必须要有虚函数。

\sphinxstylestrong{3}. 相同基类不同子类之间的交叉转换。但结果是NULL。


\subsection{const\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:const-cast-type-expr}}
\sphinxstylestrong{1}. 去掉类型的const、volitale属性;

\sphinxstylestrong{2}. 常量指针被转化成非常量的指针，并且仍然指向原来的对象；

\sphinxstylestrong{3}. 常量引用被转换成非常量的引用，并且仍然指向原来的对象；

\sphinxstylestrong{4}. const\_cast一般用于修改指针。如const char {\color{red}\bfseries{}*}p形式。


\subsection{reinterpret\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:reinterpret-cast-type-expr}}
\sphinxstylestrong{1}. reinterpret\_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差。

\sphinxstylestrong{2}. reinterpret\_cast可以将整型转换为指针，也可以把指针转换为数组。

\sphinxstylestrong{3}. reinterpret\_cast可以在指针和引用里进行肆无忌惮的转换。


\subsection{参考资料}
\label{\detokenize{cpp/10_cast:id4}}\begin{enumerate}
\item {} 
C++中四种强制类型转换区别详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/cauchy007/p/4968707.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
c++ 四种强制类型转换介绍

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/ydar95/article/details/69822540}
\end{quote}


\section{堆、栈}
\label{\detokenize{cpp/11_heapStack::doc}}\label{\detokenize{cpp/11_heapStack:id1}}
堆（Heap）与栈（Stack）有两层含义：
（1）程序内存布局场景下，堆与栈表示的是两种内存管理方式；
（2）数据结构场景下，堆与栈表示两种常用的数据结构。

栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。

堆由程序员分配释放， 若程序员不释放，程序结束时由系统回收。


\subsection{管理方式}
\label{\detokenize{cpp/11_heapStack:id2}}
栈由操作系统自动分配释放，无需我们手动控制；

堆的申请和释放工作由程序员控制，容易产生内存泄漏。


\subsection{空间大小}
\label{\detokenize{cpp/11_heapStack:id3}}
每个进程拥有的栈的大小要远远小于堆的大小。
理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小64bits的Windows默认1MB，64bits的Linux默认10MB；


\subsection{分配方式}
\label{\detokenize{cpp/11_heapStack:id4}}
堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。

动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。


\subsection{生长方式}
\label{\detokenize{cpp/11_heapStack:id5}}
堆的生长方向向上，内存地址由低到高。

栈的生长方向向下，内存地址由高到低。


\subsection{分配效率}
\label{\detokenize{cpp/11_heapStack:id6}}
栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。

堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。


\subsection{存放内容}
\label{\detokenize{cpp/11_heapStack:id7}}
栈存放函数返回地址、相关参数、局部变量和寄存器内容等。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。


\subsection{附：内存分区}
\label{\detokenize{cpp/11_heapStack:id8}}
在C++中，内存主要分为堆、栈、全局/静态存储区和常量存储区。
\begin{itemize}
\item {} 
\sphinxstylestrong{栈} ：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。

\item {} 
\sphinxstylestrong{堆} ：就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

\item {} 
\sphinxstylestrong{全局/静态存储区} ：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

\item {} 
\sphinxstylestrong{常量存储区} ：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{cpp/11_heapStack:id9}}\begin{enumerate}
\item {} 
堆与栈的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/K346K346/article/details/80849966}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C/C++——堆栈的讲解

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/lovejay7/article/details/80662390}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++ 自由存储区是否等价于堆？

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/QG-whz/p/5060894.html}
\end{quote}


\section{参数传递}
\label{\detokenize{cpp/12_argPass::doc}}\label{\detokenize{cpp/12_argPass:id1}}
当形参是引用类型时，称对应实参被 \sphinxstylestrong{引用传递} （passed by reference）或者函数被 \sphinxstylestrong{传引用调用} （called by reference）。

当实参的值被 \sphinxstylestrong{拷贝} 给形参时，形参和实参时两个相互独立的对象。这样的实参被 \sphinxstylestrong{值传递} （passed by value)或者函数被 \sphinxstylestrong{传值调用} （called by value）。


\subsection{传值参数}
\label{\detokenize{cpp/12_argPass:id2}}
当初始化一个非引用类型的变量时，初始化被拷贝给变量。此时，对变量的改动 \sphinxstylestrong{不会} 影响初始值。
\begin{description}
\item[{\sphinxstylestrong{指针形参}}] \leavevmode
指针的行为和其他 \sphinxstylestrong{非引用} 类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后， \sphinxstylestrong{两个指针是不同的指针} 。因为指针
使我们可以间接地访问它所指的对象，所以通过指针 \sphinxstylestrong{可以修改它所指的对象的值} 。

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{reset}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针p所指对象的值}
   \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 只改变了p的局部拷贝，实参未被改变}
\PYG{p}{\PYGZcb{}}

\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{x}\PYG{p}{,} \PYG{n}{T}\PYG{o}{*} \PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{T}\PYG{o}{*} \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  只交换了拷贝指针的值，实际指针并未改变，因此无法达到交换的目的。}
\end{sphinxVerbatim}

为了改变实参指针的值，可以使用指针的引用或者使用指向指针的指针。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{val} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{val}\PYG{p}{;}

\PYG{c+c1}{// 调用: reset(p)}
\PYG{k+kt}{void} \PYG{n+nf}{reset}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针p所指对象的值}
    \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针p的值}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// 调用: reset(\PYGZam{}p)}
\PYG{k+kt}{void} \PYG{n+nf}{reset}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{o}{*}\PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针*p所指对象的值}
    \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针*p的值}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{传引用参数}
\label{\detokenize{cpp/12_argPass:id3}}
通过使用引用形参，允许函数改变实参的值。

使用引用避免拷贝：拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（比如IO类型）根本不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过
引用形参访问该类型的对象。例如，需要比较两个string对象，而这样的对象可能会很长，为了避免拷贝且不改变对象的值，可以将形参声明为常量引用（const \&）。

使用引用形参返回额外信息：通过给函数传入一个额外的引用形参，让其保存需要的值，而不需要作为函数返回值返回（避免函数返回值太多）。


\subsection{参考资料}
\label{\detokenize{cpp/12_argPass:id4}}\begin{enumerate}
\item {} 
《C++ Primer 第5版 中文版》 Page 187 \textendash{} 190。

\end{enumerate}


\section{空类指针}
\label{\detokenize{cpp/13_nullClassPtr::doc}}\label{\detokenize{cpp/13_nullClassPtr:id1}}
类的成员函数并不与特定对象绑定，所有成员函数共用一份成员函数体，当程序编译后，成员函数的地址即已经确定。
那为什么同一个类的不同对象调用对应成员函数可以出现不同的结果呢？答案就是 \sphinxcode{\sphinxupquote{this}} 指针。
共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的 \sphinxcode{\sphinxupquote{this}} 指针，
成员函数中对成员变量的访问都是转化成 \sphinxstylestrong{“this-\textgreater{}数据成员”} 的方式。
因此，从这一角度说，成员函数与普通函数一样，只是多了一个隐式参数，即指向对象的 \sphinxcode{\sphinxupquote{this}} 指针。


\subsection{空类指针调用成员函数}
\label{\detokenize{cpp/13_nullClassPtr:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{TestNullPtr} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{void} \PYG{n}{print}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{print}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k+kt}{void} \PYG{n}{getA}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k+kt}{void} \PYG{n}{setA}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{a} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{virtual} \PYG{n}{test}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{k}{private}\PYG{o}{:}
  \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{TestNullPtr}\PYG{o}{*} \PYG{n}{ptr} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{print}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 运行成功}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getA}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 编译成功，运行失败}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setA}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 编译成功，运行失败}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 编译成功，运行失败}
\end{sphinxVerbatim}

上例中， \sphinxcode{\sphinxupquote{ptr-\textgreater{}getA()}} 和 \sphinxcode{\sphinxupquote{ptr-\textgreater{}setA()}} 都试图访问成员变量，然而 \sphinxcode{\sphinxupquote{this}} 指针为空，导致运行失败。
另外，虚函数的特性是动态绑定，运行时根据指针或引用绑定的对象是基类对象还是派生类对象调用相关函数，空指针显然会导致错误。


\subsection{参考资料}
\label{\detokenize{cpp/13_nullClassPtr:id3}}\begin{enumerate}
\item {} 
C++空指针调用成员函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/45cf10150e6b}
\end{quote}


\section{static和extern}
\label{\detokenize{cpp/14_staticExtern:staticextern}}\label{\detokenize{cpp/14_staticExtern::doc}}

\subsection{static: 静态全局变量}
\label{\detokenize{cpp/14_staticExtern:static}}
在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。
特点：
\begin{itemize}
\item {} 
该变量在 \sphinxstylestrong{全局数据区} 分配内存；

\item {} 
未经初始化的静态全局变量会被程序自动初始化为0；（自动变量的值是随机的，除非它被显式初始化）

\item {} 
静态全局变量在声明它的整个文件都是可见的，而在 \sphinxstylestrong{文件之外是不可见的} ，其它文件中可以定义相同名字的变量，不会发生冲突。

\end{itemize}


\subsection{static: 静态函数}
\label{\detokenize{cpp/14_staticExtern:id1}}
在函数的返回类型前加上static关键字，函数即被定义为静态函数。
静态函数与普通函数不同，它 \sphinxstylestrong{只能在声明它的文件当中可见} ，不能被其它文件使用。
其它文件中可以定义相同名字的函数，不会发生冲突。这点与静态全局变量相似。


\subsection{static: 静态局部变量}
\label{\detokenize{cpp/14_staticExtern:id2}}
在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。
特点：
\begin{itemize}
\item {} 
该变量在全局数据区分配内存；

\item {} 
静态局部变量在程序执行到该对象的声明处时被首次初始化，即 \sphinxstylestrong{以后的函数调用不再进行初始化} ；

\item {} 
静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；

\item {} 
它始终驻留在全局数据区，其生命周期一直持续到整个程序执行结束。但其作用域仍为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// 初次调用func()时才会执行初始化}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{a} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 1}
  \PYG{n}{func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 2}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{static: 静态成员变量}
\label{\detokenize{cpp/14_staticExtern:id3}}
在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。
特点：
\begin{itemize}
\item {} 
对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。在没有产生类的实例时，我们就可以操作它；

\item {} 
静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义；

\item {} 
静态数据成员和普通数据成员一样遵从public，protected，private访问规则；

\item {} 
（类定义体外部）静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
\sphinxcode{\sphinxupquote{＜数据类型＞ ＜类名＞::＜静态数据成员名＞ = ＜值＞}}

\item {} 
类的静态数据成员有两种访问形式：
\sphinxcode{\sphinxupquote{＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞}}

\end{itemize}


\subsection{static: 静态成员函数}
\label{\detokenize{cpp/14_staticExtern:id4}}
普通的成员函数一般都隐含了一个 \sphinxcode{\sphinxupquote{this}} 指针， \sphinxcode{\sphinxupquote{this}} 指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。
通常情况下， \sphinxcode{\sphinxupquote{this}} 是缺省的。如函数 \sphinxcode{\sphinxupquote{fn()}} 实际上是 \sphinxcode{\sphinxupquote{this-\textgreater{}fn()}} 。
但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它 \sphinxstylestrong{不具有this指针} 。
从这个意义上讲，它 \sphinxstylestrong{无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数} 。
非静态成员函数可以任意地访问静态成员函数和静态数据成员。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Myclass}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{,} \PYG{n}{b} \PYG{p}{,} \PYG{n}{c}\PYG{p}{;}
    \PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{sum}\PYG{p}{;}  \PYG{c+c1}{//声明静态数据成员}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Myclass}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{GetSum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{Myclass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}   \PYG{c+c1}{//定义并初始化静态数据成员}

\PYG{n}{Myclass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Myclass}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{c}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{a} \PYG{o}{=} \PYG{n}{a}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{c} \PYG{o}{=} \PYG{n}{c}\PYG{p}{;}
    \PYG{n}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{o}{+}\PYG{n}{c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n}{Myclass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetSum}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{sum}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{extern: 修饰函数、变量}
\label{\detokenize{cpp/14_staticExtern:extern}}
修饰符 \sphinxcode{\sphinxupquote{extern}} 用在变量或者函数的声明前，用来说明 \sphinxstylestrong{“此变量/函数是在别处定义的，要在此处引用”} 。
在别的文件中如果想调用 \sphinxcode{\sphinxupquote{file1.c}} 中的变量a，只须用 \sphinxcode{\sphinxupquote{extern}} 进行声明即可调用a:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{extern} \PYG{n+nb}{int} \PYG{n}{a}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{file2}\PYG{o}{.}\PYG{n}{c}
\PYG{n}{extern} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{int} \PYG{n}{a}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{file3}\PYG{o}{.}\PYG{n}{cpp}
\end{sphinxVerbatim}

在这里要注意 \sphinxcode{\sphinxupquote{extern}} 声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。
其实要调用其它文件中的函数和变量，只需把该文件用\#include包含进来即可，但是用 \sphinxcode{\sphinxupquote{extern}} 会加速程序的编译过程，这样能节省时间。


\subsection{extern “C” \{\}}
\label{\detokenize{cpp/14_staticExtern:extern-c}}

\subsubsection{例子}
\label{\detokenize{cpp/14_staticExtern:id5}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef HEADER\PYGZus{}INCLUDED }\PYG{c+c1}{// 条件编译，避免重复包含头文件}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define HEADER\PYGZus{}INCLUDED}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}cplusplus }\PYG{c+c1}{// extern \PYGZdq{}C\PYGZdq{} 只用在c++文件中}
\PYG{k}{extern} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}} \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* \PYGZus{}\PYGZus{}cplusplus */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}c.h\PYGZdq{}}

\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{strcpy}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/*.................................}
\PYG{c+cm}{ * do something else}
\PYG{c+cm}{ *.................................}
\PYG{c+cm}{ */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}cplusplus}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* \PYGZus{}\PYGZus{}cplusplus */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* HEADER\PYGZus{}INCLUDED */}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{extern "C"}} 中的 \sphinxcode{\sphinxupquote{C}} ，表示的一种编译和连接规约，表明它按照类C的编译和连接规约来编译和连接，而不是一种语言。
\sphinxcode{\sphinxupquote{C}} 表示 \sphinxstylestrong{符合C语言的编译和连接规约的任何语言} ，如Fortran、assembler等。
\sphinxcode{\sphinxupquote{extern "C"}} 的真实目的是实现 \sphinxstylestrong{类C} 和C++的混合编程。


\subsection{参考资料}
\label{\detokenize{cpp/14_staticExtern:id6}}\begin{enumerate}
\item {} 
C/C++中的static关键字详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/qintangtao/p/3285937.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++项目中的extern “C” \{\}

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
浅谈C/C++中的static和extern关键字

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/dolphin0520/archive/2011/04/20/2022701.html}
\end{quote}


\section{public、protected、private}
\label{\detokenize{cpp/15_classAccess::doc}}\label{\detokenize{cpp/15_classAccess:publicprotectedprivate}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{类成员访问权限（可访问： \(\checkmark\)）}\label{\detokenize{cpp/15_classAccess:id3}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
权限
&\sphinxstyletheadfamily 
类成员
&\sphinxstyletheadfamily 
类对象
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
友元函数
\\
\hline
public
&
\(\checkmark\)
&
\(\checkmark\)
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
private
&
\(\checkmark\)
&
\(\times\)
&
\(\times\)
&
\(\checkmark\)
\\
\hline
protected
&
\(\checkmark\)
&
\(\times\)
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{继承}
\label{\detokenize{cpp/15_classAccess:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{public继承下对基类成员的访问权限}\label{\detokenize{cpp/15_classAccess:id4}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
内部权限
&\sphinxstyletheadfamily 
权限变化(相对于派生类)
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
派生类对象
\\
\hline
public
&
-\textgreater{} public
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
private
&
-\textgreater{} private
&
\(\times\)
&
\(\times\)
\\
\hline
protected
&
-\textgreater{} protected
&
\(\checkmark\)
&
\(\times\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{private继承下对基类成员的访问权限}\label{\detokenize{cpp/15_classAccess:id5}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
内部权限
&\sphinxstyletheadfamily 
权限变化(相对于派生类)
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
派生类对象
\\
\hline
public
&
-\textgreater{} private
&
\(\checkmark\)
&
\(\times\)
\\
\hline
private
&
-\textgreater{} private
&
\(\times\)
&
\(\times\)
\\
\hline
protected
&
-\textgreater{} private
&
\(\checkmark\)
&
\(\times\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{protected继承下对基类成员的访问权限}\label{\detokenize{cpp/15_classAccess:id6}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
内部权限
&\sphinxstyletheadfamily 
权限变化(相对于派生类)
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
派生类对象
\\
\hline
public
&
-\textgreater{} protected
&
\(\checkmark\)
&
\(\times\)
\\
\hline
private
&
-\textgreater{} private
&
\(\times\)
&
\(\times\)
\\
\hline
protected
&
-\textgreater{} protected
&
\(\checkmark\)
&
\(\times\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{class与struct}
\label{\detokenize{cpp/15_classAccess:classstruct}}
class不写权限修饰符，成员默认是 \sphinxcode{\sphinxupquote{private}} ，而struct的成员默认是 \sphinxcode{\sphinxupquote{public}} 。

class的继承默认是 \sphinxcode{\sphinxupquote{private}} 的，而struct默认是 \sphinxcode{\sphinxupquote{public}} 的。


\subsection{参考资料}
\label{\detokenize{cpp/15_classAccess:id2}}\begin{enumerate}
\item {} 
C++中关于public、protect、private的访问权限控制

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/ycf74514/article/details/49053041}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++的关键字public,private和protected

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/943c0d2fe292}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++中public,protected,private访问

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/jiudianren/p/5668438.html}
\end{quote}


\section{类的static const成员}
\label{\detokenize{cpp/16_staticconst:static-const}}\label{\detokenize{cpp/16_staticconst::doc}}

\subsection{const}
\label{\detokenize{cpp/16_staticconst:const}}
const数据成员的初始化只能在类的构造函数的初始化列表中进行。声明const变量是不能初始化。

\begin{sphinxadmonition}{note}{Note:}
必须使用初始化列表的情形
\begin{itemize}
\item {} 
\sphinxstylestrong{常量成员} ，因为常量只能初始化不能赋值，所以必须放在初始化列表里面。

\item {} 
\sphinxstylestrong{引用类型} ，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面。

\item {} 
没有默认构造函数的 \sphinxstylestrong{类类型} ，因为使用初始化列表不调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
成员是按照他们在类中 \sphinxstylestrong{声明} 的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的。
\end{sphinxadmonition}


\subsection{static}
\label{\detokenize{cpp/16_staticconst:static}}
不能在定义对象时对变量进行 \sphinxstylestrong{定义和初始化} ，即不能用构造函数进行初始化。
初始化在类体外进行，前面不加static修饰符。

\begin{sphinxadmonition}{note}{Note:}
const全局变量和类static成员变量都可以在 \sphinxstylestrong{定义类的头文件} 中初始化。不会因为头文件重复包含而导致变量重复定义的编译错误。

但是在定义指针时要注意， \sphinxcode{\sphinxupquote{const char* p = "name"}} 定义的指针不是const，可能导致错误；而 \sphinxcode{\sphinxupquote{char* const p = "name"}} 不会。
\end{sphinxadmonition}


\subsection{static const}
\label{\detokenize{cpp/16_staticconst:id1}}
静态常量成员，可以直接初始化（static cosnt 和 const static 含义相同）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
      \PYG{k}{static} \PYG{k+kt}{void} \PYG{n}{print}\PYG{p}{(}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
              \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{var} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 100}
              \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{mapping}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// \PYGZsq{}a\PYGZsq{}}
      \PYG{p}{\PYGZcb{}}

\PYG{k}{private}\PYG{o}{:}
      \PYG{k}{static} \PYG{k}{const} \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{mapping}\PYG{p}{;}
      \PYG{k}{static} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{var} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{c+c1}{// 直接初始化}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{const} \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{Solution}\PYG{o}{:}\PYG{o}{:} \PYG{n}{mapping} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{2}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                                    \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{3}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{d}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{e}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{f}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                                    \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{4}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{g}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{h}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{i}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* 注：const map只能通过迭代器 const\PYGZus{}iterator 访问元素（it\PYGZhy{}\PYGZgt{}first, it\PYGZhy{}\PYGZgt{}second）}
\PYG{c+cm}{ ，不能通过下标[]的方式访问。*/}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{cpp/16_staticconst:id2}}\begin{enumerate}
\item {} 
C++ static、const和static const类型成员变量声明以及初始化

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/hustfeiji/articles/5168529.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
头文件中定义 const 全局变量应注意的问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/mafuli007/article/details/8499585}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++ 初始化列表

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
C++的一大误区——深入解释直接初始化与复制初始化的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/ljianhui/article/details/9245661}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
C++构造函数初始化列表与赋值

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/sz-leez/p/7082865.html}

\sphinxurl{http://www.cnblogs.com/BlueTzar/articles/1223169.html}
\end{quote}


\section{枚举类型}
\label{\detokenize{cpp/17_enum::doc}}\label{\detokenize{cpp/17_enum:id1}}
枚举类型（enumeration）使我们可以将一组 \sphinxstylestrong{整型常量} 组织在一起。格式

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{enum} \PYG{o}{\PYGZlt{}}\PYG{n}{类型名}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZob{}}\PYG{o}{\PYGZlt{}}\PYG{n}{枚举成员}\PYG{o}{\PYGZgt{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

枚举成员不能是数值，即不能是类似于\{1,2,3\}。


\subsection{初始化}
\label{\detokenize{cpp/17_enum:id2}}
默认情况下，每个枚举变量的值就是其序号，从0开始，依次加1。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n}{Week} \PYG{p}{\PYGZob{}}\PYG{n}{Sun}\PYG{p}{,} \PYG{n}{Mon}\PYG{p}{,} \PYG{n}{Tue}\PYG{p}{,} \PYG{n}{Wed}\PYG{p}{,} \PYG{n}{Thu}\PYG{p}{,} \PYG{n}{Fri}\PYG{p}{,} \PYG{n}{Sat}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{//Sun=0, Mon=1, Tue=2, Wed=3, Thu=4, Fri=5, Sat=6}
\end{sphinxVerbatim}

显式提供初始值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n}{Week} \PYG{p}{\PYGZob{}}\PYG{n}{Sun}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Mon}\PYG{p}{,} \PYG{n}{Tue}\PYG{p}{,} \PYG{n}{Wed}\PYG{p}{,} \PYG{n}{Thu}\PYG{p}{,} \PYG{n}{Fri}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{Sat}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{//Sun=1, Mon=2, Tue=3, Wed=4, Thu=5, Fri=100, Sat=101}
\end{sphinxVerbatim}


\subsection{枚举变量}
\label{\detokenize{cpp/17_enum:id3}}
定义枚举类型之后，就可以定义该枚举类型的变量，或者与枚举类型同时定义。枚举变量的值只能取枚举常量表中所列的值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{enum} \PYG{n}{Week} \PYG{p}{\PYGZob{}}\PYG{n}{Sun}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Mon}\PYG{p}{,} \PYG{n}{Tue}\PYG{p}{,} \PYG{n}{Wed}\PYG{p}{,} \PYG{n}{Thu}\PYG{p}{,} \PYG{n}{Fri}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{Sat}\PYG{p}{\PYGZcb{}} \PYG{n}{day\PYGZus{}1}\PYG{p}{;}
\PYG{c+c1}{// 全局变量 day\PYGZus{}1 默认初始化为 0。}

\PYG{k+kt}{void} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{num}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{num} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{n}{Week} \PYG{n}{day}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{day}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Week} \PYG{n}{day\PYGZus{}2}\PYG{p}{,} \PYG{n}{day\PYGZus{}3}\PYG{p}{;}

  \PYG{n}{day\PYGZus{}1} \PYG{o}{=} \PYG{n}{Sun}\PYG{p}{;} \PYG{c+c1}{// 或者 day\PYGZus{}1 = Week::Sun （不限定作用域的枚举类型）}
  \PYG{n}{day\PYGZus{}2} \PYG{o}{=} \PYG{n}{day\PYGZus{}1}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{day\PYGZus{}1}\PYG{p}{;} \PYG{c+c1}{// i = 1}
  \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{Mon}\PYG{p}{;} \PYG{c+c1}{// j = 2}

  \PYG{n}{Week} \PYG{n}{day\PYGZus{}4}\PYG{p}{(}\PYG{n}{Week}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// day\PYGZus{}4 = Fri}
  \PYG{k+kt}{bool} \PYG{n}{equal} \PYG{o}{=} \PYG{p}{(}\PYG{n}{day\PYGZus{}4} \PYG{o}{=}\PYG{o}{=} \PYG{n}{Fri}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// true}

  \PYG{n}{Week} \PYG{n}{day\PYGZus{}5}\PYG{p}{(}\PYG{n}{Week}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 越界，但是不报错，day\PYGZus{}5 = \PYGZhy{}1 （VS 2013）}

  \PYG{n}{ff}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 匹配 ff(int)，输出 \PYGZhy{}10}
  \PYG{n}{ff}\PYG{p}{(}\PYG{n}{day\PYGZus{}1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 匹配 ff(Week)，输出 10}
  \PYG{n}{ff}\PYG{p}{(}\PYG{n}{Fri}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 匹配 ff(Week)，输出 1000}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{cpp/17_enum:id4}}
1.《C++ Primer 第5版 中文版》 Page 736 \textendash{} 739。
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++ 枚举类型详解

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.runoob.com/w3cnote/cpp-enum-intro.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++枚举（enum）的优雅用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/daizhiyan1/article/details/82428023}
\end{quote}


\section{常用函数}
\label{\detokenize{cpp/18_commonFunc::doc}}\label{\detokenize{cpp/18_commonFunc:id1}}

\subsection{lower\_bound，upper\_bound}
\label{\detokenize{cpp/18_commonFunc:lower-bound-upper-bound}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{lower\_bound} 从排好序的数组区间 \sphinxstylestrong{{[}first,last)} 中，采用二分查找，返回 \sphinxstylestrong{大于或等于} val的 \sphinxstylestrong{第一个} 元素位置。
如果所有元素都小于val，则返回last。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{ForwardIterator} \PYG{n}{lower\PYGZus{}bound} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{upper\_bound} 从排好序的数组区间 \sphinxstylestrong{{[}first,last)} 中，采用二分查找，返回 \sphinxstylestrong{大于} val的 \sphinxstylestrong{第一个} 元素位置。
如果所有元素都不大于val，则返回last。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{ForwardIterator} \PYG{n}{upper\PYGZus{}bound} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

求有序数组中val的个数：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{first}\PYG{p}{,} \PYG{n}{last}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{first}\PYG{p}{,} \PYG{n}{last}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 4}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 8}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 用 a 对 v 初始化}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 4}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 8}

  \PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{500}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{ai} \PYG{p}{:} \PYG{n}{a}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ai} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends}\PYG{p}{;} \PYG{c+c1}{// 1 2 3 4 500 5 5 5 6 7 8}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{500}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{vi} \PYG{p}{:} \PYG{n}{v}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends}\PYG{p}{;} \PYG{c+c1}{// 1 2 3 4 500 5 5 5 6 7 8}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{fill，fill\_n，for\_each}
\label{\detokenize{cpp/18_commonFunc:fill-fill-n-for-each}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{fill} 函数将一个区间 \sphinxstylestrong{{[}first,last)} 的每个元素都赋予val值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{fill} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{fill\_n} 函数从 \sphinxstylestrong{first} 开始依次赋予n个元素val值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{OutputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Size}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{fill\PYGZus{}n} \PYG{p}{(}\PYG{n}{OutputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{Size} \PYG{n}{n}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{for\_each} 把函数fn应用于区间 \sphinxstylestrong{{[}first,last)} 的每个元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Function}\PYG{o}{\PYGZgt{}}
\PYG{n}{Function} \PYG{n}{for\PYGZus{}each} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{Function} \PYG{n}{fn}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{print}\PYG{p}{(}\PYG{n}{T} \PYG{n}{elem}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{elem} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{k+kt}{float} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+m+mf}{0.0} \PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}0.0, 0.0, 0.0, 0.0\PYGZcb{}}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}0, 0, 0, 0\PYGZcb{}}

  \PYG{n}{fill}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mf}{3.3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}3.3, 3.3, 3.3, 3.3\PYGZcb{}}
  \PYG{n}{fill\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{6.6}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}6.6, 6.6, 3.3, 3.3\PYGZcb{}}
  \PYG{n}{fill\PYGZus{}n}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}9, 9, 9, 9\PYGZcb{}}

  \PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{print}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//  6.6 6.6 3.3 3.3}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{print}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//  9 9 9 9}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

最长上升子序列：

\fvset{hllines={, 11, 12, 13,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/* https://leetcode.com/problems/longest\PYGZhy{}increasing\PYGZhy{}subsequence/ */}
\PYG{c+cm}{/* O(nlogn) in time.*/}

\PYG{k}{class} \PYG{n+nc}{Solution} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{lengthOfLIS}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{inf} \PYG{o}{=} \PYG{n}{INT\PYGZus{}MAX}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{len} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{dp} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{len}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{fill}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{inf}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{length} \PYG{o}{=} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{inf}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{dp}\PYG{p}{;}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{dp}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{length}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{sort}
\label{\detokenize{cpp/18_commonFunc:sort}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}

\PYG{c+c1}{// default}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{RandomAccessIterator}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{sort} \PYG{p}{(}\PYG{n}{RandomAccessIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{RandomAccessIterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{RandomAccessIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Compare}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{sort} \PYG{p}{(}\PYG{n}{RandomAccessIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{RandomAccessIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{Compare} \PYG{n}{comp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}functional\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{comparator}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{struct} \PYG{n}{myclass}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}} \PYG{n}{myobject}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{71}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{26}\PYG{p}{,} \PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{53}\PYG{p}{,} \PYG{l+m+mi}{33} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}               \PYG{c+c1}{// 32 71 12 45 26 80 53 33}

  \PYG{c+c1}{// using default comparison (operator \PYGZlt{}):}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}           \PYG{c+c1}{//(12 32 45 71)26 80 53 33}

  \PYG{c+c1}{// using comparator as comp}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{comparator}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 12 32 45 71(26 33 53 80)}

  \PYG{c+c1}{// using object as comp}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{myobject}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{//(12 26 32 33 45 53 71 80)}

  \PYG{c+c1}{// using build\PYGZhy{}in comp: greater}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{greater}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// (80 71 53 45 33 32 26 12)}

  \PYG{c+c1}{// using build\PYGZhy{}in comp: less}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{less}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//(12 26 32 33 45 53 71 80)}

  \PYG{c+c1}{// using reverse\PYGZus{}iterator}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{rbegin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{rend}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// (80 71 53 45 33 32 26 12)}

  \PYG{c+c1}{// sort array}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{greater}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// (80 71 53 45 33 32 26 12)}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}                 \PYG{c+c1}{// (12 26 32 33 45 53 71 80)，可使用 comparator、myobject、less\PYGZlt{}int\PYGZgt{}()}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{附：头文件}
\label{\detokenize{cpp/18_commonFunc:id2}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cmath}}
\begin{itemize}
\item {} 
pow()

\item {} 
sqrt()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{cstdlib}}
\begin{itemize}
\item {} 
abs()

\item {} 
fabs()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{limits}}
\begin{itemize}
\item {} 
INT\_MIN

\item {} 
INT\_MAX

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{algorithm}}
\begin{itemize}
\item {} 
min()

\item {} 
max()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{utility}}
\begin{itemize}
\item {} 
pair

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{functional}}
\begin{itemize}
\item {} 
less\textless{} \sphinxstyleemphasis{TYPE} \textgreater{}()

\item {} 
greater\textless{} \sphinxstyleemphasis{TYPE} \textgreater{}()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{cassert}}
\begin{itemize}
\item {} 
assert()

\end{itemize}

\end{itemize}


\subsection{参考资料}
\label{\detokenize{cpp/18_commonFunc:id3}}\begin{enumerate}
\item {} 
c++ reference

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/lower\_bound/}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/upper\_bound/}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/fill/}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/for\_each}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/sort/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C/C++-STL中lower\_bound与upper\_bound的用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/jadeyansir/article/details/77015626}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
c++sort函数的使用总结

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/TX980502/p/8528840.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
C++ sort排序函数用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/w\_linux/article/details/76222112}
\end{quote}


\chapter{Python}
\label{\detokenize{python/index:python}}\label{\detokenize{python/index::doc}}

\section{in-place 运算}
\label{\detokenize{python/01_inplace:in-place}}\label{\detokenize{python/01_inplace::doc}}

\subsection{+= 运算}
\label{\detokenize{python/01_inplace:id1}}
\sphinxcode{\sphinxupquote{+=}} 是一个in-place运算符，看如下例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{n}{a} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1,2]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[1,2]}
\end{sphinxVerbatim}

如果改变成如下形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

则结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1,2]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{a = a + {[}1,2{]}}} 不是in-place运算，尽管使用了同一个变量名。
\end{sphinxadmonition}


\subsection{add和iadd}
\label{\detokenize{python/01_inplace:addiadd}}
\sphinxcode{\sphinxupquote{operator}} 包中有两个操作：\sphinxcode{\sphinxupquote{add}} 和 \sphinxcode{\sphinxupquote{iadd}} 。\sphinxcode{\sphinxupquote{add}} 是正常加运算， \sphinxcode{\sphinxupquote{iadd}} 是原位加运算。
\begin{quote}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{\_add\_}}}] \leavevmode
does simple addition, takes two arguments, returns the sum and stores it in other variable without modifying any of the argument.
Normal operator’s \sphinxcode{\sphinxupquote{add()}} method, implements \sphinxstylestrong{“a+b”} and stores the result in the mentioned variable.

\item[{\sphinxcode{\sphinxupquote{\_iadd\_}}}] \leavevmode
also takes two arguments, but it makes in-place change in 1st argument passed by storing the sum in it. As object mutation is needed in this process, immutable targets such as numbers, strings and tuples, shouldn’t have \sphinxcode{\sphinxupquote{\_iadd\_}} method.
Inplace operator’s \sphinxcode{\sphinxupquote{iadd()}} method, implements \sphinxstylestrong{“a+=b”} if it exists (i.e in case of immutable targets, it doesn’t exist) and changes the value of passed argument. But if not, \sphinxstylestrong{“a+b”} is implemented.

\end{description}
\end{quote}

分两种情况讨论。


\subsubsection{immutable targets}
\label{\detokenize{python/01_inplace:immutable-targets}}
对于不可变目标（immutable targets），如数字、字符串、元组， \sphinxcode{\sphinxupquote{\_add\_}} 和 \sphinxcode{\sphinxupquote{\_iadd\_}} 结果是一样的，输入实参不会发生改变。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{operator}

\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{6}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{iadd}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{z}
\PYG{g+go}{11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{p}
\PYG{g+go}{11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{x}
\PYG{g+go}{5}
\end{sphinxVerbatim}


\subsubsection{mutable targets}
\label{\detokenize{python/01_inplace:mutable-targets}}
对于可变目标（mutable targets），如列表、字典，输入实参会被重现赋值和更新。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{operator}

\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{iadd}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{z}
\PYG{g+go}{[1, 2, 4, 5, 1, 2, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{p}
\PYG{g+go}{[1, 2, 4, 5, 1, 2, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1, 2, 4, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[1, 2, 4, 5, 1, 2, 3]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{不可变目标} （数字、字符串、元组）作为函数参数，相当于 \sphinxstylestrong{值传递} ，函数对实参进行拷贝。

\sphinxstylestrong{可变目标} （列表、字典）作为函数参数，相当于 \sphinxstylestrong{引用传递} ，函数对实参的修改有效。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{python/01_inplace:id2}}\begin{enumerate}
\item {} 
pytorch issue：

\end{enumerate}
\begin{quote}

\sphinxurl{https://github.com/pytorch/pytorch/issues/5687}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
GeeksforGeeks：

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.geeksforgeeks.org/inplace-vs-standard-operators-python/}
\end{quote}


\section{\_\_all\_\_ 的使用}
\label{\detokenize{python/02_all:all}}\label{\detokenize{python/02_all::doc}}

\subsection{从\_\_init\_\_.py谈起}
\label{\detokenize{python/02_all:init-py}}
\sphinxcode{\sphinxupquote{\_\_init\_\_.py}} 的 \sphinxstylestrong{作用一} ：package的标识
\begin{quote}

在每一个package文件夹中都会有一个\_\_init\_\_.py文件。
\end{quote}

\sphinxcode{\sphinxupquote{\_\_init\_\_.py}} 的 \sphinxstylestrong{作用二} ：定义该package的 \sphinxcode{\sphinxupquote{\_\_all\_\_}} ，用以模糊导入
\begin{quote}

python中包(package)和模块(module)有两种导入形式：精确导入和模糊导入。
\begin{description}
\item[{精确导入}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PACK} \PYG{k+kn}{import} \PYG{n}{CLASS1}\PYG{p}{,} \PYG{n}{CLASS2}
\PYG{k+kn}{import} \PYG{n+nn}{PACK.CLASS1}
\end{sphinxVerbatim}

\item[{模糊导入}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PACK} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

\end{description}
\end{quote}

\sphinxcode{\sphinxupquote{\_\_all\_\_}} 是一个字符串列表，用于定义模糊导入中的 \sphinxcode{\sphinxupquote{*}} 中的模块，即暴露接口，也是对于模块公开接口的一种约定。

举个例子，建立如下目录结构的文件夹及文件:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}
\PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n}{test}\PYG{o}{.}\PYG{n}{py}
\PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n}{myPack}
    \PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n}{func}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

创建了包 \sphinxstylestrong{myPack} ，其中 \sphinxstylestrong{func.py} 中定义了该包的功能，包括变量、类、函数的定义。使用 \sphinxstylestrong{test.py} 来测试这个包的调用。
\sphinxcode{\sphinxupquote{\_\_init\_\_.py}} 中的内容如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{func} \PYG{k+kn}{import} \PYG{n}{x}\PYG{p}{,} \PYG{n}{foo}
\PYG{c+c1}{\PYGZsh{} 假设x是一个变量，foo是一个函数}

\PYG{n}{\PYGZus{}\PYGZus{}all\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{foo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxstylestrong{test.py} 中的内容如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{myPack} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{k}{print} \PYG{n}{x}

\PYG{n}{foo}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/02_all:id1}}\begin{enumerate}
\item {} 
Python中的 \_\_all\_\_

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/ca469f693c31}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Python包中 \_\_init\_\_.py 作用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/AlwinXu/p/5598543.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Python \_\_init\_\_.py 作用详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/Lands-ljk/p/5880483.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Python中 \_\_all\_\_ 的用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.codetd.com/article/2136881}
\end{quote}


\section{is和==}
\label{\detokenize{python/03_is:is}}\label{\detokenize{python/03_is::doc}}

\subsection{is和==}
\label{\detokenize{python/03_is:id1}}
\sphinxcode{\sphinxupquote{is}} 的作用是用来检查对象的标示符（object identity）是否一致，也就是比较两个对象在内存中的地址是否一样，而 \sphinxcode{\sphinxupquote{==}} 是用来检查两个对象是否相等。
我们在检查 \sphinxcode{\sphinxupquote{a is b}} 的时候，其实相当于检查 \sphinxcode{\sphinxupquote{id(a) == id(b)}}。而检查 \sphinxcode{\sphinxupquote{a == b}} 的时候，实际是调用了对象a的 \sphinxcode{\sphinxupquote{\_\_eq\_\_()}} 方法，\sphinxcode{\sphinxupquote{a == b}}
相当于 \sphinxcode{\sphinxupquote{a.\_\_eq\_\_(b)}}。
一般情况下，如果 \sphinxcode{\sphinxupquote{a is b}} 返回True的话，即a和b指向同一块内存地址的话，\sphinxcode{\sphinxupquote{a == b}} 也返回True，即a和b的值也相等。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{b} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{print} \PYG{n}{a}\PYG{o}{==}\PYG{n}{b} \PYG{c+c1}{\PYGZsh{} True}
\PYG{k}{print} \PYG{n}{a} \PYG{o+ow}{is} \PYG{n}{b} \PYG{c+c1}{\PYGZsh{} False}
\PYG{k}{print} \PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{k}{print} \PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{k}{print} \PYG{n}{a}\PYG{o}{==}\PYG{n}{b} \PYG{c+c1}{\PYGZsh{} True}
\PYG{k}{print} \PYG{n}{a} \PYG{o+ow}{is} \PYG{n}{b} \PYG{c+c1}{\PYGZsh{} True}
\end{sphinxVerbatim}


\subsection{None}
\label{\detokenize{python/03_is:none}}
与 \sphinxcode{\sphinxupquote{None}} 比较是 \sphinxcode{\sphinxupquote{is None}} 而不是 \sphinxcode{\sphinxupquote{== None}} 。
这是因为 \sphinxcode{\sphinxupquote{None}} 在Python里是个单例对象（singleton）：一个变量如果是 \sphinxcode{\sphinxupquote{None}} ，它一定和 \sphinxcode{\sphinxupquote{None}} 指向同一个内存地址。
而 \sphinxcode{\sphinxupquote{== None}} 背后调用的是 \sphinxcode{\sphinxupquote{\_\_eq\_\_}} ，而 \sphinxcode{\sphinxupquote{\_\_eq\_\_}} 可以被重载，下面是一个 \sphinxcode{\sphinxupquote{is not None}} 但 \sphinxcode{\sphinxupquote{== None}} 的例子。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Foo}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}eq\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb+bp}{True}

\PYG{n}{foo} \PYG{o}{=} \PYG{n}{Foo}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{foo}\PYG{o}{==}\PYG{n+nb+bp}{None} \PYG{c+c1}{\PYGZsh{} True}
\PYG{k}{print} \PYG{n}{foo} \PYG{o+ow}{is} \PYG{n+nb+bp}{None} \PYG{c+c1}{\PYGZsh{} False}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/03_is:id2}}\begin{enumerate}
\item {} 
经典7大Python面试题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qq\_41597912/article/details/81459804}
\end{quote}


\section{装饰器}
\label{\detokenize{python/04_decorator::doc}}\label{\detokenize{python/04_decorator:id1}}

\subsection{作用}
\label{\detokenize{python/04_decorator:id2}}
装饰器本质上是一个Python函数，它可以让其他函数在 \sphinxstylestrong{不需要做任何代码变动} 的前提下 \sphinxstylestrong{增加额外功能} ，装饰器的返回值也是一个函数对象。
它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。
装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。

概括的讲，装饰器的作用就是为已经存在的函数或对象添加额外的功能。


\subsection{使用装饰器计时}
\label{\detokenize{python/04_decorator:id3}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{wraps}
\PYG{k+kn}{import} \PYG{n+nn}{time}

\PYG{k}{def} \PYG{n+nf}{timer}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@wraps}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{function\PYGZus{}timer}\PYG{p}{(}\PYG{o}{*}\PYG{n}{arg}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{start\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{result} \PYG{o}{=} \PYG{n}{func}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
        \PYG{n}{end\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{result}
    \PYG{k}{return} \PYG{n}{function\PYGZus{}timer}

\PYG{n+nd}{@timer}
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{print} \PYG{n}{foo}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}
\PYG{k}{print} \PYG{n}{foo}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}}
\end{sphinxVerbatim}

使用 \sphinxcode{\sphinxupquote{wraps}} 可以保持函数 \sphinxcode{\sphinxupquote{foo()}} 的属性 \sphinxcode{\sphinxupquote{\_\_name\_\_}} 和 \sphinxcode{\sphinxupquote{\_\_doc\_\_}} ，而不变成函数 \sphinxcode{\sphinxupquote{function\_timer}} 的相关属性。


\subsection{参考资料}
\label{\detokenize{python/04_decorator:id4}}\begin{enumerate}
\item {} 
详解Python的装饰器

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/cicaday/p/python-decorator.html}
\end{quote}


\section{迭代器和生成器}
\label{\detokenize{python/05_iterator::doc}}\label{\detokenize{python/05_iterator:id1}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{05_iterator}.png}\hspace*{\fill}}


\subsection{迭代器（iterator）}
\label{\detokenize{python/05_iterator:iterator}}\begin{description}
\item[{特点：}] \leavevmode\begin{itemize}
\item {} 
迭代器是访问集合元素的一种方式，不能随机访问集合中的某个值，只能从头到尾依次访问（ \sphinxcode{\sphinxupquote{next()}} 方法），访问到一半时不能往回退。

\item {} 
不需要事先准备好整个迭代过程中的所有元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。

\item {} 
便于循环比较大的数据集合，节省内存。

\item {} 
不能复制一个迭代器，如果要再次（或者同时）迭代同一个对象，只能去创建另一个迭代器对象。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} enumerate 返回迭代器}
\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 迭代两次enumerate对象}
    \PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{========}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

结果是：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\end{sphinxVerbatim}

可以发现：第二次返回值为空。

\end{description}


\subsubsection{可迭代对象（iterable）}
\label{\detokenize{python/05_iterator:iterable}}
\sphinxstylestrong{可以直接作用于for循环的对象统称为可迭代对象（Iterable）} 。只要定义了可以返回一个迭代器的 \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 方法，或者定义了可以支持下标索引的 \sphinxcode{\sphinxupquote{\_\_getitem\_\_()}} 方法，那么它就是一个可迭代对象。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Iterator\PYGZus{}test}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}

  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}iter\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{return} \PYG{n+nb+bp}{self}

  \PYG{k}{def} \PYG{n+nf}{next}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{:}
          \PYG{k}{raise} \PYG{n+ne}{StopIteration}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
      \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index}\PYG{p}{]}

\PYG{n}{iterator\PYGZus{}winter} \PYG{o}{=} \PYG{n}{Iterator\PYGZus{}test}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcde}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{iterator\PYGZus{}winter}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{item}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 打印 e d c b a}

\PYG{k}{class} \PYG{n+nc}{Iterator\PYGZus{}test2}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{it}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{it}\PYG{p}{]}
\PYG{n}{no\PYGZus{}iter} \PYG{o}{=} \PYG{n}{Iterator\PYGZus{}test2}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcde}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{no\PYGZus{}iter}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{item}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 打印 a b c d e}
\end{sphinxVerbatim}

常见的可迭代对象：
\begin{itemize}
\item {} 
集合数据类型，如list、tuple、dict、set、str等。

\item {} 
generator，包括生成器和带yield的generator function。

\end{itemize}

\sphinxstylestrong{可以被next()函数调用并不断返回下一个值的对象称为迭代器（Iterator）} 。生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。

\sphinxstylestrong{所有的Iterable均可以通过内置函数iter()来转变为Iterator} 。

判断一个对象是否是可迭代对象：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{Iterable}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{Iterable}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} True}

\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 或 a.next()，返回 1}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 返回 2}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 返回 3}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 抛出 StopIteration 异常}
\end{sphinxVerbatim}

一个可迭代对象是不能独立进行迭代的，Python中， 迭代是通过 \sphinxcode{\sphinxupquote{for ... in}} 来完成的 。
for循环会不断调用迭代器对象的 \sphinxcode{\sphinxupquote{\_\_next\_\_()}} 方法（python3  \sphinxcode{\sphinxupquote{\_\_next\_\_()}} ；python2  \sphinxcode{\sphinxupquote{next()}} ），每次循环，都返回迭代器对象的下一个值，直到遇到 \sphinxcode{\sphinxupquote{StopIteration}} 异常。

任何实现了 \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 和 \sphinxcode{\sphinxupquote{\_\_next\_\_()}} （python2中实现 \sphinxcode{\sphinxupquote{next()}} ）方法的对象都是迭代器， \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 返回迭代器自身， \sphinxcode{\sphinxupquote{\_\_next\_\_()}} 返回容器中的下一个值 。


\subsection{生成器（generator）}
\label{\detokenize{python/05_iterator:generator}}
生成器其实是一种特殊的迭代器。它不需要再像上面的类一样写 \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 和 \sphinxcode{\sphinxupquote{\_\_next\_\_()}} 方法了，只需要一个 \sphinxcode{\sphinxupquote{yiled}} 关键字。 \sphinxcode{\sphinxupquote{yield}} 就是return返回的一个值，并且记住这个返回的位置。下一次迭代就从这个位置开始。
生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{generator\PYGZus{}winter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}
  \PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{:}
      \PYG{k}{yield} \PYG{n}{i}
      \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n}{generator\PYGZus{}iter} \PYG{o}{=} \PYG{n}{generator\PYGZus{}winter}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 1}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 2}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 3}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 抛出 StopIteration 异常}
\end{sphinxVerbatim}

\sphinxstylestrong{生成器表达式} （类似于列表推导式，只是把{[}{]}换成()）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gen} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZlt{}generator object \PYGZlt{}genexpr\PYGZgt{} at 0x0000000012BC4990\PYGZgt{}}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{gen}\PYG{p}{:}
  \PYG{k}{print} \PYG{n}{item}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} fibonacci 数列}
\PYG{k}{def} \PYG{n+nf}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
  \PYG{k}{while} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{n}\PYG{p}{:}
      \PYG{k}{yield} \PYG{n}{b}
      \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{item}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/05_iterator:id2}}\begin{enumerate}
\item {} 
Python迭代器，生成器\textendash{}精华中的精华

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/deeper/p/7565571.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
python 生成器和迭代器有这篇就够了

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/wj-1314/p/8490822.html}
\end{quote}


\section{lambda用法}
\label{\detokenize{python/06_lambda::doc}}\label{\detokenize{python/06_lambda:lambda}}
使用：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{p}{[}\PYG{n}{arg1}\PYG{p}{[}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{argN}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:} \PYG{n}{expression}
\end{sphinxVerbatim}
\begin{description}
\item[{特性：}] \leavevmode\begin{itemize}
\item {} 
匿名函数。函数没有名字。

\item {} 
输入是arg list，输出是根据expression计算得到的值。

\item {} 
功能简单。

\end{itemize}

\end{description}


\subsection{使用场景}
\label{\detokenize{python/06_lambda:id1}}\begin{enumerate}
\item {} 
将lambda函数赋值给一个变量，通过这个变量间接调用该函数。

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{plus} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}
\PYG{k}{print} \PYG{n}{plus}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
将lambda函数赋值给其他函数，从而屏蔽其他函数本来的功能。

\item {} 
将lambda函数作为其他函数的返回值（内部函数）。

\item {} 
将lambda函数作为参数传递给其他函数。

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxstylestrong{map} ：将序列中的元素通过处理函数处理后返回一个新的列表。

\item {} 
\sphinxstylestrong{filter} ：将序列中的元素通过函数过滤后返回一个新的列表。

\item {} 
\sphinxstylestrong{reduce} ：将序列中的元素通过一个二元函数处理返回一个结果。

\item {} 
\sphinxstylestrong{sorted} ：结合lambda对列表进行排序。 \sphinxcode{\sphinxupquote{sorted(iterable, cmp=None, key=None, reverse=False)}}

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 每个元素加1}
\PYG{n}{b} \PYG{o}{=} \PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} [2, 3, 7, 6, 3, \PYGZhy{}7, \PYGZhy{}4, 0, \PYGZhy{}9]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 提取序列中大于0的数}
\PYG{n}{c} \PYG{o}{=} \PYG{n+nb}{filter}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} [1, 2, 6, 5, 2]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 返回所有元素相乘的结果}
\PYG{n}{d} \PYG{o}{=} \PYG{n+nb}{reduce}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{n}{y}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 48000}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 负数排在正数前面，同时绝对值大的排在后面}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 两个key，先按第一个key排序，若第一个key相同则按下一个key排序}
\PYG{n}{e} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} [\PYGZhy{}1, \PYGZhy{}5, \PYGZhy{}8, \PYGZhy{}10, 1, 2, 2, 5, 6]}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/06_lambda:id2}}\begin{enumerate}
\item {} 
关于Python中的lambda，这可能是你见过的最完整的讲解

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zjuxsl/article/details/79437563}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
在Python中使用lambda高效操作列表的教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/mxp-neu/articles/5316557.html}
\end{quote}


\section{*args和**kwargs}
\label{\detokenize{python/07_arg:args-kwargs}}\label{\detokenize{python/07_arg::doc}}

\subsection{*args}
\label{\detokenize{python/07_arg:args}}
\sphinxcode{\sphinxupquote{*args}} 用来将 \sphinxstylestrong{不定数量} 的参数打包成 \sphinxcode{\sphinxupquote{tuple}} 给函数体使用。

例一：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{args[\PYGZob{}\PYGZcb{}]:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{args}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{200k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{args[0]: 100}
\PYG{g+go}{args[1]: 200k}
\PYG{g+go}{args[2]: 300}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{args} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{x: A}
\PYG{g+go}{args[0]: 1}
\PYG{g+go}{args[1]: 2}
\PYG{g+go}{args[2]: abc}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 注：此时把args当做一个参数，参数类型为列表}
\PYG{g+go}{x: A}
\PYG{g+go}{args[0]: [1, 2, \PYGZsq{}abc\PYGZsq{}]}
\end{sphinxVerbatim}

例二：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{var1}\PYG{p}{,} \PYG{n}{var2}\PYG{p}{,} \PYG{n}{var3}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var1:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var1}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var2:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var2}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var3:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var3}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{args} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} list}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{TypeError: foo() takes exactly 4 arguments (2 given)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: 1}
\PYG{g+go}{var2: 2}
\PYG{g+go}{var3: A}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{args} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} tuple}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{TypeError: foo() takes exactly 4 arguments (2 given)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: 1}
\PYG{g+go}{var2: 2}
\PYG{g+go}{var3: A}
\end{sphinxVerbatim}


\subsection{**kwargs}
\label{\detokenize{python/07_arg:kwargs}}
\sphinxcode{\sphinxupquote{**kwargs}} 打包 \sphinxstylestrong{不定数量} 的键值对参数成 \sphinxcode{\sphinxupquote{dict}} 给函数体使用。

例一：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{key}\PYG{p}{,} \PYG{n}{val} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{} : \PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{n}{var1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{var2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{var3}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{var1 : 1}
\PYG{g+go}{var3 : [1, 2, 3]}
\PYG{g+go}{var2 : a}
\end{sphinxVerbatim}

例二：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{var1}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{var2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var1:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var1}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var2:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var2}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dict\PYGZus{}input} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{dict\PYGZus{}input}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: \PYGZob{}\PYGZsq{}var1\PYGZsq{}: 10, \PYGZsq{}var2\PYGZsq{}: \PYGZsq{}A\PYGZsq{}\PYGZcb{}}
\PYG{g+go}{var2: a}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{dict\PYGZus{}input}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: 10}
\PYG{g+go}{var2: A}
\end{sphinxVerbatim}


\subsection{arg，*args，**kwargs}
\label{\detokenize{python/07_arg:arg-args-kwargs}}
位置参数、*args、**kwargs三者的顺序必须是（arg，*args，**kwargs）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{arg:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{arg}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{args:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{args}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kwargs:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{kwargs}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{arg: 1}
\PYG{g+go}{args: (2, 3, 4)}
\PYG{g+go}{kwargs: \PYGZob{}\PYGZsq{}y\PYGZsq{}: \PYGZsq{}b\PYGZsq{}, \PYGZsq{}x\PYGZsq{}: 1\PYGZcb{}}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{SyntaxError: non\PYGZhy{}keyword arg after keyword arg}
\end{sphinxVerbatim}

位置参数、默认参数、**kwargs三者的顺序必须是（位置参数，默认参数，**kwargs）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 不能出现 (x=1,y,**kwargs)}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{y}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kwargs:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{kwargs}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{var1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{var2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{x: 4}
\PYG{g+go}{y: 1}
\PYG{g+go}{kwargs: \PYGZob{}\PYGZsq{}var1\PYGZsq{}: 1, \PYGZsq{}var2\PYGZsq{}: \PYGZsq{}b\PYGZsq{}\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/07_arg:id1}}\begin{enumerate}
\item {} 
大话Python中*args和**kargs的使用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/shitaotao/p/7609990.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
python函数——形参中的：*args和**kwargs

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/xuyuanyuan123/p/6674645.html}
\end{quote}


\section{基本数据类型}
\label{\detokenize{python/08_basicType::doc}}\label{\detokenize{python/08_basicType:id1}}

\subsection{类型与方法}
\label{\detokenize{python/08_basicType:id2}}\begin{itemize}
\item {} 
\sphinxstylestrong{str}
\begin{itemize}
\item {} 
索引、切片：{[}{]}

\item {} 
长度：len()

\item {} 
查找：若字符/序列不在字符串内，index()报错 ValueError，find()返回-1。

\item {} 
判断字符串内容：字母，isalpha()；数字，isdigit()；数字或字母，isalnum()。

\item {} 
大小写转换：capitalize()、lower()、upper()。

\item {} 
判断以什么开头结尾：startswith()、endswith()。

\item {} 
连接：join()，将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串。

\item {} 
分割：split()、partition()。 \sphinxstylestrong{如果想把字符串分割成独立的字符，用 list(string)。}

\item {} 
替代：replace()

\item {} 
清除空白: strip()、lstrip()、rstrip()

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{abcde}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{s}
\PYG{g+go}{a\PYGZhy{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{def}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ghi}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{s}
\PYG{g+go}{abc\PYGZus{}def\PYGZus{}ghi}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a\PYGZhy{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{partion}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 只能分割为3部分}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{s}
\PYG{g+go}{(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZsq{}, \PYGZsq{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e\PYGZsq{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{s}
\PYG{g+go}{[\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}, \PYGZsq{}e\PYGZsq{}]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{list}
\begin{itemize}
\item {} 
索引、切片：{[}{]}

\item {} 
统计元素出现的次数：count()

\item {} 
追加：append()

\item {} 
拓展：extend()

\item {} 
插入：insert()

\item {} 
弹出元素：pop()，默认弹出列表末尾的元素

\item {} 
移除/删除元素：remove()，del （del可删除切片）

\item {} 
排序：sort()

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1, 2, 3, 4]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1, 2, 3, 4, 10, 20, 30]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 在第一个元素之后插入}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1, 5, 2, 3, 4, 10, 20, 30]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1, 5, 3, 4, 10, 20, 30]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1, 5, 3, 10, 20, 30]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{reverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[30, 20, 10, 5, 3, 1] \PYGZsh{}\PYGZsh{} 直接修改 a，无返回值。使用 sorted 返回排序后的副本。}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a2} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1, 5, 10, 20, 30] \PYGZsh{}\PYGZsh{} a}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{dict}
\begin{itemize}
\item {} 
获取：keys()，values()，items()。

\item {} 
清除：clear()

\item {} 
访问：get(key)，不存在时返回None。

\item {} 
更新：update(d)，把另一个字典d中的项添加到当前字典。

\item {} 
浅复制：copy()

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{info} \PYG{o}{=}\PYG{p}{\PYGZob{}}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tom}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sex}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{man}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{info}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{age}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{info}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{man}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{info}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{age}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{man}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{info}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{age}\PYG{p}{)}
\PYG{l+m+mi}{25}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{new} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{60}\PYG{p}{\PYGZcb{}}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{info}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{new}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{info}
\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{age}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{weight}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{60}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{man}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{info}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{info}
\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
collections.defaultdict：defaultdict类使用一种给定数据类型来初始化。当所访问的key不存在的时候，会实例化一个value作为默认值。因此，判断某个key是否存在，可使用get(key)。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{defaultdict}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dd} \PYG{o}{=} \PYG{n}{defaultdict}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 使用 list 作为value type}
\PYG{g+go}{defaultdict(\PYGZlt{}type \PYGZsq{}list\PYGZsq{}\PYGZgt{}, \PYGZob{}\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dd}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{[]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dd}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{defaultdict(\PYGZlt{}type \PYGZsq{}list\PYGZsq{}\PYGZgt{}, \PYGZob{}\PYGZsq{}a\PYGZsq{}: [], \PYGZsq{}b\PYGZsq{}: [\PYGZsq{}hello\PYGZsq{}]\PYGZcb{})}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{set}
\begin{itemize}
\item {} 
特征：无重复，无须，每个元素为不可变类型

\item {} 
增加元素：单个元素，add()；多个元素，update()

\item {} 
删除：删除元素不存在，remove()报错，discard()无反应。

\item {} 
集合操作：\&，\textbar{}，-，交差补集 \textasciicircum{}，issubset() 、isupperset()。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 或者 s1 = set([\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{s1}
\PYG{g+go}{set([\PYGZsq{}a\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}e\PYGZsq{}, \PYGZsq{}d\PYGZsq{}])}
\end{sphinxVerbatim}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
对于 \sphinxcode{\sphinxupquote{切片（slice）}} 操作，下标越界 \sphinxstylestrong{不会} 报错，返回空。

对于 \sphinxcode{\sphinxupquote{索引（index）}} 操作，下标越界 \sphinxstylestrong{会} 报错。
\end{sphinxadmonition}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{j}\PYG{p}{]}

\PYG{n}{The} \PYG{n+nb}{slice} \PYG{n}{of} \PYG{n}{s} \PYG{k+kn}{from} \PYG{n+nn}{i} \PYG{n}{to} \PYG{n}{j} \PYG{o+ow}{is} \PYG{n}{defined} \PYG{k}{as} \PYG{n}{the} \PYG{n}{sequence} \PYG{n}{of} \PYG{n}{items} \PYG{k}{with} \PYG{n}{index} \PYG{n}{k} \PYG{n}{such} \PYG{n}{that} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{o}{.}

\PYG{n}{If} \PYG{n}{i} \PYG{o+ow}{or} \PYG{n}{j} \PYG{o+ow}{is} \PYG{n}{greater} \PYG{n}{than} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{,} \PYG{n}{use} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{If} \PYG{n}{i} \PYG{o+ow}{is} \PYG{n}{omitted} \PYG{o+ow}{or} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{use} \PYG{l+m+mf}{0.}
\PYG{n}{If} \PYG{n}{j} \PYG{o+ow}{is} \PYG{n}{omitted} \PYG{o+ow}{or} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{use} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{If} \PYG{n}{i} \PYG{o+ow}{is} \PYG{n}{greater} \PYG{n}{than} \PYG{o+ow}{or} \PYG{n}{equal} \PYG{n}{to} \PYG{n}{j}\PYG{p}{,} \PYG{n}{the} \PYG{n+nb}{slice} \PYG{o+ow}{is} \PYG{n}{empty}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{深复制和浅复制}
\label{\detokenize{python/08_basicType:id3}}\begin{itemize}
\item {} 
\sphinxstylestrong{直接赋值} ：并没有拷贝对象，而是拷贝了对象的引用，因此原始对象或被赋值对象的改变，都会导致另一个对象被修改。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{alist} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 引用}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{alist}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 复制}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{c}
\PYG{g+go}{[1, 2, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{c}
\PYG{g+go}{[1, 2, 3]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{浅复制} ：只会复制父对象，而不会复制对象的内部的子对象。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{copy}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{alist} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} [\PYGZsq{}a\PYGZsq{},\PYGZsq{}b\PYGZsq{}] 是列表，是一个子对象}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}copy} \PYG{o}{=} \PYG{n}{copy}\PYG{p}{(}\PYG{n}{alist}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} dict类有copy()方法，e.g.，d.copy()}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{alist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 非子对象的修改}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{alist}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{a\PYGZus{}copy}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}copy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{alist}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{a\PYGZus{}copy}
\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{alist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 子对象的修改}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{alist}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{a\PYGZus{}copy}
\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}copy}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{alist}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{a\PYGZus{}copy}
\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{深复制} ：复制对象及其子对象，原始对象的改变不会造成深复制里任何子元素的改变。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{deepcopy}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{alist} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} [\PYGZsq{}a\PYGZsq{},\PYGZsq{}b\PYGZsq{}] 是列表，是一个子对象}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}copy} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{alist}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{alist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 子对象的修改}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{alist}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{a\PYGZus{}copy}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}copy}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{alist}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{a\PYGZus{}copy}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\end{itemize}


\subsection{参考资料}
\label{\detokenize{python/08_basicType:id4}}\begin{enumerate}
\item {} 
Python基本数据类型

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/littlefivebolg/p/8982889.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
切片python字符串时 为何不会引起下标越界?

\end{enumerate}
\begin{quote}

\sphinxurl{https://segmentfault.com/q/1010000011412371}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
python中defaultdict方法的使用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/dancesir/p/8142775.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
python的复制，深拷贝和浅拷贝的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/xueli/p/4952063.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Python学习日记之字典深复制与浅复制

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/mokero/p/6662202.html}
\end{quote}


\section{random}
\label{\detokenize{python/09_random:random}}\label{\detokenize{python/09_random::doc}}

\subsection{random}
\label{\detokenize{python/09_random:id1}}
python自带的random库。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{random.random()}
\begin{itemize}
\item {} 
生成0\textasciitilde{}1的随机浮点数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.uniform(a,b)}
\begin{itemize}
\item {} 
生成指定范围{[}a, b{]}内的随机浮点数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.randint(a,b)}
\begin{itemize}
\item {} 
生成指定范围{[}a, b{]}内的随机整数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.randrange(start,stop,step)}
\begin{itemize}
\item {} 
指定范围内，按step递增的集合中的随机数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.choice()}
\begin{itemize}
\item {} 
给定的集合中选择一个元素。

\end{itemize}

\item {} 
\sphinxstylestrong{random.shuffle(lst)}
\begin{itemize}
\item {} 
对一个序列或者元组随机打乱。

\end{itemize}

\end{itemize}


\subsection{numpy.random}
\label{\detokenize{python/09_random:numpy-random}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{numpy.random.random({[}d0, d1, …, dn{]})}
\begin{itemize}
\item {} 
生成0\textasciitilde{}1的随机浮点数，维度为 d0*d1* …*dn（缺省为1）。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.rand(d0, d1, …, dn)}
\begin{itemize}
\item {} 
生成0\textasciitilde{}1的随机浮点数，维度为 d0*d1* …*dn（缺省为1）。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.randn(d0, d1, …, dn)}
\begin{itemize}
\item {} 
标准正态分布。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.randint(low, high=None, size=None, dtype=’l’)}
\begin{itemize}
\item {} 
返回随机的整数，位于半开区间 {[}low, high)。如果high=None，区间为{[}0, low)。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.choice(a, size=None, replace=True, p=None)}
\begin{itemize}
\item {} 
从一个给定的一维数组，按概率p抽样一定数量的元素，replace=True表示允许重复元素。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.shuffle(arr)}
\begin{itemize}
\item {} 
随机打乱arr。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.permutation(arr)}
\begin{itemize}
\item {} 
返回一个随机排列。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.seed(n)}
\begin{itemize}
\item {} 
改变随机数生成器的种子。设置相同的seed，每次生成的随机数相同；如果不设置seed，则每次会生成不同的随机数。

\end{itemize}

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 注：生成的数组都是 numpy array 类型}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{2.5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{3}
\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.52410303}  \PYG{l+m+mf}{1.68461615} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.04895917}  \PYG{l+m+mf}{2.81907944}\PYG{p}{]}
 \PYG{p}{[} \PYG{l+m+mf}{6.89754303}  \PYG{l+m+mf}{2.95949232}  \PYG{l+m+mf}{1.85296809}  \PYG{l+m+mf}{1.56361545}\PYG{p}{]}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{]}
 \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 从 np.arange(4) 选取 3 个元素}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{9} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{3}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{shuffle}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{arr}
\PYG{p}{[}\PYG{l+m+mi}{6} \PYG{l+m+mi}{9} \PYG{l+m+mi}{0} \PYG{l+m+mi}{8} \PYG{l+m+mi}{1} \PYG{l+m+mi}{7} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{5} \PYG{l+m+mi}{8} \PYG{l+m+mi}{9} \PYG{l+m+mi}{7} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{6} \PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{[} \PYG{l+m+mi}{9}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{4} \PYG{l+m+mi}{12} \PYG{l+m+mi}{15}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}
\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5}\PYG{p}{]}
 \PYG{p}{[}\PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{l+m+mi}{8}\PYG{p}{]}
 \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{0.417022004702574}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{0.417022004702574}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{0.7203244934421581}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/09_random:id2}}\begin{enumerate}
\item {} 
random与numpy.random

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/36a4bbb5536e}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
numpy的random模块详细解析

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/zuoshoushizi/p/8727773.html}
\end{quote}


\section{归一化}
\label{\detokenize{python/10_normalize::doc}}\label{\detokenize{python/10_normalize:id1}}

\subsection{numpy.linalg.norm}
\label{\detokenize{python/10_normalize:numpy-linalg-norm}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n+nb}{ord}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{sklearn.preprocessing.normalize}
\label{\detokenize{python/10_normalize:sklearn-preprocessing-normalize}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sklearn.preprocessing.normalize(X, norm=’l2’, axis=1, copy=True, return\PYGZus{}norm=False)
\end{sphinxVerbatim}


\subsection{torch.nn.functional.normalize}
\label{\detokenize{python/10_normalize:torch-nn-functional-normalize}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{torch}\PYG{o}{.}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{functional}\PYG{o}{.}\PYG{n}{normalize}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{dim}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{eps}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}12}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy.linalg} \PYG{k+kn}{as} \PYG{n+nn}{la}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{arr}
\PYG{g+go}{[[ 2.  1.  2.]}
\PYG{g+go}{ [ 2.  1.  1.]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{norm} \PYG{o}{=} \PYG{n}{la}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{norm}
\PYG{g+go}{[[ 2.82842708  1.41421354  2.23606801]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{arr} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tile}\PYG{p}{(}\PYG{n}{norm}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[[ 0.70710677  0.70710677  0.89442718]}
\PYG{g+go}{ [ 0.70710677  0.70710677  0.44721359]]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{n}{preprocessing}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{preprocessing}\PYG{o}{.}\PYG{n}{normalize}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{norm}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[[ 0.70710677  0.70710677  0.89442718]}
\PYG{g+go}{ [ 0.70710677  0.70710677  0.44721359]]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{torch.nn.functional} \PYG{k+kn}{as} \PYG{n+nn}{F}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{F}\PYG{o}{.}\PYG{n}{normalize}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{from\PYGZus{}numpy}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{dim}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{0.7071  0.7071  0.8944}
\PYG{g+go}{0.7071  0.7071  0.4472}
\PYG{g+go}{[torch.FloatTensor of size 2x3]}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/10_normalize:id2}}\begin{enumerate}
\item {} 
numpy.linalg.norm

\end{enumerate}
\begin{quote}

\sphinxurl{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.linalg.norm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
sklearn.preprocessing.normalize

\end{enumerate}
\begin{quote}

\sphinxurl{https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
torch.nn.functional.normalize

\end{enumerate}
\begin{quote}

\sphinxurl{https://pytorch.org/docs/0.3.0/nn.html?highlight=normalize\#torch.nn.functional.normalize}
\end{quote}


\section{常用数据结构}
\label{\detokenize{python/11_dataStruct::doc}}\label{\detokenize{python/11_dataStruct:id1}}

\subsection{栈}
\label{\detokenize{python/11_dataStruct:id2}}
\sphinxstylestrong{list} 的 \sphinxcode{\sphinxupquote{append()}} 和 \sphinxcode{\sphinxupquote{pop()}} 方法使得list类型可以作为简单的栈使用。


\subsection{队列}
\label{\detokenize{python/11_dataStruct:id3}}

\subsubsection{Queue}
\label{\detokenize{python/11_dataStruct:queue}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Queue}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
FIFO

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Queue.Queue(maxsize=0)
先进先出。
maxsize指明了队列中能存放的数据个数的上限。
一旦达到上限，插入会导致阻塞，直到队列中的数据被消费掉。
如果maxsize小于或者等于0，队列大小没有限制。
\end{sphinxVerbatim}

\item {} 
LIFO

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Queue.LifoQueue(maxsize=0)
后进先出，类似于栈。
\end{sphinxVerbatim}

\item {} 
Priority

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Queue.PriorityQueue(maxsize=0)
优先队列。
一般使用tuple（优先级+数据）作为队列元素，优先级为tuple的第一项。
默认sorted(list(entries))[0])，即tuple第一项越小，优先级越高，越先出队列。
\end{sphinxVerbatim}

\end{itemize}

插入元素

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} que is an initialization of Queue}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
\end{sphinxVerbatim}

弹出并返回元素

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{item} \PYG{o}{=} \PYG{n}{que}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

判断是否为空

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{que}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

队列大小

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{que}\PYG{o}{.}\PYG{n}{qsize}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{Queue} \PYG{k+kn}{import} \PYG{n}{PriorityQueue}
\PYG{n}{que} \PYG{o}{=} \PYG{n}{PriorityQueue}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{app}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{que}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{que}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{que}\PYG{o}{.}\PYG{n}{qsize}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} print result}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} (1, \PYGZsq{}apple\PYGZsq{}) 2}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} (5, \PYGZsq{}banana\PYGZsq{}) 1}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} (10, \PYGZsq{}app\PYGZsq{}) 0}
\end{sphinxVerbatim}


\subsubsection{deque}
\label{\detokenize{python/11_dataStruct:deque}}
double-ended queue，双端队列。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k}{import} \PYG{n}{deque}
\end{sphinxVerbatim}
\begin{description}
\item[{方法：}] \leavevmode\begin{itemize}
\item {} 
append(), appendleft()

\item {} 
pop(), popleft()

\item {} 
extend(), extendleft()

\item {} 
reverse()

\item {} 
rotate()

\item {} 
count()

\item {} 
clear()

\end{itemize}

\end{description}

例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([0, 1, 2, 3, 4])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} right\PYGZhy{}shift}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([4, 0, 1, 2, 3])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([1, 2, 3, 4, 0])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} left\PYGZhy{}shift}
\PYG{g+go}{deque([4, 0, 1, 2, 3])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([3, 2, 1, 0, 4])}
\end{sphinxVerbatim}


\subsection{堆}
\label{\detokenize{python/11_dataStruct:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{heapq}
\end{sphinxVerbatim}

heapq创建的是 \sphinxstylestrong{小顶堆} ，堆顶元素是堆的最小元素。


\subsubsection{创建堆}
\label{\detokenize{python/11_dataStruct:id5}}\begin{itemize}
\item {} 
\sphinxstylestrong{heappush()}

基于空列表{[}{]}，使用 \sphinxcode{\sphinxupquote{heappush()}} 把元素逐个插入堆中。 \sphinxcode{\sphinxupquote{heappop(h)}} 弹出并返回堆顶元素。h{[}0{]}是最小值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{heapsort}\PYG{p}{(}\PYG{n}{iterable}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{iterable}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappush}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{p}{[}\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 不能直接返回 h}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapsort}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{heapify(list\_x)}

把列表转换为堆，in-place，线性时间。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{132}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heapify}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{h}
\PYG{g+go}{[1, 2, 5, 3, 54, 23, 132] \PYGZsh{}\PYGZsh{} h 是堆，但是h不一定是有序的，只能保证 h[0] 是最小值。}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{p}{[}\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{[1, 2, 3, 5, 23, 54, 132]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{merge}

合并多个排序后的序列，返回排序后的序列的迭代器。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{132}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{656}\PYG{p}{,} \PYG{l+m+mi}{324}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h1} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{h1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h2} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{h2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{merge}\PYG{p}{(}\PYG{n}{h1}\PYG{p}{,} \PYG{n}{h2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}type \PYGZsq{}generator\PYGZsq{}\PYGZgt{} [2, 3, 5, 12, 23, 23, 23, 32, 34, 54, 54, 132, 324, 656]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{heapreplace}

删除堆中最小元素，并插入新的元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{132}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heapify}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heapreplace}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{p}{[}\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{[5, 9, 23, 32, 34, 54, 132]}
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{获取最值}
\label{\detokenize{python/11_dataStruct:id6}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nlargest}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{iterable}\PYG{p}{[}\PYG{p}{,} \PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nsmallest}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{iterable}\PYG{p}{[}\PYG{p}{,} \PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

返回一个长度为n的列表，包含数据中的前n个最大/最小的元素。使用key定义排序关键字。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nums} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nlargest}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}
\PYG{g+go}{[5, 4, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nsmallest}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}
\PYG{g+go}{[1, 2, 3]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info} \PYG{o}{=} \PYG{p}{[}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IBM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{91.1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{AAPL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{543.22}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FB}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{21.09}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HPQ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{31.75}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{YHOO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{16.35}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ACME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{115.65}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{... }\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cheap} \PYG{o}{=} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nsmallest}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{info}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{n}{x}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{expensive} \PYG{o}{=} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nlargest}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{info}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{n}{x}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{cheap}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}price\PYGZsq{}: 16.35, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}YHOO\PYGZsq{}\PYGZcb{}, \PYGZob{}\PYGZsq{}price\PYGZsq{}: 21.09, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}FB\PYGZsq{}\PYGZcb{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{expensive}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}price\PYGZsq{}: 543.22, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}AAPL\PYGZsq{}\PYGZcb{}, \PYGZob{}\PYGZsq{}price\PYGZsq{}: 115.65, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}ACME\PYGZsq{}\PYGZcb{}]}
\end{sphinxVerbatim}


\subsection{计数器}
\label{\detokenize{python/11_dataStruct:id7}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k}{import} \PYG{n}{Counter}
\end{sphinxVerbatim}

Counter用于统计频率。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 空计数器}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{word} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{cnt}\PYG{p}{[}\PYG{n}{word}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}blue\PYGZsq{}: 3, \PYGZsq{}red\PYGZsq{}: 2, \PYGZsq{}green\PYGZsq{}: 1\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}blue\PYGZsq{}: 3, \PYGZsq{}red\PYGZsq{}: 2, \PYGZsq{}green\PYGZsq{}: 1\PYGZcb{})}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt}\PYG{o}{.}\PYG{n}{most\PYGZus{}common}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 返回出现频率最高的两个元素}
\PYG{g+go}{[(\PYGZsq{}blue\PYGZsq{}, 3), (\PYGZsq{}red\PYGZsq{}, 2)]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gallahad}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}a\PYGZsq{}: 3, \PYGZsq{}l\PYGZsq{}: 2, \PYGZsq{}h\PYGZsq{}: 1, \PYGZsq{}g\PYGZsq{}: 1, \PYGZsq{}d\PYGZsq{}: 1\PYGZcb{})}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}blue\PYGZsq{}: 12, \PYGZsq{}red\PYGZsq{}: 4\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 访问不存在关键字, 可使用 c.get(\PYGZsq{}green\PYGZsq{})}
\PYG{g+go}{0}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/11_dataStruct:id8}}\begin{enumerate}
\item {} 
python中的Queue(队列)详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/wdliu/p/6905396.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Python collections使用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/f2a429aa5963}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Python标准库模块之heapq

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/801318c77ab5}

\sphinxurl{https://docs.python.org/2/library/heapq.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Counter

\end{enumerate}
\begin{quote}

\sphinxurl{https://docs.python.org/2/library/collections.html?highlight=counter}
\end{quote}


\chapter{Linux/Shell}
\label{\detokenize{linux/index:linux-shell}}\label{\detokenize{linux/index::doc}}

\section{基本命令}
\label{\detokenize{linux/01_basic::doc}}\label{\detokenize{linux/01_basic:id1}}

\subsection{文件和目录}
\label{\detokenize{linux/01_basic:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} ..
\PYG{n+nb}{pwd}
ls \PYGZhy{}a \PYGZhy{}F \PYGZhy{}R

cp \PYG{o}{[}\PYGZhy{}i\PYG{o}{]} \PYG{n+nb}{source} destination
cp \PYGZhy{}R

mv src des
rm \PYGZhy{}i \PYGZhy{}r \PYGZhy{}f folder

touch new \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 创建新文件或修改文件时间属性}

mkdir new
rmdir new

file my\PYGZus{}file \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 查看文件类型}

cat \PYGZhy{}n log.txt
tail log.txt
head \PYGZhy{}5 log.txt

wc file \PYGZhy{}c \PYGZhy{}w \PYGZhy{}l
\end{sphinxVerbatim}


\subsection{磁盘空间}
\label{\detokenize{linux/01_basic:id3}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
df \PYGZhy{}h
du \PYG{o}{[}\PYGZhy{}s\PYG{o}{]} \PYGZhy{}h
\end{sphinxVerbatim}


\subsection{处理数据文件}
\label{\detokenize{linux/01_basic:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sort \PYG{o}{[}\PYGZhy{}n\PYG{o}{]} log.txt

grep \PYG{o}{[}\PYGZhy{}n\PYG{o}{]} \PYG{o}{[}\PYGZhy{}c\PYG{o}{]} t file \PYG{c+c1}{\PYGZsh{}\PYGZsh{} find *t* in file}

gzip my*
gunzip myfile.gz

tar \PYGZhy{}cvf test.tar test/
tar \PYGZhy{}xvf test.tar
tar \PYGZhy{}xzvf test.tgz
\end{sphinxVerbatim}


\chapter{机器学习}
\label{\detokenize{machineLearning/index::doc}}\label{\detokenize{machineLearning/index:id1}}

\section{Logistic Regression}
\label{\detokenize{machineLearning/01_lr:logistic-regression}}\label{\detokenize{machineLearning/01_lr::doc}}
模型：
\begin{equation*}
\begin{split}h_\theta(\mathbf{x}) = g(\theta^\top \mathbf{x}),\\
g(z) = \frac{1}{1+e^{-z}},\\
g^\prime(z) = (1-g(z))g(z) \in (0, 0.25].\end{split}
\end{equation*}
对数损失函数（极大似然）：
\begin{equation*}
\begin{split}\mathcal{l}_\theta = -\frac{1}{m} \sum_{i=1}^m y^{(i)}log\  h_\theta(\mathbf{x}^{(i)}) + (1 - y^{(i)})log(1 - h_\theta(\mathbf{x}^{(i)}))\end{split}
\end{equation*}
虽然使用了sigmoid函数，但该模型仍然是线性分类器，因为即使不经过sigmoid函数也可以得出分类结果（与0比较），sigmoid将其转化为概率。


\subsection{基本假设}
\label{\detokenize{machineLearning/01_lr:id1}}\begin{enumerate}
\item {} 
数据服从伯努利分布， \(y \sim Bernoulli(\phi)\)

\item {} 
样例为正例的概率为 \(\phi=h_\theta(\mathbf{x})\)

\end{enumerate}


\subsection{求解方法}
\label{\detokenize{machineLearning/01_lr:id2}}\begin{description}
\item[{梯度下降}] \leavevmode\begin{itemize}
\item {} 
批梯度下降：全局最优；每次参数更新需要遍历所有样本，计算量大，效率低。

\item {} 
随机梯度下降（SGD）：以高方差频繁更新，能跳到新的、更好的局部最优解；收敛到局部最优的过程更加复杂。

\item {} 
小批量梯度下降：减少了参数更新次数，达到更稳定的收敛结果。

\end{itemize}

\end{description}


\subsection{优缺点}
\label{\detokenize{machineLearning/01_lr:id3}}\begin{description}
\item[{优点}] \leavevmode\begin{itemize}
\item {} 
模型简单，可解释性好，效果不错

\item {} 
训练速度快，资源占用少

\item {} 
直接输出样本的分类概率，便于做阈值划分

\end{itemize}

\item[{缺点}] \leavevmode\begin{itemize}
\item {} 
准确性不高

\item {} 
很难处理数据不平衡问题

\item {} 
只能处理线性问题

\item {} 
逻辑回归本身无法筛选特征

\end{itemize}

\end{description}


\subsection{解析}
\label{\detokenize{machineLearning/01_lr:id4}}\begin{enumerate}
\item {} 
为什么使用极大似然函数作为损失函数？

\end{enumerate}
\begin{itemize}
\item {} 
极大似然：希望最大化每个样本的分类正确概率，样本服从伯努利分布。

\item {} 
将极大似然取对数后就等同于对数损失函数，在LR模型中，这个损失函数使参数更新速度较快：
\begin{equation*}
\begin{split}\theta_j := \theta_j + \alpha \frac{1}{m} \sum_{i=1}^m (y^{(i)} - h_\theta(\mathbf{x}^{(i)}))\mathbf{x}_j^{(i)}\end{split}
\end{equation*}
只与 \(y^{(i)},\mathbf{x}^{(i)}\) 有关，与 \(h_\theta\) 的梯度无关。

\item {} 
为什么不用平方损失函数（多用于线性回归）？在线性回归中，前提假设是 \(y\) 服从正态分布，即 \(y \sim \mathcal{N}(\mu, \sigma^2)\) 。
另外，如果使用平方损失函数， \(\theta\) 更新与 \(h_\theta\) 的梯度有关，而sigmoid函数的梯度在定义域内小于0.25，导致参数更新慢。

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
训练中如何有很多特征高度相关或将某个特征重复100遍，影响如何？

\end{enumerate}
\begin{quote}

如果损失函数收敛，不影响分类结果（每个特征对应的权重 \(\theta_j\) 变为原来的百分之一）。将相关特征去除，使模型具有更好的解释性，也能加快训练速度。
\end{quote}


\subsection{参考资料}
\label{\detokenize{machineLearning/01_lr:id5}}\begin{enumerate}
\item {} 
逻辑回归的常见面试点总结

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/ModifyRong/p/7739955.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
LR逻辑斯回归分析（优缺点）

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/touch\_dream/article/details/79371462}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
logistic 回归（内附推导）

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/894bda167422}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
周志华《机器学习》Page 57 \textendash{} 60。

\end{enumerate}


\section{支持向量机}
\label{\detokenize{machineLearning/02_svm::doc}}\label{\detokenize{machineLearning/02_svm:id1}}
样本空间中任意点到超平面的距离为：
\begin{equation*}
\begin{split}r = \frac{|w^T x + b|}{\| w \|}\end{split}
\end{equation*}
原始问题：
\begin{equation*}
\begin{split}\underset{w,b}{min} \  \frac{1}{2} \left \| w \right \|^2 \\
s.t. \  y_i(w^T x + b) \geqslant 1, i=1,2,...,m\end{split}
\end{equation*}
拉格朗日函数：
\begin{equation*}
\begin{split}L(w,b,\alpha) = \frac{1}{2}w^Tw + \sum_{i=1}^m \alpha_i(1 - y_i(w^T x + b)),\\
\underset{w,b}{min}(\underset{\alpha_i>0}{max}L(w,b,\alpha))\end{split}
\end{equation*}
对偶问题：
\begin{equation*}
\begin{split}\underset{\alpha_i>0}{max}(\underset{w,b}{min}L(w,b,\alpha))\end{split}
\end{equation*}
即：
\begin{equation*}
\begin{split}\underset{\alpha>0}{max} \sum_{i=1}^m\alpha_i - \frac{1}{2} \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j x_i^T x_j,\  w=\sum_{i=1}^m\alpha_i y_i x_i\end{split}
\end{equation*}
KKT条件：
\begin{equation*}
\begin{split}y_i(w^T x + b) \geqslant 1, \\
\sum_{i=1}^m \alpha_i y_i = 0,\\
\alpha_i (1 - y_i(w^T x + b)) = 0.\end{split}
\end{equation*}

\subsection{核函数}
\label{\detokenize{machineLearning/02_svm:id2}}
核函数 \(\mathcal{K}\)
\begin{itemize}
\item {} 
对称半正定。( \(\mathcal{K} \geqslant 0: \forall z,\  z^T\mathcal{K}z \geqslant 0.\) )

\item {} 
主要使用线性核，高斯核（RBF）。

\item {} 
当特征维度高且样本少，不宜使用高斯核，容易过拟合。

\item {} 
当特征维度低，且样本够多，考虑使用高斯核。首先需要特征缩放（归一化）。若 \(\sigma\) 过大，导致特征间差异变小，欠拟合。

\end{itemize}


\subsection{多分类}
\label{\detokenize{machineLearning/02_svm:id3}}\begin{enumerate}
\item {} 
一对一（ \(O(N^2)\) ）

\item {} 
一对多（ \(O(N)\) ）

\item {} 
使用多分类loss

\end{enumerate}


\subsection{SVM库}
\label{\detokenize{machineLearning/02_svm:svm}}
sklearn, libsvm


\subsection{优缺点}
\label{\detokenize{machineLearning/02_svm:id4}}\begin{description}
\item[{优点}] \leavevmode\begin{itemize}
\item {} 
基于结构风险最小化，泛化能力强（自带正则化， \(\left \| w \right \|^2\) ）。

\item {} 
它是凸优化问题，可得到全局最优。

\item {} 
SVM在小样本训练集上可得到比其他方法好的结果。

\item {} 
利用核函数，可借助线性可分问题的求解方法，直接求解对应高维空间的问题。

\end{itemize}

\item[{缺点}] \leavevmode\begin{itemize}
\item {} 
SVM对缺失特征敏感。

\item {} 
如何确定核函数？

\item {} 
求解问题的二次规划，耗时耗存储。

\end{itemize}

\end{description}


\subsection{解析}
\label{\detokenize{machineLearning/02_svm:id5}}\begin{enumerate}
\item {} 
为什么要间隔最大化？

\end{enumerate}
\begin{quote}

最优超平面，解唯一，更加鲁棒。
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
为什么转化为对偶问题？

\end{enumerate}
\begin{itemize}
\item {} 
便于求解（交换 \(\alpha\) 和 \((w,b)\) 位置之后，可直接对 \((w,b)\) 求导）。

\item {} 
解的过程可以引入核函数。

\end{itemize}


\subsection{SVM与LR的异同}
\label{\detokenize{machineLearning/02_svm:svmlr}}
相同点：
\begin{itemize}
\item {} 
都是分类算法。

\item {} 
不考虑核函数，分类面都是线性。

\item {} 
都是监督学习算法。

\item {} 
都是判别模型。（判别模型：KNN，SVM，LR；生成模型：HMM，朴素贝叶斯）

\end{itemize}

不同点：
\begin{itemize}
\item {} 
本质不同：loss function不同

\item {} 
SVM只有支持向量影响模型，LR中每个样本都有作用。

\item {} 
SVM针对线性不可分问题有核函数。

\item {} 
SVM依赖样本间的距离测度，样本特征需要归一化，也就是说SVM基于距离，LR基于概率。

\item {} 
SVM是结构风险最小化算法（在训练误差和模型复杂度之间的折中，防止过拟合，从而达到真实误差最小化）。因为SVM自带正则（ \(\left \| w \right \|^2\) ）。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{machineLearning/02_svm:id6}}\begin{enumerate}
\item {} 
LR与SVM的异同

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/zhizhan/p/5038747.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
核函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/loujiayu/archive/2013/12/19/3481320.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
SVM面试题

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/fa02098bc220}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
SVM的优缺点

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/fengzhizizhizizhizi/article/details/23911699}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
机器学习技法\textendash{}SVM的对偶问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/de882f0fc434}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
周志华《机器学习》Page 121 \textendash{} 124。

\end{enumerate}


\section{主成分分析PCA}
\label{\detokenize{machineLearning/03_pca:pca}}\label{\detokenize{machineLearning/03_pca::doc}}
\sphinxstylestrong{最大可分性} ：样本点到超平面的投影能尽可能分开（投影后样本点方差最大化）。


\subsection{优化目标}
\label{\detokenize{machineLearning/03_pca:id1}}\begin{equation*}
\begin{split}\underset{W}{max} \ tr(W^TXX^TW) \\
s.t. \ W^TW=I. \\
X \in \mathbb{R}^{d \times m}, \\
W \in \mathbb{R}^{d \times d^\prime}, \ d^\prime < d.\end{split}
\end{equation*}

\subsection{求解}
\label{\detokenize{machineLearning/03_pca:id2}}\begin{enumerate}
\item {} 
计算样本的协方差矩阵 \(C = XX^T\) ；

\item {} 
对协方差矩阵做特征值分解（EVD）；

\item {} 
取最大的 \(d^\prime\) 个特征值 \((\lambda_1, \lambda_2,...,\lambda_{d^\prime})\) 对应的特征向量：
\begin{quote}
\begin{equation*}
\begin{split}W = (w_1, w_2,...,w_{d^\prime})\end{split}
\end{equation*}\end{quote}

\end{enumerate}


\subsection{PCA白化}
\label{\detokenize{machineLearning/03_pca:id3}}\begin{description}
\item[{白化的目的是降低输入的冗余性：}] \leavevmode\begin{itemize}
\item {} 
特征之间相关性降低

\item {} 
所有特征具有相同的方差

\end{itemize}

\end{description}
\begin{equation*}
\begin{split}x_{rot} = W^T x, \\
x_{pca\ white, i} \ = \frac{x_{rot, i}}{\sqrt{\lambda_i}}\end{split}
\end{equation*}

\subsection{SVD分解}
\label{\detokenize{machineLearning/03_pca:svd}}\begin{equation*}
\begin{split}A = U \Sigma V^T,\\
A \in \mathbb{R}^{m \times n}, \\
rank(A) = r,\\
U \in \mathbb{R}^{m \times r}, \\
\Sigma \in \mathbb{R}^{r \times r}, \\
V \in \mathbb{R}^{n \times r}\end{split}
\end{equation*}
其中 \(U\) 是 \(AA^T\) 的特征向量矩阵， \(V\) 是 \(A^TA\) 的特征向量矩阵。

当 \(d\) 很大时， \(C=XX^T\) 是很高维的矩阵，计算该矩阵并求特征向量开销大。此时对 \(X\) 做SVD分解，得到 \(U\) 便是
协方差矩阵 \(C\) 的特征向量。


\subsection{参考资料}
\label{\detokenize{machineLearning/03_pca:id4}}\begin{enumerate}
\item {} 
周志华《机器学习》Page 229 \textendash{} 232。

\item {} 
ufldl

\end{enumerate}
\begin{quote}

\sphinxurl{http://ufldl.stanford.edu/wiki/index.php/PCA}
\end{quote}


\chapter{深度学习}
\label{\detokenize{deepLearning/index::doc}}\label{\detokenize{deepLearning/index:id1}}

\section{pytorch的多GPU模式}
\label{\detokenize{deepLearning/01_dataParallel::doc}}\label{\detokenize{deepLearning/01_dataParallel:pytorchgpu}}
\sphinxstylestrong{pytorch} 中可以通过 \sphinxcode{\sphinxupquote{torch.nn.DataParallel}} 切换到多GPU(multi-GPU)模式，有两种使用方式：网络外指定、网络内指定。


\subsection{网络外指定}
\label{\detokenize{deepLearning/01_dataParallel:id1}}
使用方法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} 在GPU上运行}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 使用第0、1、2个GPU，注意设定batch\PYGZus{}size大一些，否则数据不足以跑多GPU}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{parallel}\PYG{o}{.}\PYG{n}{DataParallel}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{device\PYGZus{}ids}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{DataParallel} 只对  \sphinxcode{\sphinxupquote{forward()}} 和 \sphinxcode{\sphinxupquote{backward()}} 有效，直接调用model中自定义的  \sphinxcode{\sphinxupquote{attribute}} 如 \sphinxcode{\sphinxupquote{forward\_1()}} 无效。

另外，在 \sphinxstylestrong{DataParallel} 模式下，引用model的  \sphinxcode{\sphinxupquote{attribute}} 必须采用如下格式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 相比于\PYGZsq{}model.attribute\PYGZsq{}多了\PYGZsq{}module\PYGZsq{}。}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{module}\PYG{o}{.}\PYG{n}{attribute}
\end{sphinxVerbatim}

比如，\sphinxcode{\sphinxupquote{model.module.classifier.parameters()}} 。


\subsection{网络内指定}
\label{\detokenize{deepLearning/01_dataParallel:id2}}
使用方法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} 定义网络结构}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer1} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{227}\PYG{p}{,} \PYG{l+m+mi}{128}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer1} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{DataParallel}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer1}\PYG{p}{,} \PYG{n}{device\PYGZus{}ids}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

在CPU模式下不需要更改代码。


\subsection{参考资料}
\label{\detokenize{deepLearning/01_dataParallel:id3}}\begin{enumerate}
\item {} 
pytorch documentation

\end{enumerate}
\begin{quote}

\sphinxurl{https://pytorch.org/docs/stable/nn.html\#torch.nn.DataParallel}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
网络内指定

\end{enumerate}
\begin{quote}

\sphinxurl{https://ptorch.com/docs/3/parallelism\_tutorial}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
引用attribute

\end{enumerate}
\begin{quote}

\sphinxurl{https://discuss.pytorch.org/t/how-to-reach-model-attributes-wrapped-by-nn-dataparallel/1373}
\end{quote}


\section{激活函数(Activation Function)}
\label{\detokenize{deepLearning/02_activationFunction::doc}}\label{\detokenize{deepLearning/02_activationFunction:activation-function}}
神经网络引入激活函数主要是为了增强网络的非线性，提升网络的拟合能力和学习能力。激活函数有以下几个性质：
\begin{itemize}
\item {} 
非线性

\item {} 
可微性

\item {} 
单调性：保证单层网络是凸函数

\end{itemize}

下面介绍 \sphinxstylestrong{sigmoid} 、\sphinxstylestrong{tanh} 以及 \sphinxstylestrong{ReLU} 。


\subsection{sigmoid}
\label{\detokenize{deepLearning/02_activationFunction:sigmoid}}
\sphinxstylestrong{sigmoid} 函数的数学表达式如下：
\begin{equation*}
\begin{split}\sigma(z) = \frac{1}{1 + e^{-z}}.\end{split}
\end{equation*}
其导数具有如下性质：
\begin{equation*}
\begin{split}\sigma^\prime(z) = \sigma(z)(1-\sigma(z)).\end{split}
\end{equation*}
\sphinxstylestrong{sigmoid} 函数能够把输入的连续值压缩到(0, 1)范围内，其函数曲线如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_sigmoid}.jpeg}\hspace*{\fill}}

优点：
\begin{itemize}
\item {} 
单调连续，输出范围有限，优化稳定

\item {} 
求导容易

\end{itemize}

缺点：
\begin{itemize}
\item {} 
容易饱和。当输入很大、很小时(saturation, 饱和)，神经元的梯度接近0，出现“梯度消失”(gradient vanishing)，导致无法完成深层网络的训练。

\item {} 
输出不是零均值的(not zero-centered)。假设某个神经元的输入一直是正的，即 \(x>0\) . 对于 \(f(x)=w^Tx+b\) ，则 \(w\) 获得的梯度将是恒正或者恒负
（取决于 \(f\) 得到的梯度的符号），导致 \(w\) 的更新非常“曲折”(zig-zagging)。
当然，如果是按batch训练，最终梯度是各个样本下梯度的和，而每个样本下的梯度可能是符号各异的，因此在一定程度上可以缓解这个问题。

\end{itemize}


\subsection{tanh}
\label{\detokenize{deepLearning/02_activationFunction:tanh}}
\sphinxstylestrong{tanh} 函数的数学表达式如下：
\begin{align*}\!\begin{aligned}
tanh(z) = \frac{e^z-e^{-z}}{e^z+e^{-z}},\\
tanh(z) = 2\sigma(2z)-1.\\
\end{aligned}\end{align*}
其函数曲线如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_tanh}.jpeg}\hspace*{\fill}}

与 \sphinxstylestrong{sigmoid} 一样， \sphinxstylestrong{tanh} 也会产生饱和现象，但是 \sphinxstylestrong{tanh} 的输出是零均值的(zero-centered)。


\subsection{ReLU}
\label{\detokenize{deepLearning/02_activationFunction:relu}}
\sphinxstylestrong{ReLU} 函数的数学表达式如下：
\begin{equation*}
\begin{split}relu(z) = max(0,z).\end{split}
\end{equation*}
其函数曲线如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_relu}.jpeg}\hspace*{\fill}}

优点：
\begin{itemize}
\item {} 
计算简单。 \sphinxstylestrong{sigmoid} 和 \sphinxstylestrong{tanh} 都需要计算指数。

\item {} 
收敛速度快。 \sphinxhref{http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf}{Krizhevsky et al. 论文} 指出 \sphinxstylestrong{ReLU} 收敛速度比 \sphinxstylestrong{tanh} 快6倍。
\begin{quote}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_alexplot}.jpeg}\hspace*{\fill}}
\end{quote}

\end{itemize}

缺点:
\begin{itemize}
\item {} 
容易产生死亡节点(dead ReLU)。一个非常大的梯度流过一个 \sphinxstylestrong{ReLU} 神经元，更新过参数之后，这个神经元对很多输入数据都输出0，则梯度一直为0。
当然 \sphinxstylestrong{ReLU} 的输出依靠 \(w\) 和 \(x\) 的共同作用，死亡节点可能会被重新激活。

\end{itemize}

\sphinxstylestrong{LeakyReLU} 可以有效应对上述缺点。


\subsection{参考资料}
\label{\detokenize{deepLearning/02_activationFunction:id1}}\begin{enumerate}
\item {} 
CS231n

\end{enumerate}
\begin{quote}

\sphinxurl{http://cs231n.github.io/neural-networks-1/\#actfun}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
神经网络之激活函数(Activation Function)

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/memray/article/details/51442059}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
What is the “dying ReLU” problem in neural networks?

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.quora.com/What-is-the-dying-ReLU-problem-in-neural-networks}
\end{quote}


\section{Batch Normalization}
\label{\detokenize{deepLearning/03_batchnorm:batch-normalization}}\label{\detokenize{deepLearning/03_batchnorm::doc}}\begin{equation*}
\begin{split}\hat{x}^{(k)} = \frac{x^{(k)} - E[x^{(k)}]}{\sqrt{Var[x^{{(k)}}] + \epsilon}} \\
y^{(k)} = \gamma^{(k)} \hat{x}^{(k)} + \beta^{(k)}\end{split}
\end{equation*}

\subsection{BN允许更大的学习率}
\label{\detokenize{deepLearning/03_batchnorm:bn}}
由于网络参数不断更新，导致各层输入的分布不断变化，导致往往需要使用较小的学习率，并精心设计参数初始化。

使用BN进行归一化之后，各层输入的分布相同，因此可以使用更大的学习率更快地收敛，并降低网络对初始化的依赖。


\subsection{BN提供了正则化的作用}
\label{\detokenize{deepLearning/03_batchnorm:id1}}
进行BN之后，各样本的feature map已经融合了一个batch之中其他样本的特性（均值，方差），因此单一样本的影响变小，网络更好学习整体的规律
，有效地较小了过拟合的可能性。因此，可以不使用dropout。


\subsection{BN回滚}
\label{\detokenize{deepLearning/03_batchnorm:id2}}
如果网络发现这种normalization是多余的，可以通过学习使得：
\begin{equation*}
\begin{split}\gamma^{(k)} = \sqrt{Var[x^{{(k)}}]} \\
\beta^{(k)} = E[x^{(k)}]\end{split}
\end{equation*}
从而消除BN的作用。


\subsection{缺点}
\label{\detokenize{deepLearning/03_batchnorm:id3}}
BN统计均值、方差与batch size有关，batch size太小会导致性能变差。而某些任务受内存限制，batch size难以设置很大，因此BN作用难以显现。
这时候出现了Group Normalization。


\subsection{参考资料}
\label{\detokenize{deepLearning/03_batchnorm:id4}}\begin{enumerate}
\item {} 
Batch Normalization

\end{enumerate}
\begin{quote}

\sphinxurl{https://arxiv.org/pdf/1502.03167.pdf}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Group Normalization

\end{enumerate}
\begin{quote}

\sphinxurl{http://openaccess.thecvf.com/content\_ECCV\_2018/papers/Yuxin\_Wu\_Group\_Normalization\_ECCV\_2018\_paper.pdf}
\end{quote}


\section{过拟合}
\label{\detokenize{deepLearning/04_overfit::doc}}\label{\detokenize{deepLearning/04_overfit:id1}}
复杂的模型将训练数据的抽样误差考虑在内，对抽样误差也进行了拟合。过拟合的模型可以看成是完全记忆型模型。


\subsection{表现}
\label{\detokenize{deepLearning/04_overfit:id2}}
训练误差小，测试误差大，泛化能力差。


\subsection{原因}
\label{\detokenize{deepLearning/04_overfit:id3}}
训练集大小与模型复杂度不匹配；

样本的噪声太大甚至掩盖了真实样本的分布规律；

训练迭代次数太多（over-training）。


\subsection{解决方案}
\label{\detokenize{deepLearning/04_overfit:id4}}
\sphinxstylestrong{1}. 调小模型复杂度。

\sphinxstylestrong{2}. data augmentation.

\sphinxstylestrong{3}. dropout.

\sphinxstylestrong{4}. early stopping. 记录观察validation accuracy，及时停止训练。

\sphinxstylestrong{5}. 集成学习。Bagging：并行化模型生成，减小模型variance。Boosting：串行化模型生成，减小模型bias。

\sphinxstylestrong{6}. 正则化。
\begin{quote}

\textless{}1\textgreater{}. L0正则化（非0元素个数），难以优化求解（NP-hard）。

\textless{}2\textgreater{}. L1正则化（元素绝对值之和， Lasso regression），是L0范数的最优凸近似，使权值稀疏。权值稀疏的好处：特征选择 \&\& 可解释性。

\textless{}3\textgreater{}. L2正则化（元素平方和，Ridge regression / weight dacay），使权值分布均匀且值较小。
\end{quote}


\section{pytorch模型保存与读取}
\label{\detokenize{deepLearning/05_modelSave:pytorch}}\label{\detokenize{deepLearning/05_modelSave::doc}}

\subsection{简单}
\label{\detokenize{deepLearning/05_modelSave:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} save}
\PYG{n}{torch}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model.pkl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} load}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model.pkl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

这种方法存储的模型包括了模型框架及模型参数，一般存取的pkl文件较大。


\subsection{详细}
\label{\detokenize{deepLearning/05_modelSave:id2}}
模型除了本身的框架、参数信息，还应包括训练的信息，比如训练迭代次数、优化器参数等。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{shutil}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} save}
\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}checkpoint}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{is\PYGZus{}best}\PYG{p}{,} \PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}
  \PYG{n}{torch}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}
  \PYG{k}{if} \PYG{n}{is\PYGZus{}best}\PYG{p}{:}
    \PYG{n}{bestname} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model\PYGZus{}best.pth.tar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{shutil}\PYG{o}{.}\PYG{n}{copyfile}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{bestname}\PYG{p}{)}

\PYG{n}{save\PYGZus{}checkpoint}\PYG{p}{(}\PYG{p}{\PYGZob{}}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{cur\PYGZus{}epoch}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{model}\PYG{o}{.}\PYG{n}{state\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{best\PYGZus{}prec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{best\PYGZus{}prec}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss\PYGZus{}train}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{loss\PYGZus{}train}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{optimizer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{state\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
      \PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{is\PYGZus{}best}\PYG{p}{,} \PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch\PYGZhy{}\PYGZob{}\PYGZcb{}\PYGZus{}checkpoint.pth.tar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{cur\PYGZus{}epoch}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} load}
\PYG{k}{def} \PYG{n+nf}{load\PYGZus{}checkpoint}\PYG{p}{(}\PYG{n}{checkpoint}\PYG{p}{,} \PYG{n}{model}\PYG{p}{,} \PYG{n}{optimizer}\PYG{p}{)}\PYG{p}{:}
  \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} loads state into model and optimizer and returns:}
\PYG{l+s+sd}{      epoch, best\PYGZus{}precision, loss\PYGZus{}train[]}
\PYG{l+s+sd}{      e.g., model = alexnet(pretrained=False)}
\PYG{l+s+sd}{  \PYGZdq{}\PYGZdq{}\PYGZdq{}}
  \PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{isfile}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=\PYGZgt{} loading checkpoint }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}\PYG{p}{)}
      \PYG{n}{checkpoint} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}
      \PYG{n}{epoch} \PYG{o}{=} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{best\PYGZus{}prec} \PYG{o}{=} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{best\PYGZus{}prec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{loss\PYGZus{}train} \PYG{o}{=} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss\PYGZus{}train}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{model}\PYG{o}{.}\PYG{n}{load\PYGZus{}state\PYGZus{}dict}\PYG{p}{(}\PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
      \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{load\PYGZus{}state\PYGZus{}dict}\PYG{p}{(}\PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{optimizer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
      \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=\PYGZgt{} loaded checkpoint }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ (epoch \PYGZob{}\PYGZcb{})}\PYG{l+s+s2}{\PYGZdq{}}
            \PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{epoch}\PYG{p}{,} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
      \PYG{k}{return} \PYG{n}{epoch}\PYG{p}{,} \PYG{n}{best\PYGZus{}prec}\PYG{p}{,} \PYG{n}{loss\PYGZus{}train}
  \PYG{k}{else}\PYG{p}{:}
      \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=\PYGZgt{} no checkpoint found at }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}\PYG{p}{)}
      \PYG{c+c1}{\PYGZsh{} epoch, best\PYGZus{}precision, loss\PYGZus{}train}
      \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{load部分参数}
\label{\detokenize{deepLearning/05_modelSave:load}}
当我们只需要从 \sphinxcode{\sphinxupquote{state\_dict()}} load部分模型参数是，可以采用如下方法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} args has the model name, num classes and other irrelevant stuff}
\PYG{n}{pretrained\PYGZus{}state} \PYG{o}{=} \PYG{n}{model\PYGZus{}zoo}\PYG{o}{.}\PYG{n}{load\PYGZus{}url}\PYG{p}{(}\PYG{n}{model\PYGZus{}names}\PYG{p}{[}\PYG{n}{args}\PYG{o}{.}\PYG{n}{arch}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{model\PYGZus{}state} \PYG{o}{=} \PYG{n}{my\PYGZus{}model}\PYG{o}{.}\PYG{n}{state\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{pretrained\PYGZus{}state} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{n}{k}\PYG{p}{:}\PYG{n}{v} \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{pretrained\PYGZus{}state}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{(}\PYG{p}{)} \PYG{k}{if} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{model\PYGZus{}state} \PYG{o+ow}{and} \PYG{n}{v}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{model\PYGZus{}state}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZcb{}}
\PYG{n}{model\PYGZus{}state}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{pretrained\PYGZus{}state}\PYG{p}{)}
\PYG{n}{my\PYGZus{}model}\PYG{o}{.}\PYG{n}{load\PYGZus{}state\PYGZus{}dict}\PYG{p}{(}\PYG{n}{model\PYGZus{}state}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{deepLearning/05_modelSave:id3}}\begin{enumerate}
\item {} 
Saving and loading a model in Pytorch?

\end{enumerate}
\begin{quote}

\sphinxurl{https://discuss.pytorch.org/t/saving-and-loading-a-model-in-pytorch/2610}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
How to load part of pre trained model?

\end{enumerate}
\begin{quote}

\sphinxurl{https://discuss.pytorch.org/t/how-to-load-part-of-pre-trained-model/1113/8}
\end{quote}


\section{pytorch: cuda()}
\label{\detokenize{deepLearning/06_cuda:pytorch-cuda}}\label{\detokenize{deepLearning/06_cuda::doc}}

\subsection{使用指定GPU}
\label{\detokenize{deepLearning/06_cuda:gpu}}\begin{itemize}
\item {} 
\sphinxstylestrong{直接终端中设定}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CUDA\PYGZus{}VISIBLE\PYGZus{}DEVICES}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{python} \PYG{n}{my\PYGZus{}script}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{代码中设定}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{environ}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CUDA\PYGZus{}VISIBLE\PYGZus{}DEVICES}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{使用函数 set\_device}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{n}{torch}\PYG{o}{.}\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{set\PYGZus{}device}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\subsection{cuda()}
\label{\detokenize{deepLearning/06_cuda:cuda}}
对于一个 \sphinxcode{\sphinxupquote{tensor}} 对象，cuda()返回该对象在CUDA内存中的拷贝

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{obj} \PYG{o}{=} \PYG{n}{obj}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

对于一个 \sphinxcode{\sphinxupquote{nn.Module}} 实例，cuda()直接将该模型的参数和buffers转移到GPU。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{deepLearning/06_cuda:id1}}\begin{enumerate}
\item {} 
PyTorch中使用指定的GPU

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/darkknightzh/p/6836568.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
pytorch documentation

\end{enumerate}
\begin{quote}

\sphinxurl{https://pytorch.org/docs/0.3.1/tensors.html?highlight=cuda\#torch.Tensor.cuda}

\sphinxurl{https://pytorch.org/docs/0.3.1/nn.html?highlight=cuda\#torch.nn.Module.cuda}
\end{quote}


\chapter{资源链接}
\label{\detokenize{link/index::doc}}\label{\detokenize{link/index:id1}}

\section{Github Page}
\label{\detokenize{link/index:github-page}}
\sphinxurl{https://fongyk.github.io/}


\section{AnyKnew}
\label{\detokenize{link/index:anyknew}}
\sphinxurl{https://www.anyknew.com/\#/}


\section{arXiv}
\label{\detokenize{link/index:arxiv}}
\sphinxurl{https://arxiv.org/}


\section{Read the Docs}
\label{\detokenize{link/index:read-the-docs}}
\sphinxurl{https://readthedocs.org/}


\section{C++ Reference}
\label{\detokenize{link/index:c-reference}}
\sphinxurl{http://www.cplusplus.com/reference/}


\section{Numpy}
\label{\detokenize{link/index:numpy}}
\sphinxurl{http://cs231n.github.io/python-numpy-tutorial/}


\section{Pytorch}
\label{\detokenize{link/index:pytorch}}
Tutorials: \sphinxurl{https://pytorch.org/tutorials/}

Docs: \sphinxurl{https://pytorch.org/docs/master/index.html}


\section{Standford University Lectures}
\label{\detokenize{link/index:standford-university-lectures}}
CS229: \sphinxurl{http://cs229.stanford.edu/syllabus.html}

CS231: \sphinxurl{http://cs231n.github.io/}


\section{ShareLatex}
\label{\detokenize{link/index:sharelatex}}
\sphinxurl{https://www.sharelatex.com/login}


\section{PlanetB}
\label{\detokenize{link/index:planetb}}
\sphinxurl{http://www.planetb.ca/syntax-highlight-word}


\section{Vision Open Source Library}
\label{\detokenize{link/index:vision-open-source-library}}
检索： \sphinxurl{http://yael.gforge.inria.fr/index.html}

特征： \sphinxurl{http://www.vlfeat.org/index.html}


\section{牛客网}
\label{\detokenize{link/index:id2}}
\sphinxurl{https://www.nowcoder.com/}


\chapter{实用软件}
\label{\detokenize{softwares/index::doc}}\label{\detokenize{softwares/index:id1}}

\section{Listary}
\label{\detokenize{softwares/index:listary}}
\begin{sphinxadmonition}{note}{Note:}
Windows下快速查找文件及应用程序
\end{sphinxadmonition}

\sphinxurl{http://www.listary.com/}


\section{FreeCommander}
\label{\detokenize{softwares/index:freecommander}}
\begin{sphinxadmonition}{note}{Note:}
Windows下的资源管理器
\end{sphinxadmonition}

\sphinxurl{https://freecommander.com/en/summary/}


\section{MobaXterm}
\label{\detokenize{softwares/index:mobaxterm}}
\begin{sphinxadmonition}{note}{Note:}
Windows下连接服务器的终端
\end{sphinxadmonition}

\sphinxurl{https://mobaxterm.mobatek.net/}


\section{TeamViewer}
\label{\detokenize{softwares/index:teamviewer}}
\begin{sphinxadmonition}{note}{Note:}
远程连接
\end{sphinxadmonition}

\sphinxurl{https://www.teamviewer.com/zhCN/}


\section{Notepad++}
\label{\detokenize{softwares/index:notepad}}
\begin{sphinxadmonition}{note}{Note:}
强大的文本阅读/编辑器
\end{sphinxadmonition}

\sphinxurl{https://notepad-plus-plus.org/}


\chapter{其他}
\label{\detokenize{else/index::doc}}\label{\detokenize{else/index:id1}}

\section{rst语法测试}
\label{\detokenize{else/01_test_code:rst}}\label{\detokenize{else/01_test_code::doc}}
\sphinxcode{\sphinxupquote{makefile}} 规则：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{target ... }\PYG{o}{:} \PYG{n}{prerequisites} ...
    \PYG{n+nb}{command}
    ...
    ...
\end{sphinxVerbatim}

下面是几个定义：
\begin{description}
\item[{target}] \leavevmode
可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对
于标签这种特性，在后续的“伪目标”章节中会有叙述。

\item[{prerequisites}] \leavevmode
生成该target所依赖的文件和/或target

\item[{command}] \leavevmode
该target要执行的命令（任意的shell命令）

\end{description}

这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，
其生成规则定义在command中。说白一点就是说:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。
\end{sphinxVerbatim}

这就是 \sphinxcode{\sphinxupquote{makefile}} 的规则，也就是 \sphinxcode{\sphinxupquote{makefile}} 中最核心的内容。

\sphinxcode{\sphinxupquote{echo "Hello World!";}}

行内公式使用 \sphinxcode{\sphinxupquote{math}} 这个 \sphinxcode{\sphinxupquote{role}}: \(a^2 + b^2 = c^2\).
\begin{equation*}
\begin{split}(a + b)^2  &=  (a + b)(a + b) \\
           &=  a^2 + 2ab + b^2\end{split}
\end{equation*}
\sphinxcode{\sphinxupquote{latex}} math测试:
\begin{equation*}
\begin{split}X_k =  \sum_{n=0}^{N-1} x_n e^{-{i 2\pi k \frac{n}{N}}} \qquad k = 0,\dots,N-1.\end{split}
\end{equation*}
将高亮语言设置为 \sphinxcode{\sphinxupquote{C}}

测试 \sphinxcode{\sphinxupquote{C}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{c} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}c}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

这里是 \sphinxcode{\sphinxupquote{C++}} :

\fvset{hllines={, 3, 4, 5,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{;}
  \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{j}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// 主函数注释}
\end{sphinxVerbatim}

斜体 \sphinxtitleref{text}

将高亮语言设置为 \sphinxcode{\sphinxupquote{python}}

测试 \sphinxcode{\sphinxupquote{python}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello world}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

这里是 \sphinxcode{\sphinxupquote{python}} (code):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Love Python, Love FreeDome}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E文标点,.0123456789,中文标点,. }\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

如果数据库有问题, 执行下面的 \sphinxcode{\sphinxupquote{SQL}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Dumping data for table {}`item\PYGZus{}table{}`}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{item\PYGZus{}table} \PYG{k}{VALUES} \PYG{p}{(}
\PYG{l+m+mi}{0000000001}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Manual\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}0.18.0\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}This is the manual for Mantis version 0.18.0.\PYGZbs{}r\PYGZbs{}n\PYGZbs{}r\PYGZbs{}nThe Mantis manual is modeled after the [url=http://www.php.net/manual/en/]PHP Manual[/url]. It is authored via the \PYGZbs{}\PYGZbs{}\PYGZdq{}manual\PYGZbs{}\PYGZbs{}\PYGZdq{} module in Mantis CVS.  You can always view/download the latest version of this manual from [url=http://mantisbt.sourceforge.net/manual/]here[/url].\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{20030811192655}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{python}}：

\fvset{hllines={, 2, 3,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} 测试注释}
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Love Python, Love FreeDome}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E文标点,.0123456789,中文标点,. }\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{javescipt}} 的 \sphinxcode{\sphinxupquote{rst}} 源码:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{o}{.}\PYG{o}{.} \PYG{n}{code}\PYG{o}{\PYGZhy{}}\PYG{n}{block}\PYG{p}{:}\PYG{p}{:} \PYG{n}{javascript}
    \PYG{p}{:}\PYG{n}{linenos}\PYG{p}{:}

    \PYG{n}{function} \PYG{n}{whatever}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{such color}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{bash}} :

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} home
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}PATH}
\PYG{n+nb}{source} \PYGZti{}/.bashrc
ls \PYGZhy{}l
mkdir filefolder
\PYG{n+nb}{cd} ..
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{python}} (code-block):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{jump\PYGZus{}from\PYGZus{}i}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}
        \PYG{n}{max\PYGZus{}step} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i} \PYG{o}{+} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{max\PYGZus{}step}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{jump\PYGZus{}from\PYGZus{}i}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{return} \PYG{n+nb+bp}{True}
        \PYG{k}{return} \PYG{n+nb+bp}{False}
    \PYG{k}{def} \PYG{n+nf}{canJump}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        https://leetcode.com/problems/jump\PYGZhy{}game/}
\PYG{l+s+sd}{        Each element in the array represents your maximum jump length at that position.}

\PYG{l+s+sd}{        Input: [2,3,1,1,4]}
\PYG{l+s+sd}{        Output: true}
\PYG{l+s+sd}{        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.}

\PYG{l+s+sd}{        :type nums: List[int]}
\PYG{l+s+sd}{        :rtype: bool}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{n}{nums} \PYG{o}{==} \PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{False}
        \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{jump\PYGZus{}from\PYGZus{}i}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{else/01_test_code:id1}}\begin{enumerate}
\item {} 
reStructuredText(rst)快速入门语法说明

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/1885d5570b37}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
RST 语法

\end{enumerate}
\begin{quote}

\sphinxurl{https://3vshej.cn/rstSyntax/rstSyntax.html}
\end{quote}


\section{面试笔试}
\label{\detokenize{else/02_interview::doc}}\label{\detokenize{else/02_interview:id1}}

\subsection{汇总}
\label{\detokenize{else/02_interview:id2}}\begin{enumerate}
\item {} 
github

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxurl{https://github.com/imhuay/Algorithm\_Interview\_Notes-Chinese}

\item {} 
\sphinxurl{https://github.com/jwasham/coding-interview-university/blob/master/translations/README-cn.md}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
2018校招算法岗面试题汇总

\end{enumerate}
\begin{quote}

\sphinxurl{https://zhuanlan.zhihu.com/p/36801851}
\end{quote}


\subsection{编程算法}
\label{\detokenize{else/02_interview:id3}}\begin{enumerate}
\item {} 
动态规划

\end{enumerate}
\begin{itemize}
\item {} 
有面值1,5,10,20,50,100的人民币，求问10000有多少种组成方法？
\begin{quote}

\sphinxurl{https://www.zhihu.com/question/315108379}
\end{quote}

\item {} 
如何用最少的次数测出鸡蛋会在哪一层摔碎？
\begin{quote}

\sphinxurl{https://www.zhihu.com/question/19690210}
\end{quote}

\item {} 
{[}LeetCode{]} Maximum Product Subarray 求连续子数组的最大乘积
\begin{quote}

\sphinxurl{https://blog.csdn.net/xblog\_/article/details/72872263}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
排序算法之桶排序

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/developer1024/article/details/79770240}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
找出数组中N个出现1（或奇数次）次的数字

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/e1331664c8cf}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
均匀分布生成其他分布的方法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/haolexiao/article/details/60511164}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
海量数据处理

\end{enumerate}
\begin{itemize}
\item {} 
面试题集锦
\begin{quote}

\sphinxurl{https://blog.csdn.net/v\_july\_v/article/details/6685962}
\end{quote}

\item {} 
大文件中返回频数最高的100个词
\begin{quote}

\sphinxurl{https://blog.csdn.net/tiankong\_/article/details/77240283}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
链表

\end{enumerate}
\begin{itemize}
\item {} 
求有环单链表中的环长、环起点、链表长
\begin{quote}

\sphinxurl{https://www.cnblogs.com/xudong-bupt/p/3667729.html}
\end{quote}

\item {} 
判断两个链表是否相交并找出交点
\begin{quote}

\sphinxurl{https://blog.csdn.net/jiary5201314/article/details/50990349}
\end{quote}

\item {} 
单链表O(1)时间删除给定节点
\begin{quote}

\sphinxurl{https://blog.csdn.net/qq\_35546040/article/details/80341136}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
全排列的非递归和递归实现(含重复元素)

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/so\_geili/article/details/71078945}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{7}
\item {} 
排列组合 “n个球放入m个盒子”问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qwb492859377/article/details/50654627?tdsourcetag=s\_pctim\_aiomsg}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{8}
\item {} 
Next Permutation 下一个排列

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/grandyang/p/4428207.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{9}
\item {} 
LeetCode 75. Sort Colors（三颜色排序\(\rightarrow\)K颜色排序）

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/princexiexiaofeng/article/details/79645511}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{10}
\item {} 
找到数组第k大的数（\sphinxurl{https://leetcode.com/problems/kth-largest-element-in-an-array/}）

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{partition}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{pivot} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{r} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{l}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{j} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{n}{pivot}\PYG{p}{)} \PYG{n}{l}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{r}\PYG{o}{\PYGZgt{}}\PYG{n}{i} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{n}{pivot}\PYG{p}{)} \PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{l}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{r}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
            \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{l}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{int} \PYG{n}{quicksort}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{p} \PYG{o}{=} \PYG{n}{partition}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{=}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)} \PYG{k}{return} \PYG{n}{p}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{)} \PYG{k}{return} \PYG{n}{quicksort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{k} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else} \PYG{k}{return} \PYG{n+nf}{quicksort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{p}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{int} \PYG{n}{findKthLargest}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{k\PYGZus{}id} \PYG{o}{=} \PYG{n}{quicksort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k\PYGZus{}id}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{11}
\item {} 
{[}LeetCode{]} Best Time to Buy and Sell Stock 买卖股票的最佳时间

\end{enumerate}
\begin{itemize}
\item {} 
最多一次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4280131.html}
\end{quote}

\item {} 
无限次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4280803.html}
\end{quote}

\item {} 
最多两次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4281975.html}
\end{quote}

\item {} 
最多k次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4295761.html}

\sphinxurl{https://blog.csdn.net/linhuanmars/article/details/23236995}
\end{quote}

\item {} 
交易冷却
\begin{quote}

\sphinxurl{https://www.cnblogs.com/grandyang/p/4997417.html}
\end{quote}

\end{itemize}


\subsection{c++}
\label{\detokenize{else/02_interview:c}}\begin{enumerate}
\item {} 
虚函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/fighting\_coder/article/details/77187151}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
重载、重写（覆盖）和隐藏的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zx3517288/article/details/48976097}
\end{quote}


\subsection{python}
\label{\detokenize{else/02_interview:python}}\begin{enumerate}
\item {} 
基本数据类型

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/littlefivebolg/p/8982889.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Python中的None

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/changbaishan/p/8084863.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
使用lambda高效操作列表的教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/mxp-neu/articles/5316557.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
经典7大Python面试题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qq\_41597912/article/details/81459804}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
迭代器和生成器

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/chongdongxiaoyu/p/9054847.html}
\end{quote}


\subsection{机器学习（深度学习）}
\label{\detokenize{else/02_interview:id4}}\begin{enumerate}
\item {} 
激活函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/deepLearning/02\_activationFunction.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Batch Normalization

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/deepLearning/03\_batchnorm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
过拟合

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/deepLearning/03\_batchnorm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
正则化项L1和L2的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/lyr2015/p/8718104.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
KMeans秘籍之如何确定K值

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/alicelmx/article/details/80991870}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
决策树

\end{enumerate}
\begin{itemize}
\item {} 
ID3、C4.5
\begin{quote}

\sphinxurl{https://www.cnblogs.com/coder2012/p/4508602.html}
\end{quote}

\item {} 
预剪枝与后剪枝
\begin{quote}

\sphinxurl{https://blog.csdn.net/zfan520/article/details/82454814}
\end{quote}

\item {} 
CART分类与回归树
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/b90a9ce05b28}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
Logistic Regression

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/machineLearning/01\_lr.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{7}
\item {} 
Support Vector Machine

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/machineLearning/02\_svm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{8}
\item {} 
PCA

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/machineLearning/03\_pca.html}
\end{quote}


\subsection{论文相关}
\label{\detokenize{else/02_interview:id5}}\begin{enumerate}
\item {} 
AlexNet/VGG/GoogleNet

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/gdymind/article/details/83042729}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
CNN卷积神经网络\_ GoogLeNet 之 Inception(V1-V4)

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/haiyang21/p/7243200.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
R-CNN系列

\end{enumerate}
\begin{itemize}
\item {} 
【RCNN系列】【超详细解析】
\begin{quote}

\sphinxurl{https://blog.csdn.net/amor\_tila/article/details/78809791}
\end{quote}

\item {} 
实例分割模型Mask R-CNN详解：从R-CNN，Fast R-CNN，Faster R-CNN再到Mask R-CNN
\begin{quote}

\sphinxurl{https://blog.csdn.net/jiongnima/article/details/79094159}
\end{quote}

\item {} 
RCNN（三）：Fast R-CNN
\begin{quote}

\sphinxurl{https://blog.csdn.net/u011587569/article/details/52151871}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
CapsuleNet解读

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/u013010889/article/details/78722140/}
\end{quote}


\subsection{其他}
\label{\detokenize{else/02_interview:id6}}\begin{enumerate}
\item {} 
理解数据库的事务，ACID，CAP和一致性

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/2c30d1fe5c4e}
\end{quote}



\renewcommand{\indexname}{Index}
\printindex
\end{document}