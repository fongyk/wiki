

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>22. 并查集 &mdash; fong alpha documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'alpha',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="23. 前缀函数与 KMP 算法" href="23_kmp.html" />
    <link rel="prev" title="21. 随机数" href="21_rand.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> fong
          

          
            
            <img src="../_static/logo.jpg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                alpha
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../cpp/index.html">C/C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/index.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux/index.html">Linux/Shell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git</a></li>
<li class="toctree-l1"><a class="reference internal" href="../machineLearning/index.html">机器学习</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deepLearning/index.html">深度学习</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">数理与算法</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01_complexity.html">1. 算法复杂度与主定理</a></li>
<li class="toctree-l2"><a class="reference internal" href="02_redblackTree.html">2. 红黑树</a></li>
<li class="toctree-l2"><a class="reference internal" href="03_shortestPath.html">3. 最短路径</a></li>
<li class="toctree-l2"><a class="reference internal" href="04_treeTraversal.html">4. 二叉树遍历</a></li>
<li class="toctree-l2"><a class="reference internal" href="05_game.html">5. 游戏与必胜策略</a></li>
<li class="toctree-l2"><a class="reference internal" href="06_randomSample.html">6. 蓄水池抽样</a></li>
<li class="toctree-l2"><a class="reference internal" href="07_sort.html">7. 排序算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="08_dynamicProgramming.html">8. 动态规划</a></li>
<li class="toctree-l2"><a class="reference internal" href="09_backtrack.html">9. 回溯</a></li>
<li class="toctree-l2"><a class="reference internal" href="10_topoSort.html">10. 拓扑排序</a></li>
<li class="toctree-l2"><a class="reference internal" href="11_catalan.html">11. 卡特兰数</a></li>
<li class="toctree-l2"><a class="reference internal" href="12_entropy.html">12. 信息熵</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_cltLLN.html">13. 大数定律和中心极限定理</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_coinWeigh.html">14. 称重问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="15_probability.html">15. 概率基础</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_geometry.html">16. 几何</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_graphCycle.html">17. 图环</a></li>
<li class="toctree-l2"><a class="reference internal" href="18_bTree.html">18. B 树</a></li>
<li class="toctree-l2"><a class="reference internal" href="19_ballBox.html">19. 球盒问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="20_poison.html">20. 喝水试毒</a></li>
<li class="toctree-l2"><a class="reference internal" href="21_rand.html">21. 随机数</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">22. 并查集</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">22.1. 简单版本</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">查询</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">合并</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id6">22.2. 路径压缩</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">22.3. 启发式合并</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">22.4. 复杂度</a></li>
<li class="toctree-l3"><a class="reference internal" href="#python">22.5. Python 参考代码</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kruskal">22.6. Kruskal 算法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">22.7. 参考资料</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="23_kmp.html">23. 前缀函数与 KMP 算法</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../computerNetwork/index.html">计算机网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../link/index.html">资源链接</a></li>
<li class="toctree-l1"><a class="reference internal" href="../softwares/index.html">实用软件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tech/index.html">Tech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../else/index.html">其他</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">fong</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">数理与算法</a> &raquo;</li>
        
      <li>22. 并查集</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/mathematicsAlgorithm/22_unionFind.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>22. 并查集<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>并查集是一种树形的数据结构，顾名思义，它用于处理一些不相交集合（Disjoint Set）的合并及查询问题。它支持两种操作：</p>
<ul class="simple">
<li>合并（Union）：把两个不相交的集合合并为一个集合。</li>
<li>查询（Find）：查询两个元素是否在同一个集合中。</li>
</ul>
<p>并查集不支持集合的分离，但是并查集在经过修改后可以支持集合中单个元素的删除操作。</p>
<p>并查集的重要思想在于，用集合中的一个元素（根节点）代表集合。</p>
<div class="section" id="id2">
<h2>22.1. 简单版本<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>初始化<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>假设有 <span class="math notranslate nohighlight">\(n\)</span> 个元素，用一个数组 parent[] 来存储每个元素的父节点；初始时，将它们的父节点设为自己。</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="id4">
<h3>查询<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>用递归的写法实现对 <strong>代表元素</strong> 的查询：层层向上访问父节点，直至根节点（根节点的标志就是：父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="id5">
<h3>合并<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>先找到两个集合的代表元素，然后将前者的父节点设为后者即可（当然也可以将后者的父节点设为前者）。</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">union</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">parent</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="id6">
<h2>22.2. 路径压缩<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>简单版本的并查集效率是比较低的，因为集合合并可能会导致树结构深度越来越深，想要从底部找到根节点代价会变得越来越大。</p>
<p>既然我们只关心一个元素对应的根节点，那我们希望每个元素到根节点的路径尽可能短（最好只需要一步）。只要我们在查询的过程中，把沿途的每个节点的父节点都设为根节点即可。这样一来，下次查询的效率就很高。</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="id7">
<h2>22.3. 启发式合并<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>合并可能会使树的深度（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后寻找根节点的路径也就会相应变长。虽然有路径压缩，但路径压缩也是会消耗时间的。</p>
<p>启发式合并方法：把简单的树往复杂的树上合并。因为这样合并后，到根节点距离变长的节点个数比较少。</p>
<p>用一个数组 rank[] 记录每个根节点对应的树的深度（非根节点的 rank 相当于以它为根节点的子树的深度）。初始时，把所有元素的 rank（秩）设为 1；合并时把 rank 较小的树往较大的树上合并。</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">union</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">ry</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">rank</span><span class="p">[</span><span class="n">ry</span><span class="p">])</span> <span class="n">parent</span><span class="p">[</span><span class="n">rx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ry</span><span class="p">;</span>
  <span class="k">else</span> <span class="n">parent</span><span class="p">[</span><span class="n">ry</span><span class="p">]</span> <span class="o">=</span> <span class="n">rx</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rx</span><span class="p">]</span> <span class="o">==</span> <span class="n">rank</span><span class="p">[</span><span class="n">ry</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">rx</span> <span class="o">!=</span> <span class="n">ry</span><span class="p">)</span> <span class="n">rank</span><span class="p">[</span><span class="n">ry</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 如果深度相同且根节点不同，则新的根节点的深度 +1</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>由于每一次查询都是对树的一次重构，会把叶节点以及其所有的祖先全部变成根节点的子节点，因此 rank 会失真，无法反应真实的树高。还有一种启发式合并方法是：把节点少的树往节点多的树上合并。</p>
</div>
<div class="section" id="id8">
<h2>22.4. 复杂度<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>简单来说，对于有 <span class="math notranslate nohighlight">\(n\)</span> 个元素的并查集，空间复杂度是 <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span> ；<span class="math notranslate nohighlight">\(m\)</span> 次合并、查询操作的摊还时间是 <span class="math notranslate nohighlight">\(\mathcal{O}(m \log^* n)\)</span>，其中 <span class="math notranslate nohighlight">\(\log^*\)</span> 是迭代对数（iterated logarithm）。</p>
</div>
<div class="section" id="python">
<h2>22.5. Python 参考代码<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h2>
<div class="toggle docutils container">
<div class="header docutils container">
<span class="math notranslate nohighlight">\(\color{darkgreen}{Code}\)</span></div>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A union-find disjoint set data structure.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># 2to3 sanity</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Third-party libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>


<span class="k">class</span> <span class="nc">UnionFind</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Union-find disjoint sets datastructure.</span>
<span class="sd">    Union-find is a data structure that maintains disjoint set</span>
<span class="sd">    (called connected components or components in short) membership,</span>
<span class="sd">    and makes it easier to merge (union) two components, and to find</span>
<span class="sd">    if two elements are connected (i.e., belong to the same</span>
<span class="sd">    component).</span>
<span class="sd">    This implements the &quot;weighted-quick-union-with-path-compression&quot;</span>
<span class="sd">    union-find algorithm.  Only works if elements are immutable</span>
<span class="sd">    objects.</span>
<span class="sd">    Worst case for union and find: :math:`(N + M \log^* N)`, with</span>
<span class="sd">    :math:`N` elements and :math:`M` unions. The function</span>
<span class="sd">    :math:`\log^*` is the number of times needed to take :math:`\log`</span>
<span class="sd">    of a number until reaching 1. In practice, the amortized cost of</span>
<span class="sd">    each operation is nearly linear [1]_.</span>
<span class="sd">    Terms</span>
<span class="sd">    -----</span>
<span class="sd">    Component</span>
<span class="sd">        Elements belonging to the same disjoint set</span>
<span class="sd">    Connected</span>
<span class="sd">        Two elements are connected if they belong to the same component.</span>
<span class="sd">    Union</span>
<span class="sd">        The operation where two components are merged into one.</span>
<span class="sd">    Root</span>
<span class="sd">        An internal representative of a disjoint set.</span>
<span class="sd">    Find</span>
<span class="sd">        The operation to find the root of a disjoint set.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    elements : NoneType or container, optional, default: None</span>
<span class="sd">        The initial list of elements.</span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    n_elts : int</span>
<span class="sd">        Number of elements.</span>
<span class="sd">    n_comps : int</span>
<span class="sd">        Number of distjoint sets or components.</span>
<span class="sd">    Implements</span>
<span class="sd">    ----------</span>
<span class="sd">    __len__</span>
<span class="sd">        Calling ``len(uf)`` (where ``uf`` is an instance of ``UnionFind``)</span>
<span class="sd">        returns the number of elements.</span>
<span class="sd">    __contains__</span>
<span class="sd">        For ``uf`` an instance of ``UnionFind`` and ``x`` an immutable object,</span>
<span class="sd">        ``x in uf`` returns ``True`` if ``x`` is an element in ``uf``.</span>
<span class="sd">    __getitem__</span>
<span class="sd">        For ``uf`` an instance of ``UnionFind`` and ``i`` an integer,</span>
<span class="sd">        ``res = uf[i]`` returns the element stored in the ``i``-th index.</span>
<span class="sd">        If ``i`` is not a valid index an ``IndexError`` is raised.</span>
<span class="sd">    __setitem__</span>
<span class="sd">        For ``uf`` and instance of ``UnionFind``, ``i`` an integer and ``x``</span>
<span class="sd">        an immutable object, ``uf[i] = x`` changes the element stored at the</span>
<span class="sd">        ``i``-th index. If ``i`` is not a valid index an ``IndexError`` is</span>
<span class="sd">        raised.</span>
<span class="sd">    .. [1] http://algs4.cs.princeton.edu/lectures/</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_elts</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># current num of elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_comps</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the number of disjoint sets or components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># next available id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elts</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indx</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1">#  dict mapping elt -&gt; index in _elts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># parent: for the internal tree structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># size of the component - correct only for roots</span>

        <span class="k">if</span> <span class="n">elements</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>  <span class="p">(</span>
            <span class="s1">&#39;&lt;UnionFind:</span><span class="se">\n\t</span><span class="s1">elts={},</span><span class="se">\n\t</span><span class="s1">siz={},</span><span class="se">\n\t</span><span class="s1">par={},</span><span class="se">\n</span><span class="s1">n_elts={},n_comps={}&gt;&#39;</span>
            <span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_elts</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_comps</span><span class="p">,</span>
            <span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elts</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indx</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;index {} is out of bound&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;index {} is out of bound&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a single disjoint element.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : immutable object</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indx</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_elts</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_comps</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the root of the disjoint set containing the given element.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : immutable object</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The (index of the) root.</span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given element is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;{} is not an element&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indx</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">p</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">p</span><span class="p">]:</span>
            <span class="c1"># path compression</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">q</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the two given elements belong to the same component.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : immutable object</span>
<span class="sd">        y : immutable object</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if x and y are connected, false otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge the components of the two given elements into one.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : immutable object</span>
<span class="sd">        y : immutable object</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize if they are not already in the collection</span>
        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">elt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>

        <span class="n">xroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">yroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xroot</span> <span class="o">==</span> <span class="n">yroot</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">yroot</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span> <span class="o">=</span> <span class="n">yroot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">yroot</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">yroot</span><span class="p">]</span> <span class="o">=</span> <span class="n">xroot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">yroot</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_comps</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the connected component containing the given element.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : immutable object</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set</span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given element is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;{} is not an element&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">elts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">)</span>
        <span class="n">vfind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">)</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">vfind</span><span class="p">(</span><span class="n">elts</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">elts</span><span class="p">[</span><span class="n">roots</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of connected components.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list of sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">)</span>
        <span class="n">vfind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">)</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">vfind</span><span class="p">(</span><span class="n">elts</span><span class="p">)</span>
        <span class="n">distinct_roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">elts</span><span class="p">[</span><span class="n">roots</span> <span class="o">==</span> <span class="n">root</span><span class="p">])</span> <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">distinct_roots</span><span class="p">]</span>
        <span class="c1"># comps = []</span>
        <span class="c1"># for root in distinct_roots:</span>
        <span class="c1">#     mask = (roots == root)</span>
        <span class="c1">#     comp = set(elts[mask])</span>
        <span class="c1">#     comps.append(comp)</span>
        <span class="c1"># return comps</span>

    <span class="k">def</span> <span class="nf">component_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dict mapping elements to their components.</span>
<span class="sd">        The returned dict has the following semantics:</span>
<span class="sd">            `elt -&gt; component containing elt`</span>
<span class="sd">        If x, y belong to the same component, the comp(x) and comp(y)</span>
<span class="sd">        are the same objects (i.e., share the same reference). Changing</span>
<span class="sd">        comp(x) will reflect in comp(y).  This is done to reduce</span>
<span class="sd">        memory.</span>
<span class="sd">        But this behaviour should not be relied on.  There may be</span>
<span class="sd">        inconsitency arising from such assumptions or lack thereof.</span>
<span class="sd">        If you want to do any operation on these sets, use caution.</span>
<span class="sd">        For example, instead of</span>
<span class="sd">        ::</span>
<span class="sd">            s = uf.component_mapping()[item]</span>
<span class="sd">            s.add(stuff)</span>
<span class="sd">            # This will have side effect in other sets</span>
<span class="sd">        do</span>
<span class="sd">        ::</span>
<span class="sd">            s = set(uf.component_mapping()[item]) # or</span>
<span class="sd">            s = uf.component_mapping()[item].copy()</span>
<span class="sd">            s.add(stuff)</span>
<span class="sd">        or</span>
<span class="sd">        ::</span>
<span class="sd">            s = uf.component_mapping()[item]</span>
<span class="sd">            s = s | {stuff}  # Now s is different</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dict with the semantics: `elt -&gt; component contianing elt`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">)</span>
        <span class="n">vfind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">)</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">vfind</span><span class="p">(</span><span class="n">elts</span><span class="p">)</span>
        <span class="n">distinct_roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">distinct_roots</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">roots</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">elts</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">comps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">comp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">})</span>
            <span class="c1"># Change ^this^, if you want a different behaviour:</span>
            <span class="c1"># If you don&#39;t want to share the same set to different keys:</span>
            <span class="c1"># comps.update({x: set(comp) for x in comp})</span>
        <span class="k">return</span> <span class="n">comps</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="kruskal">
<h2>22.6. Kruskal 算法<a class="headerlink" href="#kruskal" title="Permalink to this headline">¶</a></h2>
<p>最小生成树算法中的 Kruskal 算法是基于并查集实现的。首先，将边集合放入优先队列，权重越小的边越靠近队首（小顶堆）；然后，边依次出队，如果边的两个顶点位于两个集合，则将它们合并，边权重累加；当合并两个集合之后得到的新集合已经包括了所有的顶点，表示已经得到一棵最小生成树。</p>
<div class="toggle docutils container">
<div class="header docutils container">
<span class="math notranslate nohighlight">\(\color{darkgreen}{Code}\)</span></div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// NC159 最小生成树</span>
<span class="c1">// https://www.nowcoder.com/practice/735a34ff4672498b95660f43b7fcd628?tpId=117&amp;&amp;tqId=37869&amp;rp=1&amp;ru=/ta/job-code-high&amp;qru=/ta/job-code-high/question-ranking</span>

<span class="k">struct</span> <span class="n">comparator</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 小顶堆</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Solution</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="cm">/**</span>
<span class="cm">    * 返回最小的花费代价使得这 n 户人家连接起来</span>
<span class="cm">    * @param n int n户人家的村庄</span>
<span class="cm">    * @param cost intvector&lt;vector&lt;&gt;&gt; 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价</span>
<span class="cm">    * @return int</span>
<span class="cm">    */</span>
    <span class="kt">int</span> <span class="n">miniSpanningTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">cost</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// write code here</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parents</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">iota</span><span class="p">(</span><span class="n">parents</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">parents</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">comparator</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">edge</span><span class="p">:</span> <span class="n">cost</span><span class="p">)</span> <span class="n">edges</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">edges</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">edges</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="kt">bool</span> <span class="n">u</span> <span class="o">=</span> <span class="n">union_</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="n">c</span> <span class="o">+=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 已经得到最小生成树</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">find_</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">parents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
            <span class="k">return</span> <span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">union_</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">parents</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">find_</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">find_</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">capacity</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">capacity</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="n">capacity</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">capacity</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
                <span class="n">capacity</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">capacity</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="id9">
<h2>22.7. 参考资料<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>算法学习笔记(1) : 并查集</li>
</ol>
<blockquote>
<div><a class="reference external" href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></div></blockquote>
<ol class="arabic simple" start="2">
<li>并查集</li>
</ol>
<blockquote>
<div><a class="reference external" href="https://oi-wiki.org/ds/dsu/">https://oi-wiki.org/ds/dsu/</a></div></blockquote>
<ol class="arabic simple" start="3">
<li>并查集入门</li>
</ol>
<blockquote>
<div><a class="reference external" href="https://segmentfault.com/a/1190000004023326">https://segmentfault.com/a/1190000004023326</a></div></blockquote>
<ol class="arabic simple" start="4">
<li>github</li>
</ol>
<blockquote>
<div><p><a class="reference external" href="https://github.com/deehzee/unionfind/blob/master/unionfind.py">https://github.com/deehzee/unionfind/blob/master/unionfind.py</a></p>
<p><a class="reference external" href="https://github.com/wjakob/dset">https://github.com/wjakob/dset</a></p>
<p><a class="reference external" href="https://github.com/angusb/Union-Find">https://github.com/angusb/Union-Find</a></p>
</div></blockquote>
<ol class="arabic simple" start="5">
<li>Disjoint-set data structure</li>
</ol>
<blockquote>
<div><a class="reference external" href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a></div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="23_kmp.html" class="btn btn-neutral float-right" title="23. 前缀函数与 KMP 算法" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="21_rand.html" class="btn btn-neutral float-left" title="21. 随机数" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, fong

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
<script type="text/javascript">
    $(document).ready(function() {
     $(".toggle > *").hide();
     $(".toggle .header").show();
     $(".toggle .header").click(function() {
      $(this).parent().children().not(".header").toggle(400);
      $(this).parent().children(".header").toggleClass("open");
     })
    });
</script>


</body>
</html>