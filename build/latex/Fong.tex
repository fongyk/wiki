%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{目录}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}


	    % Use some font with UTF-8 support with XeLaTeX
        \usepackage[UTF8]{ctex}
        \usepackage{color}
        \usepackage{xcolor}
        \definecolor{darkgreen}{rgb}{0.0, 0.2, 0.13}
     

\title{Fong Documentation}
\date{May 12, 2019}
\release{alpha}
\author{fong}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{文中可能存在错误，欢迎 PR。}

\sphinxurl{https://github.com/fongyk}

\sphinxurl{https://github.com/fongyq}
\end{sphinxadmonition}


\chapter{C/C++}
\label{\detokenize{cpp/index:c-c}}\label{\detokenize{cpp/index::doc}}\label{\detokenize{cpp/index:id1}}

\section{main函数}
\label{\detokenize{cpp/01_main:main}}\label{\detokenize{cpp/01_main::doc}}

\subsection{返回值}
\label{\detokenize{cpp/01_main:id1}}
C++ main函数的返回值必须是 \sphinxcode{\sphinxupquote{int}} ，即整型类型。在大多数系统中，main 的返回值被用来指示状态，返回值 \sphinxcode{\sphinxupquote{0}} 表示执行成功，非0的返回值含义由系统定义，通常用来指出错误类型。

Windows系统下运行可执行文件(如launch.exe)可以直接忽略其扩展名 \sphinxcode{\sphinxupquote{.exe}} ：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{launch}
\end{sphinxVerbatim}

Unix系统下需要使用全文件名，包括扩展名：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
./a.out
\end{sphinxVerbatim}

访问main函数返回之后的方法依赖于系统。在Windows和Unix系统中，执行完一个程序之后，都可以通过 \sphinxcode{\sphinxupquote{echo}} 命令来获取返回值。

Windows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo} \PYGZpc{}ERRORLEVEL\PYGZpc{}
\end{sphinxVerbatim}

Unix:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}?}
\end{sphinxVerbatim}


\subsection{处理命令行选项}
\label{\detokenize{cpp/01_main:id2}}
main函数的形参列表有两种形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

第一种形参 \sphinxcode{\sphinxupquote{*argv{[}{]}}} 中，\sphinxcode{\sphinxupquote{argv}} 是一个数组，它的元素是指向C风格的字符串的指针；
第二种形参 \sphinxcode{\sphinxupquote{**argv}} 中，\sphinxcode{\sphinxupquote{argv}} 指向 \sphinxcode{\sphinxupquote{char*}} 。
参数 \sphinxcode{\sphinxupquote{argc}} 表示数组中字符串的数量。

当实参传给main函数之后，\sphinxcode{\sphinxupquote{argv}} 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。
例如，执行：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{launch} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{ofile} \PYG{n}{data}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{launch}} 是可执行文件。那么， \sphinxcode{\sphinxupquote{argc=5}} ，\sphinxcode{\sphinxupquote{argv}} 包含如下的C风格字符串：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{launch}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}o}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ofile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
当使用 \sphinxcode{\sphinxupquote{argv}} 中的实参时，实参是从 \sphinxcode{\sphinxupquote{argv{[}1{]}}} 开始的； \sphinxcode{\sphinxupquote{argv{[}0{]}}} 保存的是程序名，而非用户输入。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/01_main:id3}}
《C++ Primer 第5版 中文版》 Page 2, Page 197。


\section{数组}
\label{\detokenize{cpp/02_array::doc}}\label{\detokenize{cpp/02_array:id1}}

\subsection{指针}
\label{\detokenize{cpp/02_array:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}ctime\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{TreeNode}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{val}\PYG{p}{;}
  \PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{left}\PYG{p}{;}
  \PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{right}\PYG{p}{;}
  \PYG{n}{TreeNode}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)} \PYG{o}{:}\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{left}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{,} \PYG{n}{right}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}} \PYG{c+cm}{/* 唯一的构造函数，必须给的参数x */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{c+c1}{//int* p = new int(1); /* 这两行与下面三行等效 */}
  \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} *p \PYGZlt{}\PYGZlt{} endl;}
  \PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{;}
  \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}                \PYG{c+cm}{/* p已经申请了内存空间，可以直接赋值 */}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{p} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{q} \PYG{o}{=} \PYG{k}{new} \PYG{n}{TreeNode}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{q}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{n}{TreeNode} \PYG{n}{node}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{r} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{node}\PYG{p}{;}   \PYG{c+cm}{/* r 不能delete */}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{k}{delete} \PYG{n}{p}\PYG{p}{;}
  \PYG{k}{delete} \PYG{n}{q}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
两个指针变量的值相同，则这两个指针 \sphinxstylestrong{指向同一内存单元地址} 或都为 \sphinxstylestrong{空指针} 。不存在多个变量占用同一内存单元的情形。
\end{sphinxadmonition}


\subsection{指向函数的指针}
\label{\detokenize{cpp/02_array:id3}}
定义形式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{函数返回值类型} \PYG{p}{(}\PYG{o}{*}\PYG{n}{指针变量名}\PYG{p}{)}\PYG{p}{(}\PYG{n}{参数列表}\PYG{p}{)}
\end{sphinxVerbatim}

指向函数的指针是让函数的入口地址赋给指针变量，类似于指向数组的指针是把数组首地址赋给指针变量。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{double} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{n}{x} \PYG{o}{*} \PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{double} \PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{p} \PYG{o}{=} \PYG{n}{square}\PYG{p}{;} \PYG{c+c1}{// 用函数名square初始化指针}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{square}\PYG{p}{(}\PYG{l+m+mf}{1.6}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{(}\PYG{l+m+mf}{1.6}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.6}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 三者等效}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

还可以定义指针数组，

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 定义一个指向函数的指针类型，名为 MenuFood。函数参数列表为空，返回值为空。}
\PYG{k}{typedef} \PYG{n+nf}{void} \PYG{p}{(}\PYG{o}{*} \PYG{n}{MenuFood}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{food1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{food2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{food3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{food4}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{MenuFood} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{food1}\PYG{p}{,} \PYG{n}{food2}\PYG{p}{,} \PYG{n}{food3}\PYG{p}{,} \PYG{n}{food4}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// 该数组的每一个元素都是指向函数的指针。}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
指针数组：\sphinxcode{\sphinxupquote{类型 *数组名{[}长度{]}}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{char} \PYG{o}{*}\PYG{n}{name}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{allen}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{martin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{clark}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

指向行向量的指针变量：\sphinxcode{\sphinxupquote{类型 (*变量名){[}长度{]}}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
int (*pa)[10];
int *p;
int a[3][10];

p = a[0]; // 或 \PYGZam{}a[0][0]
pa = a; // 使用：*(*(pa + i) + j)
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{动态数组}
\label{\detokenize{cpp/02_array:id4}}
声明与定义一个动态数组的格式一般如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{da} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{da}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

內存释放：

\fvset{hllines={, 4, 7,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{da}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 释放指针指向的内存空间}
    \PYG{n}{da}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;} \PYG{c+c1}{// 置为空指针，防止出现‘野指针’}
\PYG{p}{\PYGZcb{}}
\PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{da}\PYG{p}{;}
\PYG{n}{da} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\end{sphinxVerbatim}

内存组织形式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
动态数组在堆(heap)区分配内存，静态数组在栈(stack)区分配內存。
\end{sphinxVerbatim}

假如我们已经得到一个3x4的动态数组da，其指针关系如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_dynamicArray}.png}\hspace*{\fill}}

其中，da{[}0{]}、da{[}1{]}、da{[}2{]}的 \sphinxstylestrong{地址} 是连续的，依次相差 \sphinxcode{\sphinxupquote{sizeof(da{[}0{]})}} (一个指针的大小，32位编译器下为4，64位编译器下为8)，比如:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZam{}}\PYG{n}{da}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{da}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{o}{\PYGZam{}}\PYG{n}{da}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

如果把da看作3行4列的二维数组，那么da的每一行元素的地址是连续的，依次相差 \sphinxcode{\sphinxupquote{sizeof(da{[}0{]}{[}0{]})}} ；但是行与行之间的地址是不连续的，比如:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
da[0][0], da[0][1], da[0][2], da[0][3]地址连续；
da[1][0], da[1][1], da[1][2], da[1][3]地址连续；
da[0][3]与da[1][0]地址不连续；
\end{sphinxVerbatim}

另外:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZam{}da, \PYGZam{}da[0], \PYGZam{}da[0][0]三者的数值是不相等的。
如果数组是静态数组，则\PYGZam{}da, \PYGZam{}da[0], \PYGZam{}da[0][0]三者的数值是相等的；
且静态数组的行与行之间的地址连续。
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
对于动态数组，指针的地址和指针的值不能混淆，我们讲da{[}0{]}、da{[}1{]}、da{[}2{]}的地址是连续的，但是他们本身的值没有关系，即 \sphinxcode{\sphinxupquote{da{[}0{]} + sizeof(da{[}0{]}) != da{[}1{]}}} 。
注意有没有 \sphinxcode{\sphinxupquote{\&}} 的区别。
\end{sphinxadmonition}

如果想要定义连续内存空间的动态数组，可以按如下方式进行：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// int** f; // f的声明}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{Init2DArray}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*}\PYG{o}{*} \PYG{o}{\PYGZam{}}\PYG{n}{f}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{row}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{col}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{f} \PYG{o}{=} \PYG{k}{new} \PYG{n}{T}\PYG{o}{*}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{k}{new} \PYG{n}{T}\PYG{p}{[}\PYG{n}{row} \PYG{o}{*} \PYG{n}{col}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{col}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{f}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{col} \PYG{o}{*} \PYG{n}{i}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

内存释放方式如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{Delete2DArray}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*}\PYG{o}{*} \PYG{o}{\PYGZam{}}\PYG{n}{f}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{f} \PYG{o}{!}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{f}\PYG{p}{;}
        \PYG{n}{f} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

上面的 \sphinxcode{\sphinxupquote{Init2DArray}} 在申请内存的时候，建立了row x col的二维动态数组。实际上，二维动态数组不强求列对齐，即各行的长度可以不一样，
因此可以下面像这样定义:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{offset\PYGZus{}i}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{offset\PYGZus{}i是第i行首地址相对于第0行首地址的偏移量}
\end{sphinxVerbatim}


\subsection{另类的数组表达}
\label{\detokenize{cpp/02_array:id5}}
有如下程序：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}

\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{l+m+mi}{9}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;}
\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\end{sphinxVerbatim}

这些表达式能够正常编译和执行，是因为对于C/C++而言:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{n}{等价于}\PYG{o}{*}\PYG{n}{a等价于}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{n}{等价于}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{+}\PYG{n}{a}\PYG{p}{)} \PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{等价于0}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

所以可以推出二维表达式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{[}\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
b: 相当于 \&b{[}0{]}，第0行的首地址。

*b: 相当于 b{[}0{]}，\&b{[}0{]}{[}0{]}，第0行第0列的首地址。

b{[}0{]}{[}1{]}等价于*(b{[}0{]} + 1)，*(*(b+0)+1)，(*(b+0)){[}1{]}（ {[}{]} 优先级高于 * ）。
\end{sphinxadmonition}


\subsection{数组实参}
\label{\detokenize{cpp/02_array:id6}}
以 \sphinxstylestrong{非引用} 类型传递数组实参时，数组会退化为指针，形参复制的是这个指针的值(指向数组的第一个元素)。通过指针形参做的任何改变，都是在修改数组元素本身。

如果以 \sphinxstylestrong{引用} 形式传递数组实参，那么编译器不会将数组实参转化为指针，而是传递数组的引用本身。

编译器会检查数组实参的大小与形参大小是否匹配。

非引用形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 函数可能会改变数组}
\PYG{k+kt}{void} \PYG{n+nf}{func2}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 不能改变数组}

\PYG{k+kt}{void} \PYG{n+nf}{func3}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}\PYG{c+c1}{// 4}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// int arr[100];}
\PYG{c+c1}{// func3(arr); // 调用func3}
\end{sphinxVerbatim}

引用形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func4}\PYG{p}{(}\PYG{k+kt}{int} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}\PYG{c+c1}{// 100}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// int arr[100];}
\PYG{c+c1}{// func4(arr); // 调用func4}
\end{sphinxVerbatim}


\subsection{数组地址与加法}
\label{\detokenize{cpp/02_array:id7}}
假设我们已经定义了一个数组：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Type} \PYG{n}{a}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]}\PYG{p}{[}\PYG{n}{M}\PYG{p}{]}\PYG{p}{[}\PYG{n}{N}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{1}. \sphinxcode{\sphinxupquote{a}} , \sphinxcode{\sphinxupquote{a{[}0{]}}} , \sphinxcode{\sphinxupquote{a{[}0{]}{[}0{]}}} , \sphinxcode{\sphinxupquote{\&a}} , \sphinxcode{\sphinxupquote{\&a{[}0{]}}} , \sphinxcode{\sphinxupquote{\&a{[}0{]}{[}0{]}}} , \sphinxcode{\sphinxupquote{\&a{[}0{]}{[}0{]}{[}0{]}}} 的数值都是一样的。

\sphinxstylestrong{2}. \sphinxcode{\sphinxupquote{\&a}} 是4级指针, 类型是 \sphinxcode{\sphinxupquote{int (*){[}L{]}{[}M{]}{[}N{]}}} ，指向a这个数组。

\sphinxstylestrong{3}. \sphinxcode{\sphinxupquote{a}} 是3级指针，类型是 \sphinxcode{\sphinxupquote{int (*){[}M{]}{[}N{]}}} ，三维数组的数组名，是数组a的首地址。

\sphinxstylestrong{4}. 大小计算如下:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sizeof(\PYGZam{}a) = 4;// 指针的大小，32位编译器
sizeof(a[0][0][0]) = sizeof(Type);
sizeof(a[0][0]) = N * sizeof(Type);
sizeof(a[0]) = M * N * sizeof(Type);
sizeof(a) = L * M * N * sizeof(Type);// 整个数组的大小
\end{sphinxVerbatim}

\sphinxstylestrong{5}. 加法运算:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
a + i = a + i * sizeof(a[0]);
\PYGZam{}a + i = a + i * sizeof(a);
这里（\PYGZam{}a + 1）就已经跳过了整个数组。
\end{sphinxVerbatim}

\sphinxstylestrong{6}. 定义指针 \sphinxcode{\sphinxupquote{int *ptr = (int *)(\&a + 1)}} ，则 \sphinxcode{\sphinxupquote{(ptr - 1)}} 指向数组a的最后一个元素。


\subsection{malloc/free与new/delete}
\label{\detokenize{cpp/02_array:malloc-freenew-delete}}

\subsubsection{相同点}
\label{\detokenize{cpp/02_array:id8}}
都可用于申请动态内存和释放内存。


\subsubsection{不同点}
\label{\detokenize{cpp/02_array:id9}}\begin{enumerate}
\item {} 
属性
\begin{quote}

\sphinxcode{\sphinxupquote{malloc/free}} 是C/C++的 \sphinxstylestrong{库函数} ，在头文件 \sphinxcode{\sphinxupquote{stdlib.h}} 中声明。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{o}{*}\PYG{n+nf}{malloc}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{size}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{free}\PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{pointer}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

因为malloc()函数的返回值类型为 \sphinxcode{\sphinxupquote{void*}} ，所以需要在函数前面进行相应的强制类型转换。

\sphinxcode{\sphinxupquote{new/delete}} 是C++的 \sphinxstylestrong{运算符} 。
\end{quote}

\item {} 
参数
\begin{quote}

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
int *pi=new int[n]; //指针pi指向长度为n的数组，未初始化
\end{sphinxVerbatim}

而malloc则需要显式地指出所需内存的尺寸。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{o}{*}\PYG{n}{p}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{int} \PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{n}{sizeof}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/}\PYG{n}{指向整型的指针p指向一个25个int整型空间的地址}
\PYG{n+nb}{int} \PYG{o}{*}\PYG{n}{p}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{int} \PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{l+m+mi}{99}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/}\PYG{n}{指向整型的指针p指向一个大小为99字节的内存的地址}
\end{sphinxVerbatim}

malloc可以分配任意字节，new 只能分配实例所占内存的整数倍数大小。
\end{quote}

\item {} 
分配失败
\begin{quote}

new内存分配失败时，会抛出 \sphinxcode{\sphinxupquote{bad\_alloc}} 异常；malloc分配内存失败时返回 \sphinxcode{\sphinxupquote{NULL}} 。
\end{quote}

\item {} 
功能
\begin{quote}

new做两件事，先分配内存，再调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。

对于内部数据类型(如 \sphinxcode{\sphinxupquote{int}} , \sphinxcode{\sphinxupquote{char}} 等)的对象，没有构造和析构的过程，对它们而言， \sphinxcode{\sphinxupquote{malloc/free}} 和 \sphinxcode{\sphinxupquote{new/delete}} 等价。

对于非内部数据类型的对象而言， \sphinxcode{\sphinxupquote{malloc/free}} 无法满足动态对象的要求。
\end{quote}

\item {} 
重载(overload)
\begin{quote}

\sphinxcode{\sphinxupquote{new/delete}} 可以重载成为函数，可以自定义申请过程，比如记录申请内存的长度以及跟踪每个对象的指针。

\sphinxcode{\sphinxupquote{malloc/free}} 不能重载。
\end{quote}

\end{enumerate}

\begin{sphinxadmonition}{warning}{Warning:}\begin{itemize}
\item {} 
new和delete一定要配对使用。

\item {} 
对空指针使用delete是安全的。

\item {} 
不能使用delete释放绑定到对象的指针。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{val} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n+nb}{int}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{val}\PYG{p}{;}
\PYG{n}{delete} \PYG{n}{p}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{error}\PYG{p}{,} \PYG{n}{memory} \PYG{o+ow}{not} \PYG{n}{allocated} \PYG{n}{by} \PYG{n}{new}
\end{sphinxVerbatim}

\end{itemize}
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/02_array:id10}}\begin{enumerate}
\item {} 
静态数组与动态数组：

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/liupeng900605/article/details/7526753}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
浅谈new/delete和malloc/free的用法与区别：

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/maluning/p/7944231.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
malloc/free与new/delete的区别：

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/hackbuteer1/article/details/6789164}
\end{quote}


\section{数据类型}
\label{\detokenize{cpp/03_typeSize::doc}}\label{\detokenize{cpp/03_typeSize:id1}}

\subsection{常用内置数据类型的大小}
\label{\detokenize{cpp/03_typeSize:id2}}
以下结果若非特别指出，均在Windows系统下由编译器Visual Studio测试得到。


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{类型大小}\label{\detokenize{cpp/03_typeSize:id4}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
类型
&\sphinxstyletheadfamily 
size/32位编译器
&\sphinxstyletheadfamily 
size/64位编译器
\\
\hline
char
&
1
&
1
\\
\hline
char*
&
4
&
8
\\
\hline
int
&
4
&
4
\\
\hline
int*
&
4
&
8
\\
\hline
short
&
2
&
2
\\
\hline
long
&
4
&
4 (8/linux)
\\
\hline
long*
&
4
&
8
\\
\hline
long long
&
8
&
8
\\
\hline
float
&
4
&
4
\\
\hline
double
&
8
&
8
\\
\hline
size\_t
&
4
&
8
\\
\hline
size\_type
&
4
&
8
\\
\hline
bool
&
1
&
1
\\
\hline
string
&
28
&
40
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{sizeof与strlen}
\label{\detokenize{cpp/03_typeSize:sizeofstrlen}}\begin{enumerate}
\item {} 
sizeof
\begin{quote}

\sphinxcode{\sphinxupquote{sizeof()}} 是 \sphinxstylestrong{运算符} ，计算的是分配的内存空间大小(单位为字节)，编译时就会计算，不受里面存储内容的影响。

\sphinxcode{\sphinxupquote{sizeof()}} 可以用数据类型、数组、字符串等做参数。
\end{quote}

\item {} 
strlen
\begin{quote}

\sphinxcode{\sphinxupquote{strlen()}} 是 \sphinxstylestrong{函数} ，计算的是字符串的实际长度(字符的个数)，以 \sphinxcode{\sphinxupquote{'\textbackslash{}0'}} 结束但长度 \sphinxstylestrong{不包括} \sphinxcode{\sphinxupquote{'\textbackslash{}0'}} ，程序执行时才计算结果。
\sphinxcode{\sphinxupquote{strlen()}} 只能用 \sphinxcode{\sphinxupquote{char*}} 类型做参数。
\end{quote}

\item {} 
实例
\begin{quote}

定义以下变量：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{strA} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdef}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strB}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdef}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strC}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strD}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strE}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strF}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

结果如下:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sizeof(strA) = 4 : 指针的大小
sizeof(strB) = 7 : 该字符数组用字符串初始化，因此strB就是一个字符串，字符串以\PYGZsq{}\PYGZbs{}0\PYGZsq{}结尾，则大小为6+1=7
sizeof(strC) = 5 : 字符数组所占内存为5字节
sizeof(strD) = 3 : 字符数组所占内存为3字节
sizeof(strE) = 3 : 字符数组中有3个字符
sizeof(strF) = 4 : 字符数组中有4个字符，包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
sizeof(y) = 12 : 4 * 3 = 12 字节

strlen(strA) = 6 : 字符串长度为6，不包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
strlen(strB) = 6 : 字符串长度为6，不包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
strlen(strC) = 1 : 字符数组中只有1个字符
strlen(strD)不定，因为数组strD末尾没有人为补\PYGZsq{}\PYGZbs{}0\PYGZsq{}，因此strD是一个普通的字符数组，而不是字符串
strlen(strE)不定，因为数组strE末尾没有人为补\PYGZsq{}\PYGZbs{}0\PYGZsq{}，因此strD是一个普通的字符数组，而不是字符串
strlen(strF) = 3 : 字符串长度为3，不包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
如果字符数组以字符常量进行初始化且字符个数大于1，如上例中的 \sphinxcode{\sphinxupquote{strD}} 和 \sphinxcode{\sphinxupquote{strE}} ，
如果不在末尾人为添加 \sphinxcode{\sphinxupquote{'\textbackslash{}0'}} ，则该字符数组不是字符串，
使用函数 \sphinxcode{\sphinxupquote{strlen}} 求得的大小不定，且该字符数组的内容也是未知的。
虽然 \sphinxcode{\sphinxupquote{strD}} 只有3个字节空间且刚好包含3个字符，但是 \sphinxcode{\sphinxupquote{cout\textless{}\textless{}strD}} 的结果也是不定的。
正确的定义应该是 \sphinxcode{\sphinxupquote{strF}} 。
\end{sphinxadmonition}
\end{quote}

\end{enumerate}


\subsection{float和double}
\label{\detokenize{cpp/03_typeSize:floatdouble}}
单精度浮点型 \sphinxstylestrong{float} 的精度为 \sphinxstylestrong{6 \textendash{} 7} 位有效数字，双精度浮点型 \sphinxstylestrong{double} 的精度为 \sphinxstylestrong{15 \textendash{} 16} 位有效数字。

\fvset{hllines={, 17, 18, 19, 20, 22,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{200000003} \PYG{o}{/} \PYG{l+m+mi}{100000002}\PYG{p}{;} \PYG{c+c1}{// 1.9999999900000003}

  \PYG{k+kt}{float} \PYG{n}{f\PYGZus{}i} \PYG{o}{=} \PYG{l+m+mi}{200000003} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{l+m+mi}{100000002}\PYG{p}{;} \PYG{c+c1}{// 浮点型常数默认为 const double，或用 200000003.0f 指定为 float。}
  \PYG{k+kt}{float} \PYG{n}{f\PYGZus{}f} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{l+m+mf}{200000003.0} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{l+m+mf}{100000002.0}\PYG{p}{;} \PYG{c+c1}{// 若不进行强制类型转换，会有 warning: truncation from \PYGZsq{}double\PYGZsq{} to \PYGZsq{}float\PYGZsq{}}
  \PYG{k+kt}{float} \PYG{n}{f\PYGZus{}d} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{l+m+mf}{200000003.0} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{l+m+mi}{100000002}\PYG{p}{;}\PYG{c+c1}{// warning: truncation from \PYGZsq{}double\PYGZsq{} to \PYGZsq{}float\PYGZsq{}}
  \PYG{k+kt}{double} \PYG{n}{d\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mi}{200000003} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{l+m+mi}{100000002}\PYG{p}{;}

  \PYG{n}{cout}\PYG{p}{.}\PYG{n}{setf}\PYG{p}{(}\PYG{n}{ios}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fixed}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 浮点数定点输出}
  \PYG{n}{cout}\PYG{p}{.}\PYG{n}{setf}\PYG{p}{(}\PYG{n}{ios}\PYG{o}{:}\PYG{o}{:}\PYG{n}{showpoint}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 显示小数位}
  \PYG{n}{cout}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 固定为10位精度（四舍五入）}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 1}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f\PYGZus{}i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f\PYGZus{}i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 2.0000000000 2}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f\PYGZus{}f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f\PYGZus{}f}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 2.0000000000 2}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f\PYGZus{}d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f\PYGZus{}d}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 2.0000000000 2}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d\PYGZus{}d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{d\PYGZus{}d}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 1.9999999900 1}
  \PYG{n}{cout}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d\PYGZus{}d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{d\PYGZus{}d}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 2.00 1}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{boolalpha}\PYG{p}{;} \PYG{c+c1}{// 设置布尔型输出格式}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f\PYGZus{}f}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// false}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f\PYGZus{}d}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// false}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{d\PYGZus{}d}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// true （只有double转换到int的结果与 i 一致）}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{cpp/03_typeSize:id3}}\begin{enumerate}
\item {} 
数据类型的数值范围

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qianbitou000/article/details/51939055/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
关于strlen与sizeof的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zhengqijun\_/article/details/51815081}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++ 中的 cout.setf() 函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/baishuiniyaonulia/article/details/79144033}
\end{quote}


\section{类的大小}
\label{\detokenize{cpp/04_classSize::doc}}\label{\detokenize{cpp/04_classSize:id1}}
计算类的大小遵循以下原则：
\begin{itemize}
\item {} 
内存对齐。

\item {} 
类的大小与普通数据成员有关，与成员函数、静态成员无关。即普通成员函数、静态成员函数、静态数据成员均对类的大小无影响。

\item {} 
虚函数对类的大小的影响体现在 \sphinxstylestrong{虚函数表指针} 的大小。

\item {} 
虚继承对类的大小的影响体现在 \sphinxstylestrong{虚基类表指针} 的大小。

\end{itemize}

以下结果均是在32位 Visual Studio 2013 下编译得到。


\subsection{空类}
\label{\detokenize{cpp/04_classSize:id2}}
C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。这是由于：
\begin{itemize}
\item {} 
new需要分配不同的内存地址，不能分配内存大小为0的空间 。

\item {} 
避免除以sizeof(*)时得到除以0错误

\end{itemize}

每个类在内存中都有唯一的标识，因此空类被实例化时，编译器会隐含地为其添加一个字节，以作区分。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Empty}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Empty) = 1}
\end{sphinxVerbatim}


\subsection{普通数据成员}
\label{\detokenize{cpp/04_classSize:id3}}
遵循内存对齐原则。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(A) = 4 + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{B}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(B) = 8 + 8 = 16}
\end{sphinxVerbatim}


\subsection{普通继承}
\label{\detokenize{cpp/04_classSize:id4}}
普通类的继承，派生类的大小=派生类数据成员大小+基类数据成员大小。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{B}\PYG{o}{:} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{ch}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{b}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(B) = 8 + 8 = 16 (对齐： 4+1 \PYGZhy{}\PYGZgt{} 8)}

\PYG{k}{class} \PYG{n+nc}{C}\PYG{o}{:} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{c}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{ch}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(C) = 8 + 8 + 8 = 24 (对齐： 4 \PYGZhy{}\PYGZgt{} 8, 1 \PYGZhy{}\PYGZgt{} 8)}
\end{sphinxVerbatim}


\subsubsection{继承空类}
\label{\detokenize{cpp/04_classSize:id5}}
派生类继承空类后，派生类如果有自己的数据成员，而空基类的一个字节并不会加到派生类中去。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Empty}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{A}\PYG{o}{:} \PYG{k}{public} \PYG{n}{Empty}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(A) = 4}
\end{sphinxVerbatim}


\subsubsection{类包含空类对象数据成员}
\label{\detokenize{cpp/04_classSize:id6}}
空类的1字节是会被计算进去的。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Empty}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Empty} \PYG{n}{e}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(A) = 4 + 4 = 8}
\end{sphinxVerbatim}


\subsection{虚函数与继承}
\label{\detokenize{cpp/04_classSize:id7}}
虚函数（Virtual Function）是通过一张 \sphinxstylestrong{虚函数表（Virtual Table, vtable）} 来实现的。
每当 \sphinxstylestrong{创建一个包含有虚函数的类} 或 \sphinxstylestrong{从包含有虚函数的类派生一个类} 时，编译器就会为这个类创建一个虚函数表保存该类 \sphinxstylestrong{所有虚函数} 的地址。

当一个类中包含虚函数时，会有一个指向其虚函数表的指针vptr，系统为类指针分配大小为4个字节(即使有多个虚函数)。
当构造该派生类对象时，其成员vptr被初始化指向该派生类的vtable。
所以可以认为vtable是该类的所有对象共有的，在定义该类时被初始化；而vptr则是每个类对象都有独立一份的，且在该类对象被构造时被初始化。


\subsubsection{单继承}
\label{\detokenize{cpp/04_classSize:id8}}
派生类的大小 = 派生类的普通数据成员的大小 + 1个vptr指针的大小

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Base}
\PYG{p}{\PYGZob{}}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Base) = 4}

\PYG{k}{class} \PYG{n+nc}{Derived}\PYG{o}{:} \PYG{k}{public} \PYG{n}{Base}
\PYG{p}{\PYGZob{}}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 覆盖了基类中的f1()， **多态**}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Derived) = 4 + 4 = 8}
\end{sphinxVerbatim}


\subsubsection{多继承}
\label{\detokenize{cpp/04_classSize:id9}}
每个基类都有自己的虚表(vtable)。

派生类的成员函数被放到了第一个基类的表中。

派生类的大小 = 派生类的普通数据成员的大小 + 基类的普通数据成员的大小 + \sphinxstylestrong{n} 个vptr指针的大小。 \sphinxstylestrong{n} 是继承的基类的个数。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(A) = 1}

\PYG{k}{class} \PYG{n+nc}{B}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{ch}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f0}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(B) = 4 + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{C}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{ch1}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{ch2}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(C) = 4 + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{D}\PYG{o}{:} \PYG{k}{public} \PYG{n}{A}\PYG{p}{,} \PYG{k}{public} \PYG{n}{C}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{d}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(D) = 4 + 4 + 1*4 = 12}

\PYG{k}{class} \PYG{n+nc}{E}\PYG{o}{:} \PYG{k}{public} \PYG{n}{B}\PYG{p}{,} \PYG{k}{public} \PYG{n}{C}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{e}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f0}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(E) = 4 + 4 + 4 + 2*4 = 20}
\end{sphinxVerbatim}


\subsection{虚继承}
\label{\detokenize{cpp/04_classSize:id10}}
尽管派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接
继承某个基类，然后通过另一个基类再一次间接继承该类。

在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现多次，则派生类中将包含该类的多个子对象。这会导致两个问题：第一，
浪费存储空间；第二，存在二义性。

虚继承可以解决上述问题。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{04_virtualInheritance}.png}\hspace*{\fill}}

虚继承的目的是令某个类做出声明，承诺共享它的基类。其中，共享的基类子对象称为 \sphinxstylestrong{虚基类} (上图中的类 \sphinxstylestrong{A} )。
在这种机制下，不论虚基类在继承体系中
出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。

虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现。
每个虚继承的子类都有一个 \sphinxstylestrong{虚基类指针(Virtual Base Table Pointer，vbptr，占用一个指针的存储空间)} 和虚基类表( \sphinxstylestrong{不占用} 类对象的存储空间)
(需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了)。

实际上，vbptr指向了一个 \sphinxstylestrong{虚基类表(Virtual Table)} ，虚基类表中记录了虚基类与本类的偏移地址。
通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类(虚基类)的两份同样的拷贝，节省了存储空间。

当虚继承的子类被当做父类继承时，虚基类指针也会被继承。上图中，C继承了B1，B2，也就继承了2个虚基类指针。

总体需要考虑：数据成员的大小、虚基类指针的大小 、虚函数指针的大小。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A} \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(A) = 4}

\PYG{k}{class} \PYG{n+nc}{B} \PYG{o}{:}\PYG{k}{virtual} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
      \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{myfunB}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(B) = 16}

\PYG{k}{class} \PYG{n+nc}{C} \PYG{o}{:}\PYG{k}{virtual} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{double} \PYG{n}{c}\PYG{p}{;}
      \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{myfunC}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(C) = 28}

\PYG{k}{class} \PYG{n+nc}{D} \PYG{o}{:}\PYG{k}{public} \PYG{n}{B}\PYG{p}{,} \PYG{k}{public} \PYG{n}{C}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{d}\PYG{p}{;}
      \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{myfunD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(D) = 52}
\end{sphinxVerbatim}


\subsection{内存对齐}
\label{\detokenize{cpp/04_classSize:id11}}\begin{description}
\item[{内存对齐，是为了让内存存取更有效率而采用的一种编译阶段优化内存存取的手段。}] \leavevmode\begin{itemize}
\item {} 
内存对齐是指首地址对齐，而不是说每个变量大小对齐。

\item {} 
分配内存的顺序是按照声明的顺序。

\item {} 
每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，如果不是整数倍则空出内存，直到偏移量是整数倍为止。

\item {} 
结构体内存对齐要求结构体内每一个成员变量都是内存对齐的。

\item {} 
整个结构体的大小必须是结构体里面变量类型最大值的整数倍。

\item {} 
如果一个结构里有某些结构体成员，则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。比如，struct A里存有struct B，B里有char, int, double等类型的成员变量，那B应该从8的整数倍开始存储。

\end{itemize}

\item[{内存对齐的作用：}] \leavevmode\begin{itemize}
\item {} 
平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

\item {} 
性能原因：经过内存对齐后，CPU的内存访问速度大大提升。

\end{itemize}

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Data}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{d}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Data) = 1 + (3) + 4 + 1 + (3) = 12，括号内表示补齐的字节数。}

\PYG{k}{class} \PYG{n+nc}{Data}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{d}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Data) = 1 + 1 + (2) + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{BigData}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{char} \PYG{n}{array}\PYG{p}{[}\PYG{l+m+mi}{33}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BigData) = 33}

\PYG{k}{class} \PYG{n+nc}{Data}
\PYG{p}{\PYGZob{}}
      \PYG{n}{BigData} \PYG{n}{bd}\PYG{p}{;}
      \PYG{c+c1}{//int integer; // 不管有没有注释这一行，sizeof(Data)结果一样}
      \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{;} \PYG{c+c1}{// d的起始偏移量必须为8的倍数，且大于33，则其偏移量为40}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Data) = 48}
\end{sphinxVerbatim}


\subsection{位域}
\label{\detokenize{cpp/04_classSize:id12}}
C/C++中以一定区域内的位(bit)为单位来表示的数据成为位域，位域必须指明具体的数目。
位域的作用主要是节省内存资源，使数据结构更紧凑。
\begin{enumerate}
\item {} 
一个位域必须存储在同一个字节中，不能跨两个字节，故位域的长度不能大于一个字节的长度

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{BitField}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int}  \PYG{o}{:}\PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{//空位域，自动置0，此时占满 1 个int存储单元，即 4 字节}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位，从第二个字节存储单元开始存放}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{d}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{;}  \PYG{c+c1}{//占用5个二进制位，剩余的3个bit不够存储4个bit的数据，从下一个存储单元开始存放}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int}  \PYG{o}{:}\PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{//空位域，自动置0，此时占满 2 个int存储单元，即 8 字节}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{e}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位，从第三个int存储单元开始存放}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BitField) = 3 * 4 = 12}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
取地址操作符\&不能应用在位域字段上

\item {} 
位域字段不能是类的静态成员

\item {} 
位域字段在内存中的位置是按照从低位向高位的顺序放置的

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{BitField}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}  \PYG{c+c1}{//最低位;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}  \PYG{c+c1}{//最高位;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
位域的对齐

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{BFA}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BFA) = 1}

\PYG{k}{struct} \PYG{n}{BFB}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int}  \PYG{n+nl}{d}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BFA) = 1 + (3) + 4 = 8}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
一个例子

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{num}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{struct} \PYG{n}{num} \PYG{n}{n} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{.}\PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{.}\PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{.}\PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\(8 = (00001000)_2\) ， \(8\) 在计算机中的补码也是 \sphinxcode{\sphinxupquote{00001000}} ， \(a\) 用3位表示，取低位为 \sphinxcode{\sphinxupquote{000}} ( \sphinxcode{\sphinxupquote{00000000}} )，原码也是 \sphinxcode{\sphinxupquote{00000000}} ，则 \(a = 0\) 。

\item {} 
\(-6 = (10000110)_2\) ， \(-6\) 在计算机中的补码是 \sphinxcode{\sphinxupquote{11111010}} ， \(b\) 用2位表示，取低位为 \sphinxcode{\sphinxupquote{10}} ( \sphinxcode{\sphinxupquote{11111110}} )，原码是 \sphinxcode{\sphinxupquote{10000010}} ，则 \(b = -2\) 。

\item {} 
\(5 = (00000101)_2\) ， \(5\) 在计算机中的补码也是 \sphinxcode{\sphinxupquote{00000101}} ， \(c\) 用1位表示，取低位为 \sphinxcode{\sphinxupquote{1}} ( \sphinxcode{\sphinxupquote{11111111}} )，原码是 \sphinxcode{\sphinxupquote{10000001}} ，则 \(c = -1\) 。

\end{itemize}
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
C++标准库提供了一个 \sphinxstylestrong{bitset} 类模板，它可以辅助操纵位的集合。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/04_classSize:id13}}\begin{enumerate}
\item {} 
c++ 类大小问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/sz-leez/p/7119232.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
c++类的大小计算

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/fengxinlinux/article/details/72836199}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
虚继承

\end{enumerate}
\begin{quote}

《C++ Primer 第5版 中文版》 Page 717-718。
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
C++中虚继承的作用及底层实现原理

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/bxw1992/article/details/77726390}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
c++中的内存对齐

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/suntp/p/MemAlignment.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
C/C++ 内存对齐原则及作用

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/chy19911123/article/details/48894579}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
C/C++位域知识小结

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/pure/archive/2013/04/22/3034818.html}
\end{quote}


\section{交换函数swap}
\label{\detokenize{cpp/05_swap::doc}}\label{\detokenize{cpp/05_swap:swap}}
\sphinxstylestrong{1}. 库函数，包含在头文件 \sphinxcode{\sphinxupquote{\textless{}algorithm\textgreater{}}} 中。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{2}. 指针。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{T} \PYG{o}{*}\PYG{n}{x}\PYG{p}{,} \PYG{n}{T} \PYG{o}{*}\PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{T} \PYG{n}{tmp} \PYG{o}{=} \PYG{o}{*}\PYG{n}{x}\PYG{p}{;}
    \PYG{o}{*}\PYG{n}{x} \PYG{o}{=} \PYG{o}{*}\PYG{n}{y}\PYG{p}{;}
    \PYG{o}{*}\PYG{n}{y} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{3}. 引用。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{T} \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{4}. 异或。适用于整型/字符/枚举类型，浮点型不适用。 \sphinxcode{\sphinxupquote{swap(a, a)}} 会导致 \sphinxcode{\sphinxupquote{a=0}} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define swap(a, b) a\PYGZca{}=b\PYGZca{}=a\PYGZca{}=b;}
\end{sphinxVerbatim}

\sphinxstylestrong{4}. 赋值。受编译器影响，先执行 \sphinxcode{\sphinxupquote{a+b}} 还是先执行 \sphinxcode{\sphinxupquote{b=a}} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define swap(a, b) a=a+b\PYGZhy{}(b=a);}
\end{sphinxVerbatim}

\sphinxstylestrong{5}. 加减。无需申请额外空间。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{数组形参}
\label{\detokenize{cpp/06_arrayArg::doc}}\label{\detokenize{cpp/06_arrayArg:id1}}

\subsection{非引用}
\label{\detokenize{cpp/06_arrayArg:id2}}
当数组以 \sphinxstylestrong{非引用} 类型传递，数组会悄悄退化为指针，形参复制的是这个指针的值（指向数组第一个元素）。通过该形参做的任何改变都是在修改数组元素本身。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 指针的大小为4（32位编译器）}
    \PYG{c+cm}{/*}
\PYG{c+cm}{        function body}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{func2}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 指针的大小为4（32位编译器）}
    \PYG{c+cm}{/*}
\PYG{c+cm}{        function body}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{func2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{引用}
\label{\detokenize{cpp/06_arrayArg:id3}}
如果形参是数组的 \sphinxstylestrong{引用} ，编译器不会将数组实参转化为指针，而是传递数组的引用本身。编译器会检查数组实参的大小与形参是否匹配。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 大小为4*10=40（32位编译器）}
    \PYG{c+cm}{/*}
\PYG{c+cm}{        function body}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{func2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{指针与引用}
\label{\detokenize{cpp/07_pointerReference::doc}}\label{\detokenize{cpp/07_pointerReference:id1}}
\sphinxstylestrong{1}. \sphinxstylestrong{非常量} 指针可以被重新赋值，指向另一个对象；引用是对象的别名，必须初始化并总是指向（代表）最初绑定的那个对象。

\sphinxstylestrong{2}. 有 \sphinxcode{\sphinxupquote{null pointer}} ，没有 \sphinxcode{\sphinxupquote{null reference}} ，故使用前无需检查是非为空。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{rValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{pValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{p} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{3}. 例子。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{string} \PYG{n+nf}{s1}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nancy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{s2}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{candy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{rs} \PYG{o}{=} \PYG{n}{s1}\PYG{p}{;}
\PYG{n}{string}\PYG{o}{*} \PYG{n}{ps} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{s2}\PYG{p}{;}
\PYG{n}{rs} \PYG{o}{=} \PYG{n}{s2}\PYG{p}{;} \PYG{c+c1}{// rs仍指向s1，但是s1值变为\PYGZdq{}candy\PYGZdq{}。}
\PYG{n}{ps} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{s2}\PYG{p}{;} \PYG{c+c1}{// ps指向s2，s1无变化}
\end{sphinxVerbatim}


\section{重载，覆盖，隐藏}
\label{\detokenize{cpp/08_overload::doc}}\label{\detokenize{cpp/08_overload:id1}}

\subsection{重载}
\label{\detokenize{cpp/08_overload:id2}}
同一可访问区内被声明的几个具有不同参数列表（参数个数，参数类型，参数顺序）的同名函数。不关心函数返回类型。


\subsection{覆盖}
\label{\detokenize{cpp/08_overload:id3}}
基类中被重写的函数，用 \sphinxcode{\sphinxupquote{virtual}} 修饰。派生类重写的函数与被重写的函数保持同样的函数名、参数列表、返回类型。


\subsection{隐藏}
\label{\detokenize{cpp/08_overload:id4}}
派生类中的函数屏蔽了基类中的同名函数，不管参数列表是否相同。当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被覆盖。


\subsection{参考资料}
\label{\detokenize{cpp/08_overload:id5}}\begin{enumerate}
\item {} 
C++中重载、重写（覆盖）和隐藏的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zx3517288/article/details/48976097}
\end{quote}


\section{strcpy函数}
\label{\detokenize{cpp/09_strcpy:strcpy}}\label{\detokenize{cpp/09_strcpy::doc}}
函数定义：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{char}\PYG{o}{*} \PYG{n+nf}{strcpy}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{dst}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{src}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cp} \PYG{o}{=} \PYG{n}{dst}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(} \PYG{o}{*}\PYG{n}{cp}\PYG{o}{+}\PYG{o}{+} \PYG{o}{=} \PYG{o}{*}\PYG{n}{src}\PYG{o}{+}\PYG{o}{+} \PYG{p}{)}\PYG{p}{;}  \PYG{c+cm}{/* Copy src over dst */}
    \PYG{k}{return}\PYG{p}{(} \PYG{n}{dst} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{char} \PYG{n}{src}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{dst}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{copy} \PYG{o}{=} \PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{dst}\PYG{p}{,} \PYG{n}{src}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{形参src}
\label{\detokenize{cpp/09_strcpy:src}}
形参 \sphinxcode{\sphinxupquote{src}} 定义为  \sphinxcode{\sphinxupquote{const}} ，防止函数对其进行修改。


\subsection{额外指针cp}
\label{\detokenize{cpp/09_strcpy:cp}}
\sphinxcode{\sphinxupquote{cp++}} 导致复制结束时， \sphinxcode{\sphinxupquote{cp}} 指向的是 \sphinxcode{\sphinxupquote{dst}} 绑定的字符串的尾部，因此不能直接返回 \sphinxcode{\sphinxupquote{cp}} 。


\subsection{返回值}
\label{\detokenize{cpp/09_strcpy:id1}}
为了实现链式操作，将目的地址返回。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{length} \PYG{o}{=} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{strcpy}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello World}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{cpp/09_strcpy:id2}}\begin{enumerate}
\item {} 
标准的strcpy函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/elisha-blogs/p/4125799.html}
\end{quote}


\section{强制类型转换}
\label{\detokenize{cpp/10_cast::doc}}\label{\detokenize{cpp/10_cast:id1}}

\subsection{static\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:static-cast-type-expr}}
\sphinxstylestrong{1}. \sphinxcode{\sphinxupquote{static\_cast}} 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。

\sphinxstylestrong{2}. 用于基本数据类型之间的转换，如把 \sphinxcode{\sphinxupquote{int}} 转换成 \sphinxcode{\sphinxupquote{char}} ，把 \sphinxcode{\sphinxupquote{int}} 转换成 \sphinxcode{\sphinxupquote{enum}} 。这种转换的安全性需要开发者来维护。

\sphinxstylestrong{3}. C++ 的任何的隐式转换都是使用 \sphinxcode{\sphinxupquote{static\_cast}} 来实现。

\sphinxstylestrong{4}. 基类和子类之间转换：其中子类指针转换成父类指针是安全的；但父类指针转换成子类指针是不安全的。(基类和子类之间的动态类型转换建议用dynamic\_cast)

\sphinxstylestrong{5}. 把空指针转换成目标类型的空指针。

\sphinxstylestrong{6}. 把任何类型的表达式转换成void类型。


\subsection{dynamic\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:dynamic-cast-type-expr}}
有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)：

\sphinxstylestrong{1}. 安全的基类和子类之间转换。

\sphinxstylestrong{2}. 必须要有虚函数。

\sphinxstylestrong{3}. 相同基类不同子类之间的交叉转换。但结果是NULL。


\subsection{const\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:const-cast-type-expr}}
\sphinxstylestrong{1}. 去掉类型的const、volitale属性;

\sphinxstylestrong{2}. 常量指针被转化成非常量的指针，并且仍然指向原来的对象；

\sphinxstylestrong{3}. 常量引用被转换成非常量的引用，并且仍然指向原来的对象；

\sphinxstylestrong{4}. const\_cast一般用于修改指针。如const char *p形式。


\subsection{reinterpret\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:reinterpret-cast-type-expr}}
\sphinxstylestrong{1}. reinterpret\_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差。

\sphinxstylestrong{2}. reinterpret\_cast可以将整型转换为指针，也可以把指针转换为数组。

\sphinxstylestrong{3}. reinterpret\_cast可以在指针和引用里进行肆无忌惮的转换。


\subsection{参考资料}
\label{\detokenize{cpp/10_cast:id2}}\begin{enumerate}
\item {} 
C++中四种强制类型转换区别详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/cauchy007/p/4968707.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
c++ 四种强制类型转换介绍

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/ydar95/article/details/69822540}
\end{quote}


\section{堆、栈}
\label{\detokenize{cpp/11_heapStack::doc}}\label{\detokenize{cpp/11_heapStack:id1}}
堆（Heap）与栈（Stack）有两层含义：
（1）程序内存布局场景下，堆与栈表示的是两种内存管理方式；
（2）数据结构场景下，堆与栈表示两种常用的数据结构。

栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。

堆由程序员分配释放， 若程序员不释放，程序结束时由系统回收。


\subsection{管理方式}
\label{\detokenize{cpp/11_heapStack:id2}}
栈由操作系统自动分配释放，无需我们手动控制；

堆的申请和释放工作由程序员控制，容易产生内存泄漏。


\subsection{空间大小}
\label{\detokenize{cpp/11_heapStack:id3}}
每个进程拥有的栈的大小要远远小于堆的大小。
理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小64bits的Windows默认1MB，64bits的Linux默认10MB；


\subsection{分配方式}
\label{\detokenize{cpp/11_heapStack:id4}}
堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。

动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。


\subsection{生长方式}
\label{\detokenize{cpp/11_heapStack:id5}}
堆的生长方向向上，内存地址由低到高。

栈的生长方向向下，内存地址由高到低。


\subsection{分配效率}
\label{\detokenize{cpp/11_heapStack:id6}}
栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。

堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。


\subsection{存放内容}
\label{\detokenize{cpp/11_heapStack:id7}}
栈存放函数返回地址、相关参数、局部变量和寄存器内容等。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。


\subsection{附：内存分区}
\label{\detokenize{cpp/11_heapStack:id8}}
在C++中，内存主要分为堆、栈、全局/静态存储区和常量存储区。
\begin{itemize}
\item {} 
\sphinxstylestrong{栈} ：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。

\item {} 
\sphinxstylestrong{堆} ：就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

\item {} 
\sphinxstylestrong{全局/静态存储区} ：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

\item {} 
\sphinxstylestrong{常量存储区} ：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{cpp/11_heapStack:id9}}\begin{enumerate}
\item {} 
堆与栈的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/K346K346/article/details/80849966}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C/C++——堆栈的讲解

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/lovejay7/article/details/80662390}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++ 自由存储区是否等价于堆？

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/QG-whz/p/5060894.html}
\end{quote}


\section{参数传递}
\label{\detokenize{cpp/12_argPass::doc}}\label{\detokenize{cpp/12_argPass:id1}}
当形参是引用类型时，称对应实参被 \sphinxstylestrong{引用传递} （passed by reference）或者函数被 \sphinxstylestrong{传引用调用} （called by reference）。

当实参的值被 \sphinxstylestrong{拷贝} 给形参时，形参和实参时两个相互独立的对象。这样的实参被 \sphinxstylestrong{值传递} （passed by value)或者函数被 \sphinxstylestrong{传值调用} （called by value）。


\subsection{传值参数}
\label{\detokenize{cpp/12_argPass:id2}}
当初始化一个非引用类型的变量时，初始化被拷贝给变量。此时，对变量的改动 \sphinxstylestrong{不会} 影响初始值。
\begin{description}
\item[{\sphinxstylestrong{指针形参}}] \leavevmode
指针的行为和其他 \sphinxstylestrong{非引用} 类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后， \sphinxstylestrong{两个指针是不同的指针} 。因为指针
使我们可以间接地访问它所指的对象，所以通过指针 \sphinxstylestrong{可以修改它所指的对象的值} 。

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{reset}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针p所指对象的值}
   \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 只改变了p的局部拷贝，实参未被改变}
\PYG{p}{\PYGZcb{}}

\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{x}\PYG{p}{,} \PYG{n}{T}\PYG{o}{*} \PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{T}\PYG{o}{*} \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  只交换了拷贝指针的值，实际指针并未改变，因此无法达到交换的目的。}
\end{sphinxVerbatim}

为了改变实参指针的值，可以使用指针的引用或者使用指向指针的指针。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{val} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{val}\PYG{p}{;}

\PYG{c+c1}{// 调用: reset(p)}
\PYG{k+kt}{void} \PYG{n+nf}{reset}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针p所指对象的值}
    \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针p的值}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// 调用: reset(\PYGZam{}p)}
\PYG{k+kt}{void} \PYG{n+nf}{reset}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{o}{*}\PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针*p所指对象的值}
    \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针*p的值}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{传引用参数}
\label{\detokenize{cpp/12_argPass:id3}}
通过使用引用形参，允许函数改变实参的值。

使用引用避免拷贝：拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（比如IO类型）根本不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过
引用形参访问该类型的对象。例如，需要比较两个string对象，而这样的对象可能会很长，为了避免拷贝且不改变对象的值，可以将形参声明为常量引用（const \&）。

使用引用形参返回额外信息：通过给函数传入一个额外的引用形参，让其保存需要的值，而不需要作为函数返回值返回（避免函数返回值太多）。


\subsection{参考资料}
\label{\detokenize{cpp/12_argPass:id4}}\begin{enumerate}
\item {} 
《C++ Primer 第5版 中文版》 Page 187 \textendash{} 190。

\end{enumerate}


\section{空类指针}
\label{\detokenize{cpp/13_nullClassPtr::doc}}\label{\detokenize{cpp/13_nullClassPtr:id1}}
类的成员函数并不与特定对象绑定，所有成员函数共用一份成员函数体，当程序编译后，成员函数的地址即已经确定。
那为什么同一个类的不同对象调用对应成员函数可以出现不同的结果呢？答案就是 \sphinxcode{\sphinxupquote{this}} 指针。
共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的 \sphinxcode{\sphinxupquote{this}} 指针，
成员函数中对成员变量的访问都是转化成 \sphinxstylestrong{“this-\textgreater{}数据成员”} 的方式。
因此，从这一角度说，成员函数与普通函数一样，只是多了一个隐式参数，即指向对象的 \sphinxcode{\sphinxupquote{this}} 指针。


\subsection{空类指针调用成员函数}
\label{\detokenize{cpp/13_nullClassPtr:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{TestNullPtr} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{void} \PYG{n}{print}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{print}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k+kt}{void} \PYG{n}{getA}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k+kt}{void} \PYG{n}{setA}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{a} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{virtual} \PYG{n}{test}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{k}{private}\PYG{o}{:}
  \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{TestNullPtr}\PYG{o}{*} \PYG{n}{ptr} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{print}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 运行成功}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getA}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 编译成功，运行失败}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setA}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 编译成功，运行失败}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 编译成功，运行失败}
\end{sphinxVerbatim}

上例中， \sphinxcode{\sphinxupquote{ptr-\textgreater{}getA()}} 和 \sphinxcode{\sphinxupquote{ptr-\textgreater{}setA()}} 都试图访问成员变量，然而 \sphinxcode{\sphinxupquote{this}} 指针为空，导致运行失败。
另外，虚函数的特性是动态绑定，运行时根据指针或引用绑定的对象是基类对象还是派生类对象调用相关函数，空指针显然会导致错误。


\subsection{参考资料}
\label{\detokenize{cpp/13_nullClassPtr:id3}}\begin{enumerate}
\item {} 
C++空指针调用成员函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/45cf10150e6b}
\end{quote}


\section{static和extern}
\label{\detokenize{cpp/14_staticExtern:staticextern}}\label{\detokenize{cpp/14_staticExtern::doc}}

\subsection{static: 静态全局变量}
\label{\detokenize{cpp/14_staticExtern:static}}
在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。
特点：
\begin{itemize}
\item {} 
该变量在 \sphinxstylestrong{全局数据区} 分配内存；

\item {} 
未经初始化的静态全局变量会被程序自动初始化为0；（自动变量的值是随机的，除非它被显式初始化）

\item {} 
静态全局变量在声明它的整个文件都是可见的，而在 \sphinxstylestrong{文件之外是不可见的} ，其它文件中可以定义相同名字的变量，不会发生冲突。

\end{itemize}


\subsection{static: 静态函数}
\label{\detokenize{cpp/14_staticExtern:id1}}
在函数的返回类型前加上static关键字，函数即被定义为静态函数。
静态函数与普通函数不同，它 \sphinxstylestrong{只能在声明它的文件当中可见} ，不能被其它文件使用。
其它文件中可以定义相同名字的函数，不会发生冲突。这点与静态全局变量相似。


\subsection{static: 静态局部变量}
\label{\detokenize{cpp/14_staticExtern:id2}}
在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。
特点：
\begin{itemize}
\item {} 
该变量在全局数据区分配内存；

\item {} 
静态局部变量在程序执行到该对象的声明处时被首次初始化，即 \sphinxstylestrong{以后的函数调用不再进行初始化} ；

\item {} 
静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；

\item {} 
它始终驻留在全局数据区，其生命周期一直持续到整个程序执行结束。但其作用域仍为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// 初次调用func()时才会执行初始化}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{a} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 1}
  \PYG{n}{func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 2}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{static: 静态成员变量}
\label{\detokenize{cpp/14_staticExtern:id3}}
在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。
特点：
\begin{itemize}
\item {} 
对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。在没有产生类的实例时，我们就可以操作它；

\item {} 
静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义；

\item {} 
静态数据成员和普通数据成员一样遵从public，protected，private访问规则；

\item {} 
（类定义体外部）静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
\sphinxcode{\sphinxupquote{＜数据类型＞ ＜类名＞::＜静态数据成员名＞ = ＜值＞}}

\item {} 
类的静态数据成员有两种访问形式：
\sphinxcode{\sphinxupquote{＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞}}

\end{itemize}


\subsection{static: 静态成员函数}
\label{\detokenize{cpp/14_staticExtern:id4}}
普通的成员函数一般都隐含了一个 \sphinxcode{\sphinxupquote{this}} 指针， \sphinxcode{\sphinxupquote{this}} 指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。
通常情况下， \sphinxcode{\sphinxupquote{this}} 是缺省的。如函数 \sphinxcode{\sphinxupquote{fn()}} 实际上是 \sphinxcode{\sphinxupquote{this-\textgreater{}fn()}} 。
但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它 \sphinxstylestrong{不具有this指针} 。
从这个意义上讲，它 \sphinxstylestrong{无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数} 。
非静态成员函数可以任意地访问静态成员函数和静态数据成员。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Myclass}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{,} \PYG{n}{b} \PYG{p}{,} \PYG{n}{c}\PYG{p}{;}
    \PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{sum}\PYG{p}{;}  \PYG{c+c1}{//声明静态数据成员}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Myclass}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{GetSum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{Myclass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}   \PYG{c+c1}{//定义并初始化静态数据成员}

\PYG{n}{Myclass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Myclass}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{c}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{a} \PYG{o}{=} \PYG{n}{a}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{c} \PYG{o}{=} \PYG{n}{c}\PYG{p}{;}
    \PYG{n}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{o}{+}\PYG{n}{c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n}{Myclass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetSum}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{sum}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{extern: 修饰函数、变量}
\label{\detokenize{cpp/14_staticExtern:extern}}
修饰符 \sphinxcode{\sphinxupquote{extern}} 用在变量或者函数的声明前，用来说明 \sphinxstylestrong{“此变量/函数是在别处定义的，要在此处引用”} 。
在别的文件中如果想调用 \sphinxcode{\sphinxupquote{file1.c}} 中的变量a，只须用 \sphinxcode{\sphinxupquote{extern}} 进行声明即可调用a:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{extern} \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{// file2.c}
\PYG{k}{extern} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}} \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{// file3.cpp}
\end{sphinxVerbatim}

在这里要注意 \sphinxcode{\sphinxupquote{extern}} 声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。
其实要调用其它文件中的函数和变量，只需把该文件用\#include包含进来即可，但是用 \sphinxcode{\sphinxupquote{extern}} 会加速程序的编译过程，这样能节省时间。


\subsection{extern “C” \{\}}
\label{\detokenize{cpp/14_staticExtern:extern-c}}

\subsubsection{例子}
\label{\detokenize{cpp/14_staticExtern:id5}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef HEADER\PYGZus{}INCLUDED }\PYG{c+c1}{// 条件编译，避免重复包含头文件}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define HEADER\PYGZus{}INCLUDED}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}cplusplus }\PYG{c+c1}{// extern \PYGZdq{}C\PYGZdq{} 只用在c++文件中}
\PYG{k}{extern} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}} \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* \PYGZus{}\PYGZus{}cplusplus */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}c.h\PYGZdq{}}

\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{strcpy}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/*.................................}
\PYG{c+cm}{ * do something else}
\PYG{c+cm}{ *.................................}
\PYG{c+cm}{ */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}cplusplus}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* \PYGZus{}\PYGZus{}cplusplus */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* HEADER\PYGZus{}INCLUDED */}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{extern "C"}} 中的 \sphinxcode{\sphinxupquote{C}} ，表示的一种编译和连接规约，表明它按照类C的编译和连接规约来编译和连接，而不是一种语言。
\sphinxcode{\sphinxupquote{C}} 表示 \sphinxstylestrong{符合C语言的编译和连接规约的任何语言} ，如Fortran、assembler等。
\sphinxcode{\sphinxupquote{extern "C"}} 的真实目的是实现 \sphinxstylestrong{类C} 和C++的混合编程。


\subsection{参考资料}
\label{\detokenize{cpp/14_staticExtern:id6}}\begin{enumerate}
\item {} 
C/C++中的static关键字详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/qintangtao/p/3285937.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++项目中的extern “C” \{\}

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
浅谈C/C++中的static和extern关键字

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/dolphin0520/archive/2011/04/20/2022701.html}
\end{quote}


\section{public、protected、private}
\label{\detokenize{cpp/15_classAccess::doc}}\label{\detokenize{cpp/15_classAccess:publicprotectedprivate}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{类成员访问权限（可访问： \(\checkmark\)）}\label{\detokenize{cpp/15_classAccess:id3}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
权限
&\sphinxstyletheadfamily 
类成员
&\sphinxstyletheadfamily 
类对象
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
友元函数
\\
\hline
public
&
\(\checkmark\)
&
\(\checkmark\)
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
private
&
\(\checkmark\)
&
\(\times\)
&
\(\times\)
&
\(\checkmark\)
\\
\hline
protected
&
\(\checkmark\)
&
\(\times\)
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{继承}
\label{\detokenize{cpp/15_classAccess:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{public继承下对基类成员的访问权限}\label{\detokenize{cpp/15_classAccess:id4}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
内部权限
&\sphinxstyletheadfamily 
权限变化(相对于派生类)
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
派生类对象
\\
\hline
public
&
-\textgreater{} public
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
private
&
-\textgreater{} private
&
\(\times\)
&
\(\times\)
\\
\hline
protected
&
-\textgreater{} protected
&
\(\checkmark\)
&
\(\times\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{private继承下对基类成员的访问权限}\label{\detokenize{cpp/15_classAccess:id5}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
内部权限
&\sphinxstyletheadfamily 
权限变化(相对于派生类)
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
派生类对象
\\
\hline
public
&
-\textgreater{} private
&
\(\checkmark\)
&
\(\times\)
\\
\hline
private
&
-\textgreater{} private
&
\(\times\)
&
\(\times\)
\\
\hline
protected
&
-\textgreater{} private
&
\(\checkmark\)
&
\(\times\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{protected继承下对基类成员的访问权限}\label{\detokenize{cpp/15_classAccess:id6}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
内部权限
&\sphinxstyletheadfamily 
权限变化(相对于派生类)
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
派生类对象
\\
\hline
public
&
-\textgreater{} protected
&
\(\checkmark\)
&
\(\times\)
\\
\hline
private
&
-\textgreater{} private
&
\(\times\)
&
\(\times\)
\\
\hline
protected
&
-\textgreater{} protected
&
\(\checkmark\)
&
\(\times\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{class与struct}
\label{\detokenize{cpp/15_classAccess:classstruct}}
class不写权限修饰符，成员默认是 \sphinxcode{\sphinxupquote{private}} ，而struct的成员默认是 \sphinxcode{\sphinxupquote{public}} 。

class的继承默认是 \sphinxcode{\sphinxupquote{private}} 的，而struct默认是 \sphinxcode{\sphinxupquote{public}} 的。


\subsection{参考资料}
\label{\detokenize{cpp/15_classAccess:id2}}\begin{enumerate}
\item {} 
C++中关于public、protect、private的访问权限控制

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/ycf74514/article/details/49053041}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++的关键字public,private和protected

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/943c0d2fe292}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++中public,protected,private访问

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/jiudianren/p/5668438.html}
\end{quote}


\section{类的static const成员}
\label{\detokenize{cpp/16_staticconst:static-const}}\label{\detokenize{cpp/16_staticconst::doc}}

\subsection{const}
\label{\detokenize{cpp/16_staticconst:const}}
const数据成员的初始化只能在类的构造函数的初始化列表中进行。声明const变量是不能初始化。

\begin{sphinxadmonition}{note}{Note:}
必须使用初始化列表的情形
\begin{itemize}
\item {} 
\sphinxstylestrong{常量成员} ，因为常量只能初始化不能赋值，所以必须放在初始化列表里面。

\item {} 
\sphinxstylestrong{引用类型} ，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面。

\item {} 
没有默认构造函数的 \sphinxstylestrong{类类型} ，因为使用初始化列表不调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
成员是按照他们在类中 \sphinxstylestrong{声明} 的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的。
\end{sphinxadmonition}


\subsection{static}
\label{\detokenize{cpp/16_staticconst:static}}
不能在定义对象时对变量进行 \sphinxstylestrong{定义和初始化} ，即不能用构造函数进行初始化。
初始化在类体外进行，前面不加static修饰符。

\begin{sphinxadmonition}{note}{Note:}
const全局变量和类static成员变量都可以在 \sphinxstylestrong{定义类的头文件} 中初始化。不会因为头文件重复包含而导致变量重复定义的编译错误。

但是在定义指针时要注意， \sphinxcode{\sphinxupquote{const char* p = "name"}} 定义的指针不是const，可能导致错误；而 \sphinxcode{\sphinxupquote{char* const p = "name"}} 不会。
\end{sphinxadmonition}


\subsection{static const}
\label{\detokenize{cpp/16_staticconst:id1}}
静态常量成员，可以直接初始化（static cosnt 和 const static 含义相同）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// header.h}
\PYG{k}{class} \PYG{n+nc}{Solution} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
      \PYG{k}{static} \PYG{k+kt}{void} \PYG{n}{print}\PYG{p}{(}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
              \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{var} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 100}
              \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{mapping}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// \PYGZsq{}a\PYGZsq{}}
      \PYG{p}{\PYGZcb{}}

\PYG{k}{private}\PYG{o}{:}
      \PYG{k}{static} \PYG{k}{const} \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{mapping}\PYG{p}{;} \PYG{c+c1}{// 常量声明式}
      \PYG{k}{static} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{var} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{c+c1}{// 常量声明式（直接初始化）}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// source.cpp}
\PYG{k}{const} \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{Solution}\PYG{o}{:}\PYG{o}{:} \PYG{n}{mapping} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{2}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                                    \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{3}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{d}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{e}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{f}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                                    \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{4}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{g}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{h}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{i}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// mapping 的定义}

\PYG{c+cm}{/* 注：const map只能通过迭代器 const\PYGZus{}iterator 访问元素（it\PYGZhy{}\PYGZgt{}first, it\PYGZhy{}\PYGZgt{}second）}
\PYG{c+cm}{ ，不能通过下标[]的方式访问。*/}

\PYG{c+c1}{// 对应类的 static const int/char/bool 成员常量，如果不取他们的地址，则可以直接声明并使用，而无需提供以下的定义式。}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{Solution}\PYG{o}{:}\PYG{o}{:} \PYG{n}{var}\PYG{p}{;} \PYG{c+c1}{// var 的定义。由于 常量var 在类内声明时已经获得了初始值，因此定义时不可以再设初始值。}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{初始化} ：变量还没有值，现在赋予它一个值。

\sphinxstylestrong{赋值} ：变量已经有一个值，现在擦除它之前的值，赋予一个新的值。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/16_staticconst:id2}}\begin{enumerate}
\item {} 
C++ static、const和static const类型成员变量声明以及初始化

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/hustfeiji/articles/5168529.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
头文件中定义 const 全局变量应注意的问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/mafuli007/article/details/8499585}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++ 初始化列表

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
C++的一大误区——深入解释直接初始化与复制初始化的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/ljianhui/article/details/9245661}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
C++构造函数初始化列表与赋值

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/sz-leez/p/7082865.html}

\sphinxurl{http://www.cnblogs.com/BlueTzar/articles/1223169.html}
\end{quote}


\section{枚举类型与共用体}
\label{\detokenize{cpp/17_enumUnion::doc}}\label{\detokenize{cpp/17_enumUnion:id1}}

\subsection{枚举类型}
\label{\detokenize{cpp/17_enumUnion:id2}}
枚举类型（enumeration）使我们可以将一组 \sphinxstylestrong{整型常量} 组织在一起。格式

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{enum} \PYG{o}{\PYGZlt{}}\PYG{n}{类型名}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZob{}}\PYG{o}{\PYGZlt{}}\PYG{n}{枚举成员}\PYG{o}{\PYGZgt{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

枚举成员不能是数值，即不能是类似于\{1,2,3\}。


\subsubsection{初始化}
\label{\detokenize{cpp/17_enumUnion:id3}}
默认情况下，每个枚举变量的值就是其序号，从0开始，依次加1。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n}{Week} \PYG{p}{\PYGZob{}}\PYG{n}{Sun}\PYG{p}{,} \PYG{n}{Mon}\PYG{p}{,} \PYG{n}{Tue}\PYG{p}{,} \PYG{n}{Wed}\PYG{p}{,} \PYG{n}{Thu}\PYG{p}{,} \PYG{n}{Fri}\PYG{p}{,} \PYG{n}{Sat}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{//Sun=0, Mon=1, Tue=2, Wed=3, Thu=4, Fri=5, Sat=6}
\end{sphinxVerbatim}

显式提供初始值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n}{Week} \PYG{p}{\PYGZob{}}\PYG{n}{Sun}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Mon}\PYG{p}{,} \PYG{n}{Tue}\PYG{p}{,} \PYG{n}{Wed}\PYG{p}{,} \PYG{n}{Thu}\PYG{p}{,} \PYG{n}{Fri}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{Sat}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{//Sun=1, Mon=2, Tue=3, Wed=4, Thu=5, Fri=100, Sat=101}
\end{sphinxVerbatim}


\subsubsection{枚举变量}
\label{\detokenize{cpp/17_enumUnion:id4}}
定义枚举类型之后，就可以定义该枚举类型的变量，或者与枚举类型同时定义。枚举变量的值只能取枚举常量表中所列的值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{enum} \PYG{n}{Week} \PYG{p}{\PYGZob{}}\PYG{n}{Sun}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Mon}\PYG{p}{,} \PYG{n}{Tue}\PYG{p}{,} \PYG{n}{Wed}\PYG{p}{,} \PYG{n}{Thu}\PYG{p}{,} \PYG{n}{Fri}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{Sat}\PYG{p}{\PYGZcb{}} \PYG{n}{day\PYGZus{}1}\PYG{p}{;}
\PYG{c+c1}{// 全局变量 day\PYGZus{}1 默认初始化为 0。}

\PYG{k+kt}{void} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{num}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{num} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{n}{Week} \PYG{n}{day}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{day}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Week} \PYG{n}{day\PYGZus{}2}\PYG{p}{,} \PYG{n}{day\PYGZus{}3}\PYG{p}{;}

  \PYG{n}{day\PYGZus{}1} \PYG{o}{=} \PYG{n}{Sun}\PYG{p}{;} \PYG{c+c1}{// 或者 day\PYGZus{}1 = Week::Sun （不限定作用域的枚举类型）}
  \PYG{n}{day\PYGZus{}2} \PYG{o}{=} \PYG{n}{day\PYGZus{}1}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{day\PYGZus{}1}\PYG{p}{;} \PYG{c+c1}{// i = 1}
  \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{Mon}\PYG{p}{;} \PYG{c+c1}{// j = 2}

  \PYG{n}{Week} \PYG{n}{day\PYGZus{}4}\PYG{p}{(}\PYG{n}{Week}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// day\PYGZus{}4 = Fri}
  \PYG{k+kt}{bool} \PYG{n}{equal} \PYG{o}{=} \PYG{p}{(}\PYG{n}{day\PYGZus{}4} \PYG{o}{=}\PYG{o}{=} \PYG{n}{Fri}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// true}

  \PYG{n}{Week} \PYG{n}{day\PYGZus{}5}\PYG{p}{(}\PYG{n}{Week}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 越界，但是不报错，day\PYGZus{}5 = \PYGZhy{}1 （VS 2013）}

  \PYG{n}{ff}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 匹配 ff(int)，输出 \PYGZhy{}10}
  \PYG{n}{ff}\PYG{p}{(}\PYG{n}{day\PYGZus{}1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 匹配 ff(Week)，输出 10}
  \PYG{n}{ff}\PYG{p}{(}\PYG{n}{Fri}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 匹配 ff(Week)，输出 1000}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{共用体}
\label{\detokenize{cpp/17_enumUnion:id5}}
共用体（union）及其变量的定义形式与结构体类似。共用体成员访问方式也是使用运算符 \sphinxcode{\sphinxupquote{.}} 或 \sphinxcode{\sphinxupquote{-\textgreater{}}}。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{union} \PYG{n}{ifcd}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
  \PYG{k+kt}{float} \PYG{n}{f}\PYG{p}{;}
  \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{o}{*}\PYG{n}{pu}\PYG{p}{;}
\PYG{c+c1}{// 同结构体一样，分号不能丢}
\end{sphinxVerbatim}

与结构体的异同：
\begin{itemize}
\item {} 
存储分配方式
\begin{itemize}
\item {} 
结构体每个成员各自占有自己的存储单元、各自的地址，结构体占有的内存空间大小是所有成员所占存储单元的总和。

\item {} 
共用体各个成员占用共同的存储单元，具有 \sphinxstylestrong{相同的首地址} ，占用存储单元最多的成员的长度就是共用体的长度。一个共用体
可以包含多个不同类型的成员，但是每一时刻只有 \sphinxstylestrong{一个成员有效} ，即最后一次存放的数据成员起作用。虽然仍然可以访问无效的成员，但是结果是未知的。
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x1}\PYG{p}{.}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{256}\PYG{p}{;}
\PYG{n}{x1}\PYG{p}{.}\PYG{n}{c} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{A}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{x1}\PYG{p}{.}\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.23}\PYG{p}{;}
\PYG{c+c1}{// 三步操作之后，只有 x1.f 有效。}
\end{sphinxVerbatim}
\end{quote}

\end{itemize}

\item {} 
初始化
\begin{itemize}
\item {} 
结构变量或数组可以为所有成员初始化。

\item {} 
共用体变量或数组在初始化时，只能对初始化它的 \sphinxstylestrong{第一个成员} ，对多个成员初始化是不允许的。
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{union} \PYG{n}{ifcd} \PYG{n}{x3} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{256}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{x4}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// 对成员 i 初始化}
\end{sphinxVerbatim}
\end{quote}

\end{itemize}

\item {} 
结构体和共用体可以相互出现在对方的类型定义中。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{cpp/17_enumUnion:id6}}
1.《C++ Primer 第5版 中文版》 Page 736 \textendash{} 739。
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++ 枚举类型详解

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.runoob.com/w3cnote/cpp-enum-intro.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++枚举（enum）的优雅用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/daizhiyan1/article/details/82428023}
\end{quote}


\section{常用函数}
\label{\detokenize{cpp/18_commonFunc::doc}}\label{\detokenize{cpp/18_commonFunc:id1}}

\subsection{lower\_bound，upper\_bound}
\label{\detokenize{cpp/18_commonFunc:lower-bound-upper-bound}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{lower\_bound} 从排好序的数组区间 \sphinxstylestrong{{[}first,last)} 中，采用二分查找，返回 \sphinxstylestrong{大于或等于} val的 \sphinxstylestrong{第一个} 元素位置。
如果所有元素都小于val，则返回last。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{ForwardIterator} \PYG{n}{lower\PYGZus{}bound} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{upper\_bound} 从排好序的数组区间 \sphinxstylestrong{{[}first,last)} 中，采用二分查找，返回 \sphinxstylestrong{大于} val的 \sphinxstylestrong{第一个} 元素位置。
如果所有元素都不大于val，则返回last。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{ForwardIterator} \PYG{n}{upper\PYGZus{}bound} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

求有序数组中val的个数：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{first}\PYG{p}{,} \PYG{n}{last}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{first}\PYG{p}{,} \PYG{n}{last}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 4}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 8}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 用 a 对 v 初始化}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 4}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 8}

  \PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{500}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{ai} \PYG{p}{:} \PYG{n}{a}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ai} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends}\PYG{p}{;} \PYG{c+c1}{// 1 2 3 4 500 5 5 5 6 7 8}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{500}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{vi} \PYG{p}{:} \PYG{n}{v}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends}\PYG{p}{;} \PYG{c+c1}{// 1 2 3 4 500 5 5 5 6 7 8}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{fill，fill\_n，for\_each}
\label{\detokenize{cpp/18_commonFunc:fill-fill-n-for-each}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{fill} 函数将一个区间 \sphinxstylestrong{{[}first,last)} 的每个元素都赋予val值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{fill} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{fill\_n} 函数从 \sphinxstylestrong{first} 开始依次赋予n个元素val值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{OutputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Size}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{fill\PYGZus{}n} \PYG{p}{(}\PYG{n}{OutputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{Size} \PYG{n}{n}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{for\_each} 把函数fn应用于区间 \sphinxstylestrong{{[}first,last)} 的每个元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Function}\PYG{o}{\PYGZgt{}}
\PYG{n}{Function} \PYG{n}{for\PYGZus{}each} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{Function} \PYG{n}{fn}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{print}\PYG{p}{(}\PYG{n}{T} \PYG{n}{elem}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{elem} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{k+kt}{float} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+m+mf}{0.0} \PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}0.0, 0.0, 0.0, 0.0\PYGZcb{}}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}0, 0, 0, 0\PYGZcb{}}

  \PYG{n}{fill}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mf}{3.3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}3.3, 3.3, 3.3, 3.3\PYGZcb{}}
  \PYG{n}{fill\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{6.6}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}6.6, 6.6, 3.3, 3.3\PYGZcb{}}
  \PYG{n}{fill\PYGZus{}n}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}9, 9, 9, 9\PYGZcb{}}

  \PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{print}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//  6.6 6.6 3.3 3.3}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{print}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//  9 9 9 9}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{fill}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// b 所有元素为 2}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

最长上升子序列：

\fvset{hllines={, 11, 12, 13,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/* https://leetcode.com/problems/longest\PYGZhy{}increasing\PYGZhy{}subsequence/ */}
\PYG{c+cm}{/* O(nlogn) in time.*/}

\PYG{k}{class} \PYG{n+nc}{Solution} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{lengthOfLIS}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{inf} \PYG{o}{=} \PYG{n}{INT\PYGZus{}MAX}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{len} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{dp} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{len}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{fill}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{inf}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{length} \PYG{o}{=} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{inf}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{dp}\PYG{p}{;}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{dp}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{length}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{sort}
\label{\detokenize{cpp/18_commonFunc:sort}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}

\PYG{c+c1}{// default}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{RandomAccessIterator}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{sort} \PYG{p}{(}\PYG{n}{RandomAccessIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{RandomAccessIterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{RandomAccessIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Compare}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{sort} \PYG{p}{(}\PYG{n}{RandomAccessIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{RandomAccessIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{Compare} \PYG{n}{comp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}functional\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{comparator}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{struct} \PYG{n}{myclass}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}} \PYG{n}{myobject}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{71}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{26}\PYG{p}{,} \PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{53}\PYG{p}{,} \PYG{l+m+mi}{33} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}               \PYG{c+c1}{// 32 71 12 45 26 80 53 33}

  \PYG{c+c1}{// using default comparison (operator \PYGZlt{}):}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}           \PYG{c+c1}{//(12 32 45 71)26 80 53 33}

  \PYG{c+c1}{// using comparator as comp}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{comparator}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 12 32 45 71(26 33 53 80)}

  \PYG{c+c1}{// using object as comp}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{myobject}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{//(12 26 32 33 45 53 71 80)}

  \PYG{c+c1}{// using build\PYGZhy{}in comp: greater}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{greater}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// (80 71 53 45 33 32 26 12)}

  \PYG{c+c1}{// using build\PYGZhy{}in comp: less}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{less}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//(12 26 32 33 45 53 71 80)}

  \PYG{c+c1}{// using reverse\PYGZus{}iterator}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{rbegin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{rend}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// (80 71 53 45 33 32 26 12)}

  \PYG{c+c1}{// sort array}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{greater}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// (80 71 53 45 33 32 26 12)}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}                 \PYG{c+c1}{// (12 26 32 33 45 53 71 80)，可使用 comparator、myobject、less\PYGZlt{}int\PYGZgt{}()}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxstylestrong{string} 类也是可以排序的，如

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n}{str}\PYG{p}{;}
\PYG{n}{sort}\PYG{p}{(}\PYG{n}{str}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{str}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{min\_element，max\_element，minmax\_element}
\label{\detokenize{cpp/18_commonFunc:min-element-max-element-minmax-element}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{min\_element} ：会返回指向输入序列的最小元素的迭代器；

\item {} 
\sphinxstylestrong{max\_element} ：会返回指向最大元素的迭代器；

\item {} 
\sphinxstylestrong{minmax\_element} ：会以 pair 对象的形式返回这两个迭代器。first 指向最小元素。second 指向最大元素。

\end{itemize}

\sphinxstylestrong{min\_element}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// default}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{o}{\PYGZgt{}}
\PYG{n}{ForwardIterator} \PYG{n}{min\PYGZus{}element} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Compare}\PYG{o}{\PYGZgt{}}
\PYG{n}{ForwardIterator} \PYG{n}{min\PYGZus{}element} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{Compare} \PYG{n}{comp}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// [first,last)}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 0}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{min\PYGZus{}element}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 0}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{max\PYGZus{}element}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 6}

  \PYG{k}{auto} \PYG{n}{p} \PYG{o}{=} \PYG{n}{minmax\PYGZus{}element}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 0 6}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{accumulate}
\label{\detokenize{cpp/18_commonFunc:accumulate}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}

\PYG{c+c1}{// sum}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{T} \PYG{n}{accumulate} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{T} \PYG{n}{init}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BinaryOperation}\PYG{o}{\PYGZgt{}}
\PYG{n}{T} \PYG{n}{accumulate} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{T} \PYG{n}{init}\PYG{p}{,} \PYG{n}{BinaryOperation} \PYG{n}{binary\PYGZus{}op}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

累加区间 \sphinxstylestrong{{[}first,last)} 的元素，并加上 \sphinxstylestrong{init} 。

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}     // std::cout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}functional\PYGZgt{}   // std::minus}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}      // std::accumulate}

\PYG{k+kt}{int} \PYG{n+nf}{myfunction} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{y}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k}{struct} \PYG{n}{myclass}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{y}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}} \PYG{n}{myobject}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{init} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numbers}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using default accumulate: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{numbers}\PYG{p}{,}\PYG{n}{numbers}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{init}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 + (10 + 20 + 30)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using functional\PYGZsq{}s minus: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{accumulate} \PYG{p}{(}\PYG{n}{numbers}\PYG{p}{,} \PYG{n}{numbers}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{init}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{minus}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 \PYGZhy{} (10 + 20 + 30)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using custom function: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{accumulate} \PYG{p}{(}\PYG{n}{numbers}\PYG{p}{,} \PYG{n}{numbers}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{init}\PYG{p}{,} \PYG{n}{myfunction}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 + 2 * (10 + 20 + 30)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using custom object: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{accumulate} \PYG{p}{(}\PYG{n}{numbers}\PYG{p}{,} \PYG{n}{numbers}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{init}\PYG{p}{,} \PYG{n}{myobject}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 + 3 * (10 + 20 + 30)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{partial\_sum}
\label{\detokenize{cpp/18_commonFunc:partial-sum}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}
\end{sphinxVerbatim}

累加，并把结果存到序列（数组、向量） \sphinxstylestrong{result} 中。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// sum}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{OutputIterator}\PYG{o}{\PYGZgt{}}
\PYG{n}{OutputIterator} \PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{OutputIterator} \PYG{n}{result}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{OutputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BinaryOperation}\PYG{o}{\PYGZgt{}}
\PYG{n}{OutputIterator} \PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,}
                            \PYG{n}{OutputIterator} \PYG{n}{result}\PYG{p}{,}
                            \PYG{n}{BinaryOperation} \PYG{n}{binary\PYGZus{}op}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// y0 = x0}
\PYG{c+c1}{// y1 = x0 + x1}
\PYG{c+c1}{// y2 = x0 + x1 + x2}
\PYG{c+c1}{// y3 = x0 + x1 + x2 + x3}
\PYG{c+c1}{// y4 = x0 + x1 + x2 + x3 + x4}
\PYG{c+c1}{// ... ... ...}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}     // std::cout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}functional\PYGZgt{}   // std::multiplies}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}      // std::partial\PYGZus{}sum}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{myop} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{val}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{result}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{val}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using default partial\PYGZus{}sum: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;} \PYG{c+c1}{// 1 3 6 10 15}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{result\PYGZus{}vec}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 0 0 0 0 0 0}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{val}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{result\PYGZus{}vec}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 1 3 6 10 15 0}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{val}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{result}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{multiplies}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 1 2 6 24 120}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using functional operation multiplies: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{val}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{result}\PYG{p}{,} \PYG{n}{myop}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 1 4 8 13 19}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using custom function: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{iota}
\label{\detokenize{cpp/18_commonFunc:iota}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{iota} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{T} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

采用递增的形式，将val开始的等差数列赋值给区间 {[}first,last) 的元素。

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}     // std::cout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}      // std::iota}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{float} \PYG{n}{numbers}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iota} \PYG{p}{(}\PYG{n}{numbers}\PYG{p}{,}\PYG{n}{numbers}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mf}{3.5}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{numbers:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{float}\PYG{o}{\PYGZam{}} \PYG{n+nl}{i}\PYG{p}{:}\PYG{n}{numbers}\PYG{p}{)} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{p}{;} \PYG{c+c1}{// 3.5 4.5 5.5 6.5 7.5 8.5 9.5 10.5 11.5 12.5}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{inner\_product}
\label{\detokenize{cpp/18_commonFunc:inner-product}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}

\PYG{c+c1}{// sum/multiply}
\PYG{n}{emplate} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator1}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{InputIterator2}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{T} \PYG{n}{inner\PYGZus{}product} \PYG{p}{(}\PYG{n}{InputIterator1} \PYG{n}{first1}\PYG{p}{,} \PYG{n}{InputIterator1} \PYG{n}{last1}\PYG{p}{,} \PYG{n}{InputIterator2} \PYG{n}{first2}\PYG{p}{,} \PYG{n}{T} \PYG{n}{init}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator1}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{InputIterator2}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BinaryOperation1}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BinaryOperation2}\PYG{o}{\PYGZgt{}}
\PYG{n}{T} \PYG{n}{inner\PYGZus{}product} \PYG{p}{(}\PYG{n}{InputIterator1} \PYG{n}{first1}\PYG{p}{,} \PYG{n}{InputIterator1} \PYG{n}{last1}\PYG{p}{,}
                 \PYG{n}{InputIterator2} \PYG{n}{first2}\PYG{p}{,}
                 \PYG{n}{T} \PYG{n}{init}\PYG{p}{,}
                 \PYG{n}{BinaryOperation1} \PYG{n}{binary\PYGZus{}op1}\PYG{p}{,}
                 \PYG{n}{BinaryOperation2} \PYG{n}{binary\PYGZus{}op2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

内积运算，再与 \sphinxstylestrong{init} 做运算:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{first1}\PYG{o}{!}\PYG{o}{=}\PYG{n}{last1}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{init} \PYG{o}{=} \PYG{n}{init} \PYG{o}{+} \PYG{p}{(}\PYG{o}{*}\PYG{n}{first1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{n}{first2}\PYG{p}{)}\PYG{p}{;}
  \PYG{c+c1}{// or: init = binary\PYGZus{}op1 (init, binary\PYGZus{}op2(*first1,*first2));}
  \PYG{o}{+}\PYG{o}{+}\PYG{n}{first1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{first2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{return} \PYG{n}{init}\PYG{p}{;}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}     // std::cout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}functional\PYGZgt{}   // std::minus, std::divides}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}      // std::inner\PYGZus{}product}

\PYG{k+kt}{int} \PYG{n+nf}{myaccumulator} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{n+nf}{myproduct} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{init} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{series1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{series2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using default inner\PYGZus{}product: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{inner\PYGZus{}product}\PYG{p}{(}\PYG{n}{series1}\PYG{p}{,}\PYG{n}{series1}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{series2}\PYG{p}{,}\PYG{n}{init}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 + (10*1 + 20*2 + 30*3)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using functional operations: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{inner\PYGZus{}product}\PYG{p}{(}\PYG{n}{series1}\PYG{p}{,}\PYG{n}{series1}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{series2}\PYG{p}{,}\PYG{n}{init}\PYG{p}{,}
                                  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{minus}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{divides}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 \PYGZhy{} (10/1 + 20/2 + 30/3)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using custom functions: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{inner\PYGZus{}product}\PYG{p}{(}\PYG{n}{series1}\PYG{p}{,}\PYG{n}{series1}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{series2}\PYG{p}{,}\PYG{n}{init}\PYG{p}{,}
                                  \PYG{n}{myaccumulator}\PYG{p}{,}\PYG{n}{myproduct}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 \PYGZhy{} (10+1 + 20+2 + 30+3)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{memset}
\label{\detokenize{cpp/18_commonFunc:memset}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}

\PYG{k+kt}{void} \PYG{o}{*} \PYG{n+nf}{memset} \PYG{p}{(} \PYG{k+kt}{void} \PYG{o}{*} \PYG{n}{ptr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{value}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{num} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{memset} 按 \sphinxstylestrong{字节} 赋值， \sphinxstylestrong{fill} 按 \sphinxstylestrong{元素} 赋值。

如果用memset给int型变量赋值，只能是0或-1。

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{char} \PYG{n}{str}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{almost every programmer should know memset!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{memset} \PYG{p}{(}\PYG{n}{str}\PYG{p}{,}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{str} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} every programmer should know memset!}

  \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
  \PYG{n}{memset}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 或者 10*10*sizeof(int)，全部赋值为\PYGZhy{}1}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n+nl}{e}\PYG{p}{:}\PYG{n}{a}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bitset}\PYG{o}{\PYGZlt{}}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 11111111  11111111  11111111  11111111 （补码）}

  \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
  \PYG{n}{memset}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 或者 5*sizeof(int)，全部赋值为 16843009}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n+nl}{e}\PYG{p}{:}\PYG{n}{b}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bitset}\PYG{o}{\PYGZlt{}}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 00000001 00000001 00000001 00000001 （int型占4字节，每个字节都赋值为1）}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{附：头文件}
\label{\detokenize{cpp/18_commonFunc:id2}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cmath}}
\begin{itemize}
\item {} 
pow()

\item {} 
sqrt()

\item {} 
floor()

\item {} 
ceil()

\item {} 
round()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{cstdlib}}
\begin{itemize}
\item {} 
abs()

\item {} 
fabs()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{limits}}
\begin{itemize}
\item {} 
INT\_MIN

\item {} 
INT\_MAX

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{algorithm}}
\begin{itemize}
\item {} 
min()

\item {} 
max()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{utility}}
\begin{itemize}
\item {} 
pair

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{functional}}
\begin{itemize}
\item {} 
less\textless{} \sphinxstyleemphasis{TYPE} \textgreater{}()

\item {} 
greater\textless{} \sphinxstyleemphasis{TYPE} \textgreater{}()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{cassert}}
\begin{itemize}
\item {} 
assert()

\end{itemize}

\end{itemize}


\subsection{参考资料}
\label{\detokenize{cpp/18_commonFunc:id3}}\begin{enumerate}
\item {} 
C++ reference

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/lower\_bound}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/upper\_bound}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/fill}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/for\_each}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/sort}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/min\_element}

\sphinxurl{http://www.cplusplus.com/reference/numeric/accumulate}

\sphinxurl{http://www.cplusplus.com/reference/numeric/partial\_sum}

\sphinxurl{http://www.cplusplus.com/reference/numeric/iota}

\sphinxurl{http://www.cplusplus.com/reference/numeric/inner\_product}

\sphinxurl{http://www.cplusplus.com/reference/cstring/memset}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C/C++-STL中lower\_bound与upper\_bound的用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/jadeyansir/article/details/77015626}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
c++sort函数的使用总结

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/TX980502/p/8528840.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
C++ sort排序函数用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/w\_linux/article/details/76222112}
\end{quote}


\section{常用STL类及容器}
\label{\detokenize{cpp/19_stl:stl}}\label{\detokenize{cpp/19_stl::doc}}
\sphinxstylestrong{STL: Standard Template Library} ，标准模板库。
\begin{description}
\item[{顺序容器}] \leavevmode\begin{itemize}
\item {} 
array

\item {} 
vector

\item {} 
list

\item {} 
deque

\item {} 
string

\item {} 
…

\end{itemize}

\item[{关联容器}] \leavevmode\begin{itemize}
\item {} 
set

\item {} 
map

\item {} 
multiset

\item {} 
multimap

\item {} 
…

\end{itemize}

\item[{容器适配器}] \leavevmode\begin{itemize}
\item {} 
stack

\item {} 
queue

\item {} 
priority\_queue

\end{itemize}

\end{description}


\subsection{string}
\label{\detokenize{cpp/19_stl:string}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
长度：length()，size()，empty()

\item {} 
访问：{[}pos{]}，at(pos)。at()返回位置pos处元素的引用，越界则抛出out\_of\_range异常。

\item {} 
字典序比较：==，!=，\textless{}，\textless{}=，\textgreater{}，\textgreater{}=

\item {} 
串接：+

\item {} 
c\_str()：返回指向C类型字符串的指针。

\item {} 
子串

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n}{substr}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{pos} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{len} \PYG{o}{=} \PYG{n}{npos}\PYG{p}{)} \PYG{k}{const}
\end{sphinxVerbatim}

\end{itemize}


\subsection{vector}
\label{\detokenize{cpp/19_stl:vector}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{底层实现：顺序表（数组）。}
\begin{itemize}
\item {} 
元素个数：size()，empty()

\item {} 
逐元素比较：==，!=，\textless{}，\textless{}=，\textgreater{}，\textgreater{}=

\item {} 
内存空间：capcity()

\item {} 
访问：{[}pos{]}，at(pos)

\item {} 
头部元素：front()，返回的是引用

\item {} 
尾部元素：back()，返回的是引用

\item {} 
尾部插入：push\_back(x)

\item {} 
尾部弹出：pop\_back()

\item {} 
迭代器插入：在position \sphinxstylestrong{之前} 插入元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{n}{insert} \PYG{p}{(}\PYG{n}{iterator} \PYG{n}{position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
尾部删除：pop\_back()

\item {} 
申请空间：至少能容纳n个元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n}{reserve} \PYG{p}{(}\PYG{n}{size\PYGZus{}type} \PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
赋值
\begin{itemize}
\item {} 
数组或其他向量区间 {[}first,last) 内的值赋给当前向量。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{assign} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
赋予n个val元素给当前向量。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n}{assign} \PYG{p}{(}\PYG{n}{size\PYGZus{}type} \PYG{n}{n}\PYG{p}{,} \PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
删除：删除一个元素之后，此位置之后所有元素往前移动。虽然当前迭代器没有+1，但是由于后续元素的前移，相当于迭代器自动指向了下一个元素。故删除了一个元素之后如果要访问下一个元素，不必执行it++。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{n+nf}{erase} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{position}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iterator} \PYG{n+nf}{erase} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{const\PYGZus{}iterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 区间 [first,last)}
\end{sphinxVerbatim}

\item {} 
清除：
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vector\textless{} value\_type \textgreater{}().swap(myVec)}}

\item {} 
\sphinxcode{\sphinxupquote{myVec.clear()}} 让myVec.size()为0，但是myVec.capcity()不为0，调用 \sphinxcode{\sphinxupquote{myVec.clear()}} 之后再调用 \sphinxcode{\sphinxupquote{myVec.shrink\_to\_fit()}} 。 \sphinxcode{\sphinxupquote{shrink\_to\_fit()}} 的作用是减小capcity()以匹配size()。

\end{itemize}

\end{itemize}


\subsection{list}
\label{\detokenize{cpp/19_stl:list}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}list\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{底层实现：双向链表。}
\begin{itemize}
\item {} 
元素个数：size()，empty()

\item {} 
表首元素：front()

\item {} 
表尾元素：back()

\item {} 
插入：push\_front()，push\_back()，emplace\_front()，emplace\_back()

\item {} 
删除：pop\_front()，pop\_back()

\item {} 
迭代器插入：在position \sphinxstylestrong{之前} 插入元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{n}{insert} \PYG{p}{(}\PYG{n}{iterator} \PYG{n}{position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\subsection{deque}
\label{\detokenize{cpp/19_stl:deque}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}deque\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{底层实现：循环队列。}
\begin{itemize}
\item {} 
元素个数：size()，empty()

\item {} 
队首元素：front()

\item {} 
队尾元素：back()

\item {} 
插入：push\_front(x)，push\_back(x)

\item {} 
删除：pop\_front()，pop\_back()

\item {} 
迭代器插入：在position \sphinxstylestrong{之前} 插入元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{n}{insert} \PYG{p}{(}\PYG{n}{iterator} \PYG{n}{position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
顺序容器构造函数
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{C c;}} // 默认构造函数，空容器

\item {} 
\sphinxcode{\sphinxupquote{C c1(c2);}} // 拷贝构造函数

\item {} 
\sphinxcode{\sphinxupquote{C c(it\_begin, it\_end);}} // 迭代器指定的范围 {[}it\_begin, it\_end) 内的元素赋值给c（array不支持）

\item {} 
\sphinxcode{\sphinxupquote{C c\{a, b, c,...\};}} // 列表初始化

\end{itemize}
\end{sphinxadmonition}


\subsection{pair}
\label{\detokenize{cpp/19_stl:pair}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}utility\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
构造

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T1}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T2}\PYG{o}{\PYGZgt{}}
\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{p}{,}\PYG{n}{T2}\PYG{o}{\PYGZgt{}} \PYG{n}{make\PYGZus{}pair} \PYG{p}{(}\PYG{n}{T1} \PYG{n}{x}\PYG{p}{,} \PYG{n}{T2} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
访问：成员 \sphinxcode{\sphinxupquote{first}} 访问第一个元素，成员 \sphinxcode{\sphinxupquote{second}} 访问第二个元素。

\end{itemize}


\subsection{map}
\label{\detokenize{cpp/19_stl:map}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}map\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{底层实现：红黑树。}

\sphinxcode{\sphinxupquote{map\textless{}K，T\textgreater{}}} 容器，保存的是 \sphinxcode{\sphinxupquote{pair\textless{}const K，T\textgreater{}}} 类型的元素。

\sphinxcode{\sphinxupquote{map\textless{}K，T\textgreater{}::key\_type}} ：键类型

\sphinxcode{\sphinxupquote{map\textless{}K，T\textgreater{}::mapped\_type}} ：值类型

\sphinxcode{\sphinxupquote{map\textless{}K，T\textgreater{}::value\_type}} ：pair类型， \sphinxcode{\sphinxupquote{\textless{}map\textless{}K，T\textgreater{}::key\_type, map\textless{}K，T\textgreater{}::mapped\_type\textgreater{}}}
\begin{itemize}
\item {} 
访问：{[}key{]}，at(key)
\begin{itemize}
\item {} 
{[}key{]}，key不存在，会创建新的键值对。

\item {} 
at(key)，key不存在，抛出out\_of\_range异常。

\end{itemize}

\item {} 
查找：找不到key则返回 \sphinxcode{\sphinxupquote{map::end}} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{n+nf}{find} \PYG{p}{(}\PYG{k}{const} \PYG{n}{key\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{find} \PYG{p}{(}\PYG{k}{const} \PYG{n}{key\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{k}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
插入：如果key已经存在，则插入无效。map的元素自动按照key升序排序，不能人为对map进行排序。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{iterator}\PYG{p}{,}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}} \PYG{n}{insert} \PYG{p}{(}\PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
删除：返回删除元素后的下一个元素的迭代器，当前迭代器失效。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator}  \PYG{n+nf}{erase} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{position}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{size\PYGZus{}type} \PYG{n+nf}{erase} \PYG{p}{(}\PYG{k}{const} \PYG{n}{key\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iterator}  \PYG{n+nf}{erase} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{const\PYGZus{}iterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{it = myMap.erase(it)}} 等效为 \sphinxcode{\sphinxupquote{myMap.erase(it++)}} 。

\end{itemize}

例子

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}map\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{mymap}\PYG{p}{;}

  \PYG{c+c1}{// first insert function version (single parameter):}
  \PYG{n}{mymap}\PYG{p}{.}\PYG{n}{insert} \PYG{p}{(} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
  \PYG{n}{mymap}\PYG{p}{.}\PYG{n}{insert} \PYG{p}{(} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{value\PYGZus{}type}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{z}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator}\PYG{p}{,}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}} \PYG{n}{ret}\PYG{p}{;}
  \PYG{n}{ret} \PYG{o}{=} \PYG{n}{mymap}\PYG{p}{.}\PYG{n}{insert} \PYG{p}{(} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{z}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{500}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{ret}\PYG{p}{.}\PYG{n}{second}\PYG{o}{=}\PYG{o}{=}\PYG{n+nb}{false}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{element \PYGZsq{}z\PYGZsq{} already existed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ with a value of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ret}\PYG{p}{.}\PYG{n}{first}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{stack}
\label{\detokenize{cpp/19_stl:stack}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}stack\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
大小：size()，empty()

\item {} 
栈顶元素：top()

\item {} 
入栈：push(x)

\item {} 
出栈：pop()

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\subsection{queue}
\label{\detokenize{cpp/19_stl:queue}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}queue\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
大小：size()，empty()

\item {} 
队首元素：front()

\item {} 
队尾元素：back()

\item {} 
入队：push(x)

\item {} 
出队：pop()

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\subsection{size\_t和size\_type}
\label{\detokenize{cpp/19_stl:size-tsize-type}}

\subsubsection{size\_t}
\label{\detokenize{cpp/19_stl:size-t}}
size\_t 提供了一种可移植（不同平台下）的方法声明与系统可寻址的内存区域一致的长度。
size\_t 是通过typedef定义的一些 \sphinxstylestrong{无符号整型} 的别名，通常是 unsigned int，unsigned long 甚至是unsigned long long。

常用于循环计数器、数组索引，或指针的算术运算。

VS 32位编译器：sizeof(size\_t) = 32；VS 64位编译器：sizeof(size\_t) = 64。
\begin{description}
\item[{头文件}] \leavevmode\begin{itemize}
\item {} 
\textless{}cstddef\textgreater{}

\item {} 
\textless{}cstdio\textgreater{}

\item {} 
\textless{}cstring\textgreater{}

\item {} 
\textless{}ctime\textgreater{}

\item {} 
\textless{}cstdlib\textgreater{}

\item {} 
\textless{}cwchar\textgreater{}

\end{itemize}

\end{description}


\subsubsection{size\_type}
\label{\detokenize{cpp/19_stl:size-type}}
size\_type 是STL定义的类型属性，足够保持对应容器最大可能的容器大小。也是 \sphinxstylestrong{无符号整型} 。

size() 的返回类型就是size\_type。把 size() 赋值给一个 int 变量，会有 warning。
\begin{description}
\item[{VS 32位编译器}] \leavevmode\begin{itemize}
\item {} 
sizeof(string::size\_type) = 32

\item {} 
sizeof(vector\textless{}int\textgreater{}::size\_type) = 32

\item {} 
…

\end{itemize}

\item[{VS 64位编译器}] \leavevmode\begin{itemize}
\item {} 
sizeof(string::size\_type) = 64

\item {} 
sizeof(vector\textless{}int\textgreater{}::size\_type) = 64

\item {} 
…

\end{itemize}

\end{description}

\begin{sphinxadmonition}{warning}{Warning:}\begin{quote}

\sphinxstylestrong{无符号整型} 尤其是要注意下标为 0 时的边界情况。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{vec}\PYG{p}{;} \PYG{c+c1}{// vec = \PYGZob{}\PYGZcb{}}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{c+c1}{// 判断改为: k + 1 \PYGZlt{} vec.size()}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

上例中，本意是只有当 vec 至少包含2个元素时，才输出。但是，当 vec.size() = 0，vec.size() - 1 = 2\textasciicircum{}32 - 1 或2\textasciicircum{}64 - 1，
而不是预想的 -1。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/19_stl:id1}}\begin{enumerate}
\item {} 
C++ reference

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cplusplus.com/reference/string/string}

\sphinxurl{http://www.cplusplus.com/reference/vector/vector}

\sphinxurl{http://www.cplusplus.com/reference/list/list}

\sphinxurl{http://www.cplusplus.com/reference/deque/deque}

\sphinxurl{http://www.cplusplus.com/reference/map/map}

\sphinxurl{http://www.cplusplus.com/reference/stack/stack}

\sphinxurl{http://www.cplusplus.com/reference/queue/queue}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++ STL快速入门

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/skyfsm/p/6934246.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
STL教程：C++ STL快速入门（非常详细）

\end{enumerate}
\begin{quote}

\sphinxurl{http://c.biancheng.net/stl/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
标准C++中的string类的用法总结（转）

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/aminxu/p/4686320.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
std::size\_t

\end{enumerate}
\begin{quote}

\sphinxurl{https://zh.cppreference.com/w/cpp/types/size\_t}
\end{quote}


\section{\#define}
\label{\detokenize{cpp/20_define::doc}}\label{\detokenize{cpp/20_define:define}}\begin{description}
\item[{\sphinxstylestrong{原则}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{对于单纯常量，最好以 const 对象或 enum 替换 \#define。}

\item {} 
\sphinxstylestrong{对于形似函数的宏（macros），最好改用 inline 函数替换 \#define。}

\end{itemize}

\end{description}


\subsection{const}
\label{\detokenize{cpp/20_define:const}}
“宁可以编译器替换 \sphinxstylestrong{预编译器} ”。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ASPECT\PYGZus{}RATIO 1.653}

\PYG{k}{const} \PYG{k+kt}{double} \PYG{n}{AspectRation} \PYG{o}{=} \PYG{l+m+mf}{1.653}\PYG{p}{;}
\end{sphinxVerbatim}

也许名称 \sphinxcode{\sphinxupquote{ASPECT\_RATIO}} 从未被编译器看见，也许在编译器开始处理源码之前它已经被预处理器移走了。于是，记号名称 \sphinxcode{\sphinxupquote{ASPECT\_RATIO}}
可能没有进入记号表（symbol table）内。当运用此常量获得编译错误时，这个错误也许会提到  \sphinxcode{\sphinxupquote{1.653}} 而不是 \sphinxcode{\sphinxupquote{ASPECT\_RATIO}} ，导致对其追踪
变得困难。

作为一个语言常量， \sphinxcode{\sphinxupquote{AspectRation}} 一定会被编译器看到并记入记号表。

此外，对浮点常量而言，使用常量可能比使用 \#define 导致较小的代码量，因为预处理器将宏名称 \sphinxcode{\sphinxupquote{ASPECT\_RATIO}} 替换为  \sphinxcode{\sphinxupquote{1.653}} ，可能导致
目标码（object code）出现多份 \sphinxcode{\sphinxupquote{1.653}} ，使用常量则不会。

还可以在类定义 static const 成员。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Player}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
  \PYG{k}{static} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{NumTurns} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{// 常量声明（不是定义）}
  \PYG{k+kt}{int} \PYG{n}{scores}\PYG{p}{[}\PYG{n}{NumTurns}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 使用该常量}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{enum}
\label{\detokenize{cpp/20_define:enum}}
如果编译器不允许static成员在声明式上获得初始值，一方面，可以在头文件定义类，在源文件中初始化它；另一方面，如果该类在编译期间
必须使用一个常量值，例如上例中数组 scores 的大小必须在编译期间知道，此时可以使用 enum。一个属于枚举类型的数值可以权当int被使用。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Player}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
  \PYG{k}{enum} \PYG{p}{\PYGZob{}}\PYG{n}{NumTurns} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// NumTurns 成为数值 5 的一个记号。}
  \PYG{k+kt}{int} \PYG{n}{scores}\PYG{p}{[}\PYG{n}{NumTurns}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 使用该常量}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
enum的行为类似于\#define，取一个enum的地址或\#define的地址通常不合法，而取一个const的地址是合法的。
\end{sphinxadmonition}


\subsection{inline}
\label{\detokenize{cpp/20_define:inline}}
使用宏（macros）不会有函数调用带来的额外开销。宏中的所有实参必须添加括号，但是仍然可能出现问题。

此时，可以定义内联函数（inline），它与普通函数一样遵守作用域（scope）和访问规则。内联函数的特点：
\begin{itemize}
\item {} 
在调用处直接展开该函数的内容

\item {} 
运行速度快，但占用更多内存

\item {} 
适用于规模小、流程直接（无递归和众多判断）、频繁调用的函数

\end{itemize}
\begin{description}
\item[{普通函数的调用：}] \leavevmode\begin{enumerate}
\item {} 
执行到函数调用指令时，程序将立即存储该指令的内存地址，并将函数参数复制到栈（为此保留的内存块）；

\item {} 
跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入寄存器中）；

\item {} 
然后跳回到地址被保存的指令处。

\end{enumerate}

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define CALL\PYGZus{}WITH\PYGZus{}MAX(a, b) f((a)\PYGZgt{}(b)? (a):(b))}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define MAX\PYGZus{}COMP\PYGZus{}1(a, b) (a)\PYGZgt{}(b)? (a):(b)}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define MAX\PYGZus{}COMP\PYGZus{}2(a, b) ((a)\PYGZgt{}(b)? (a):(b)) }\PYG{c+c1}{// 有外层括号}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{f}\PYG{p}{(}\PYG{n}{T} \PYG{n}{elem}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max out: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{n}{elem} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{CallWithMax}\PYG{p}{(}\PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{a}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)} \PYG{c+c1}{// 形参使用常量引用，因为不知道 T 的具体类型，比较安全}
\PYG{p}{\PYGZob{}}
  \PYG{n}{f}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{b} \PYG{o}{?} \PYG{n+nl}{a} \PYG{p}{:} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{n}{CALL\PYGZus{}WITH\PYGZus{}MAX}\PYG{p}{(}\PYG{o}{+}\PYG{o}{+}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// a 自增2次，变为7（++a \PYGZgt{} b =\PYGZgt{} ++a）}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{CALL\PYGZus{}WITH\PYGZus{}MAX}\PYG{p}{(}\PYG{o}{+}\PYG{o}{+}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// a 自增1次，变为8（++a \PYGZlt{} b =\PYGZgt{} b）}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{n}{f}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{MAX\PYGZus{}COMP\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZhy{}10 + a \PYGZgt{} b ? a : b; 结果为 0}
  \PYG{n}{f}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{MAX\PYGZus{}COMP\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// \PYGZhy{}10 + (a \PYGZgt{} b ? a : b); 结果为 \PYGZhy{}10 + 8 = \PYGZhy{}2}

  \PYG{n}{CallWithMax}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 8}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{附：C/C++ 编译过程（简）}
\label{\detokenize{cpp/20_define:c-c}}
编译过程
\begin{quote}

\sphinxstylestrong{1.（分离式）编译} ：每个文件独立编译
\begin{quote}
\begin{enumerate}
\item {} 
预处理：处理伪指令（\#开头）和特殊符号。

\end{enumerate}
\begin{itemize}
\item {} 
宏定义：\#define，\#undef

\item {} 
条件编译：\#ifdef，\#ifndef，\#endif

\item {} 
头文件包含：\#include

\item {} 
特殊符号：\_\_LINE\_\_，\_\_FILE\_\_

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
编译：词法分析、语法分析，确认所有指令符合语法规则，将其翻译成等价的中间代码表示或汇编代码。

\item {} 
汇编：把汇编代码翻译成目标机器指令，得到目标文件（obj）。

\end{enumerate}
\end{quote}

\sphinxstylestrong{2. 链接} ：将相关的目标文件进行连接（头文件包含关系、符号引用等），使这些目标文件能够成为一个被执行的同一整体。
\end{quote}


\subsection{参考资料}
\label{\detokenize{cpp/20_define:id1}}\begin{enumerate}
\item {} 
《Effective C++》条款02。

\item {} 
《C++ Primer 第5版 中文版》 Page 213\textendash{}214。

\item {} 
C++内联函数详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/shijingjing07/p/5523224.html}
\end{quote}


\section{运算符优先级}
\label{\detokenize{cpp/21_operatorPrior::doc}}\label{\detokenize{cpp/21_operatorPrior:id1}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{|*{3}{\X{1}{3}|}}
\caption{运算符的优先级\strut}\label{\detokenize{cpp/21_operatorPrior:id2}}\\*[\sphinxlongtablecapskipadjust]
\hline
\sphinxstyletheadfamily 
prior
&\sphinxstyletheadfamily 
operator
&\sphinxstyletheadfamily 
meaning
\\
\hline
\endfirsthead

\multicolumn{3}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstyletheadfamily 
prior
&\sphinxstyletheadfamily 
operator
&\sphinxstyletheadfamily 
meaning
\\
\hline
\endhead

\hline
\multicolumn{3}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot
\sphinxmultirow{6}{4}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
1
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
{[}{]}
&
下标运算
\\
\cline{2-3}\sphinxtablestrut{4}&
()
&
圆括号
\\
\cline{2-3}\sphinxtablestrut{4}&
-\textgreater{}
&
指向运算符
\\
\cline{2-3}\sphinxtablestrut{4}&
.
&
成员运算符
\\
\cline{2-3}\sphinxtablestrut{4}&
++
&
自增（后缀）
\\
\cline{2-3}\sphinxtablestrut{4}&
- -
&
自减（后缀）
\\
\hline\sphinxmultirow{10}{17}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
2
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
!
&
逻辑非
\\
\cline{2-3}\sphinxtablestrut{17}&
\textasciitilde{}
&
按位反
\\
\cline{2-3}\sphinxtablestrut{17}&
++
&
自增（前缀）
\\
\cline{2-3}\sphinxtablestrut{17}&
- -
&
自增（前缀）
\\
\cline{2-3}\sphinxtablestrut{17}&
-
&
负号
\\
\cline{2-3}\sphinxtablestrut{17}&
+
&
正号
\\
\cline{2-3}\sphinxtablestrut{17}&
(类型)
&
类型转换
\\
\cline{2-3}\sphinxtablestrut{17}&
*
&
指针运算符
\\
\cline{2-3}\sphinxtablestrut{17}&
\&
&
取地址
\\
\cline{2-3}\sphinxtablestrut{17}&
sizeof
&
长度运算
\\
\hline\sphinxmultirow{3}{38}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
3
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
*
&
乘法
\\
\cline{2-3}\sphinxtablestrut{38}&
/
&
除法
\\
\cline{2-3}\sphinxtablestrut{38}&
\%
&
求余
\\
\hline\sphinxmultirow{2}{45}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
4
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
+
&
加法
\\
\cline{2-3}\sphinxtablestrut{45}&
-
&
减法
\\
\hline\sphinxmultirow{2}{50}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
5
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\textless{}\textless{}
&
左移位
\\
\cline{2-3}\sphinxtablestrut{50}&
\textgreater{}\textgreater{}
&
右移位
\\
\hline
6
&
\textless{} \textless{}= \textgreater{} \textgreater{}=
&
关系运算符
\\
\hline\sphinxmultirow{2}{58}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
7
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
==
&
等于
\\
\cline{2-3}\sphinxtablestrut{58}&
!=
&
不等于
\\
\hline
8
&
\&
&
按位与
\\
\hline
9
&
\textasciicircum{}
&
按位异或
\\
\hline
10
&
\textbar{}
&
按位或
\\
\hline
11
&
\&\&
&
逻辑与
\\
\hline
12
&
\textbar{}\textbar{}
&
逻辑或
\\
\hline
13
&
? :
&
条件运算符
\\
\hline\sphinxmultirow{3}{81}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
14
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{3}{82}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
=   +=  -=  *=

/=  \%=  \&=  \textbar{}=

\textasciicircum{}=  \textless{}\textless{}=  \textgreater{}\textgreater{}=
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{3}{83}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
赋值运算符
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
\\
\sphinxtablestrut{81}&\sphinxtablestrut{82}&\sphinxtablestrut{83}\\
\sphinxtablestrut{81}&\sphinxtablestrut{82}&\sphinxtablestrut{83}\\
\hline
15
&
,
&
逗号运算符
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
位运算的优先级是：\sphinxcode{\sphinxupquote{\textasciitilde{}}} \textgreater{} \sphinxcode{\sphinxupquote{\&}} \textgreater{} \sphinxcode{\sphinxupquote{\textasciicircum{}}} \textgreater{} \sphinxcode{\sphinxupquote{\textbar{}}} 。

逻辑运算的优先级是：\sphinxcode{\sphinxupquote{!}} \textgreater{} \sphinxcode{\sphinxupquote{\&\&}} \textgreater{} \sphinxcode{\sphinxupquote{\textbar{}\textbar{}}} 。

不能重载的运算符（5个）：\sphinxcode{\sphinxupquote{.}} ， \sphinxcode{\sphinxupquote{.*}} ， \sphinxcode{\sphinxupquote{::}} ，\sphinxcode{\sphinxupquote{sizeof}} ，\sphinxcode{\sphinxupquote{? :}} 。
\end{sphinxadmonition}


\chapter{Python}
\label{\detokenize{python/index:python}}\label{\detokenize{python/index::doc}}

\section{in-place 运算}
\label{\detokenize{python/01_inplace:in-place}}\label{\detokenize{python/01_inplace::doc}}

\subsection{+= 运算}
\label{\detokenize{python/01_inplace:id1}}
\sphinxcode{\sphinxupquote{+=}} 是一个in-place运算符，看如下例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{n}{a} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1,2]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[1,2]}
\end{sphinxVerbatim}

如果改变成如下形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

则结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1,2]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{a = a + {[}1,2{]}}} 不是in-place运算，尽管使用了同一个变量名。
\end{sphinxadmonition}


\subsection{add和iadd}
\label{\detokenize{python/01_inplace:addiadd}}
\sphinxcode{\sphinxupquote{operator}} 包中有两个操作：\sphinxcode{\sphinxupquote{add}} 和 \sphinxcode{\sphinxupquote{iadd}} 。\sphinxcode{\sphinxupquote{add}} 是正常加运算， \sphinxcode{\sphinxupquote{iadd}} 是原位加运算。
\begin{quote}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{\_add\_}}}] \leavevmode
does simple addition, takes two arguments, returns the sum and stores it in other variable without modifying any of the argument.
Normal operator’s \sphinxcode{\sphinxupquote{add()}} method, implements \sphinxstylestrong{“a+b”} and stores the result in the mentioned variable.

\item[{\sphinxcode{\sphinxupquote{\_iadd\_}}}] \leavevmode
also takes two arguments, but it makes in-place change in 1st argument passed by storing the sum in it. As object mutation is needed in this process, immutable targets such as numbers, strings and tuples, shouldn’t have \sphinxcode{\sphinxupquote{\_iadd\_}} method.
Inplace operator’s \sphinxcode{\sphinxupquote{iadd()}} method, implements \sphinxstylestrong{“a+=b”} if it exists (i.e in case of immutable targets, it doesn’t exist) and changes the value of passed argument. But if not, \sphinxstylestrong{“a+b”} is implemented.

\end{description}
\end{quote}

分两种情况讨论。


\subsubsection{immutable targets}
\label{\detokenize{python/01_inplace:immutable-targets}}
对于不可变目标（immutable targets），如数字、字符串、元组， \sphinxcode{\sphinxupquote{\_add\_}} 和 \sphinxcode{\sphinxupquote{\_iadd\_}} 结果是一样的，输入实参不会发生改变。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{operator}

\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{6}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{iadd}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{z}
\PYG{g+go}{11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{p}
\PYG{g+go}{11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{x}
\PYG{g+go}{5}
\end{sphinxVerbatim}


\subsubsection{mutable targets}
\label{\detokenize{python/01_inplace:mutable-targets}}
对于可变目标（mutable targets），如列表、字典，输入实参会被重现赋值和更新。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{operator}

\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{iadd}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{z}
\PYG{g+go}{[1, 2, 4, 5, 1, 2, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{p}
\PYG{g+go}{[1, 2, 4, 5, 1, 2, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1, 2, 4, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[1, 2, 4, 5, 1, 2, 3]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{不可变目标} （数字、字符串、元组）作为函数参数，相当于 \sphinxstylestrong{值传递} ，函数对实参进行拷贝。

\sphinxstylestrong{可变目标} （列表、字典）作为函数参数，相当于 \sphinxstylestrong{引用传递} ，函数对实参的修改有效。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{python/01_inplace:id2}}\begin{enumerate}
\item {} 
pytorch issue：

\end{enumerate}
\begin{quote}

\sphinxurl{https://github.com/pytorch/pytorch/issues/5687}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
GeeksforGeeks：

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.geeksforgeeks.org/inplace-vs-standard-operators-python/}
\end{quote}


\section{\_\_all\_\_ 的使用}
\label{\detokenize{python/02_all:all}}\label{\detokenize{python/02_all::doc}}

\subsection{从\_\_init\_\_.py谈起}
\label{\detokenize{python/02_all:init-py}}
\sphinxcode{\sphinxupquote{\_\_init\_\_.py}} 的 \sphinxstylestrong{作用一} ：package的标识
\begin{quote}

在每一个package文件夹中都会有一个\_\_init\_\_.py文件。
\end{quote}

\sphinxcode{\sphinxupquote{\_\_init\_\_.py}} 的 \sphinxstylestrong{作用二} ：定义该package的 \sphinxcode{\sphinxupquote{\_\_all\_\_}} ，用以模糊导入
\begin{quote}

python中包(package)和模块(module)有两种导入形式：精确导入和模糊导入。
\begin{description}
\item[{精确导入}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PACK} \PYG{k+kn}{import} \PYG{n}{CLASS1}\PYG{p}{,} \PYG{n}{CLASS2}
\PYG{k+kn}{import} \PYG{n+nn}{PACK.CLASS1}
\end{sphinxVerbatim}

\item[{模糊导入}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PACK} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

\end{description}
\end{quote}

\sphinxcode{\sphinxupquote{\_\_all\_\_}} 是一个字符串列表，用于定义模糊导入中的 \sphinxcode{\sphinxupquote{*}} 中的模块，即暴露接口，也是对于模块公开接口的一种约定。

举个例子，建立如下目录结构的文件夹及文件:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}
\PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n}{test}\PYG{o}{.}\PYG{n}{py}
\PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n}{myPack}
    \PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n}{func}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

创建了包 \sphinxstylestrong{myPack} ，其中 \sphinxstylestrong{func.py} 中定义了该包的功能，包括变量、类、函数的定义。使用 \sphinxstylestrong{test.py} 来测试这个包的调用。
\sphinxcode{\sphinxupquote{\_\_init\_\_.py}} 中的内容如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{func} \PYG{k+kn}{import} \PYG{n}{x}\PYG{p}{,} \PYG{n}{foo}
\PYG{c+c1}{\PYGZsh{} 假设x是一个变量，foo是一个函数}

\PYG{n}{\PYGZus{}\PYGZus{}all\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{foo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxstylestrong{test.py} 中的内容如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{myPack} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{k}{print} \PYG{n}{x}

\PYG{n}{foo}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/02_all:id1}}\begin{enumerate}
\item {} 
Python中的 \_\_all\_\_

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/ca469f693c31}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Python包中 \_\_init\_\_.py 作用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/AlwinXu/p/5598543.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Python \_\_init\_\_.py 作用详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/Lands-ljk/p/5880483.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Python中 \_\_all\_\_ 的用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.codetd.com/article/2136881}
\end{quote}


\section{is和==}
\label{\detokenize{python/03_is:is}}\label{\detokenize{python/03_is::doc}}

\subsection{is和==}
\label{\detokenize{python/03_is:id1}}
\sphinxcode{\sphinxupquote{is}} 的作用是用来检查对象的标示符（object identity）是否一致，也就是比较两个对象在内存中的地址是否一样，而 \sphinxcode{\sphinxupquote{==}} 是用来检查两个对象是否相等。
我们在检查 \sphinxcode{\sphinxupquote{a is b}} 的时候，其实相当于检查 \sphinxcode{\sphinxupquote{id(a) == id(b)}}。而检查 \sphinxcode{\sphinxupquote{a == b}} 的时候，实际是调用了对象a的 \sphinxcode{\sphinxupquote{\_\_eq\_\_()}} 方法，\sphinxcode{\sphinxupquote{a == b}}
相当于 \sphinxcode{\sphinxupquote{a.\_\_eq\_\_(b)}}。
一般情况下，如果 \sphinxcode{\sphinxupquote{a is b}} 返回True的话，即a和b指向同一块内存地址的话，\sphinxcode{\sphinxupquote{a == b}} 也返回True，即a和b的值也相等。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{b} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{print} \PYG{n}{a}\PYG{o}{==}\PYG{n}{b} \PYG{c+c1}{\PYGZsh{} True}
\PYG{k}{print} \PYG{n}{a} \PYG{o+ow}{is} \PYG{n}{b} \PYG{c+c1}{\PYGZsh{} False}
\PYG{k}{print} \PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{k}{print} \PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{k}{print} \PYG{n}{a}\PYG{o}{==}\PYG{n}{b} \PYG{c+c1}{\PYGZsh{} True}
\PYG{k}{print} \PYG{n}{a} \PYG{o+ow}{is} \PYG{n}{b} \PYG{c+c1}{\PYGZsh{} True}
\end{sphinxVerbatim}


\subsection{None}
\label{\detokenize{python/03_is:none}}
与 \sphinxcode{\sphinxupquote{None}} 比较是 \sphinxcode{\sphinxupquote{is None}} 而不是 \sphinxcode{\sphinxupquote{== None}} 。
这是因为 \sphinxcode{\sphinxupquote{None}} 在Python里是个单例对象（singleton）：一个变量如果是 \sphinxcode{\sphinxupquote{None}} ，它一定和 \sphinxcode{\sphinxupquote{None}} 指向同一个内存地址。
而 \sphinxcode{\sphinxupquote{== None}} 背后调用的是 \sphinxcode{\sphinxupquote{\_\_eq\_\_}} ，而 \sphinxcode{\sphinxupquote{\_\_eq\_\_}} 可以被重载，下面是一个 \sphinxcode{\sphinxupquote{is not None}} 但 \sphinxcode{\sphinxupquote{== None}} 的例子。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Foo}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}eq\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{True}

\PYG{n}{foo} \PYG{o}{=} \PYG{n}{Foo}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{foo}\PYG{o}{==}\PYG{n+nb+bp}{None} \PYG{c+c1}{\PYGZsh{} True}
\PYG{k}{print} \PYG{n}{foo} \PYG{o+ow}{is} \PYG{n+nb+bp}{None} \PYG{c+c1}{\PYGZsh{} False}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/03_is:id2}}\begin{enumerate}
\item {} 
经典7大Python面试题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qq\_41597912/article/details/81459804}
\end{quote}


\section{装饰器}
\label{\detokenize{python/04_decorator::doc}}\label{\detokenize{python/04_decorator:id1}}

\subsection{作用}
\label{\detokenize{python/04_decorator:id2}}
装饰器本质上是一个Python函数，它可以让其他函数在 \sphinxstylestrong{不需要做任何代码变动} 的前提下 \sphinxstylestrong{增加额外功能} ，装饰器的返回值也是一个函数对象。
它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。
装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。

概括的讲，装饰器的作用就是为已经存在的函数或对象添加额外的功能。


\subsection{使用装饰器计时}
\label{\detokenize{python/04_decorator:id3}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{wraps}
\PYG{k+kn}{import} \PYG{n+nn}{time}

\PYG{k}{def} \PYG{n+nf}{timer}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@wraps}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{function\PYGZus{}timer}\PYG{p}{(}\PYG{o}{*}\PYG{n}{arg}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{start\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{result} \PYG{o}{=} \PYG{n}{func}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
        \PYG{n}{end\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{result}
    \PYG{k}{return} \PYG{n}{function\PYGZus{}timer}

\PYG{n+nd}{@timer}
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{print} \PYG{n}{foo}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}
\PYG{k}{print} \PYG{n}{foo}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}}
\end{sphinxVerbatim}

使用 \sphinxcode{\sphinxupquote{wraps}} 可以保持函数 \sphinxcode{\sphinxupquote{foo()}} 的属性 \sphinxcode{\sphinxupquote{\_\_name\_\_}} 和 \sphinxcode{\sphinxupquote{\_\_doc\_\_}} ，而不变成函数 \sphinxcode{\sphinxupquote{function\_timer}} 的相关属性。


\subsection{参考资料}
\label{\detokenize{python/04_decorator:id4}}\begin{enumerate}
\item {} 
详解Python的装饰器

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/cicaday/p/python-decorator.html}
\end{quote}


\section{迭代器和生成器}
\label{\detokenize{python/05_iterator::doc}}\label{\detokenize{python/05_iterator:id1}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{05_iterator}.png}\hspace*{\fill}}


\subsection{迭代器（iterator）}
\label{\detokenize{python/05_iterator:iterator}}\begin{description}
\item[{特点：}] \leavevmode\begin{itemize}
\item {} 
迭代器是访问集合元素的一种方式，不能随机访问集合中的某个值，只能从头到尾依次访问（ \sphinxcode{\sphinxupquote{next()}} 方法），访问到一半时不能往回退。

\item {} 
不需要事先准备好整个迭代过程中的所有元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。

\item {} 
便于循环比较大的数据集合，节省内存。

\item {} 
不能复制一个迭代器，如果要再次（或者同时）迭代同一个对象，只能去创建另一个迭代器对象。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} enumerate 返回迭代器}
\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 迭代两次enumerate对象}
    \PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{========}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

结果是：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\end{sphinxVerbatim}

可以发现：第二次返回值为空。

\end{description}


\subsubsection{可迭代对象（iterable）}
\label{\detokenize{python/05_iterator:iterable}}
\sphinxstylestrong{可以直接作用于for循环的对象统称为可迭代对象（Iterable）} 。只要定义了可以返回一个迭代器的 \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 方法，或者定义了可以支持下标索引的 \sphinxcode{\sphinxupquote{\_\_getitem\_\_()}} 方法，那么它就是一个可迭代对象。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Iterator\PYGZus{}test}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}

  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}iter\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{return} \PYG{n+nb+bp}{self}

  \PYG{k}{def} \PYG{n+nf}{next}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{:}
          \PYG{k}{raise} \PYG{n+ne}{StopIteration}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
      \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index}\PYG{p}{]}

\PYG{n}{iterator\PYGZus{}winter} \PYG{o}{=} \PYG{n}{Iterator\PYGZus{}test}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcde}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{iterator\PYGZus{}winter}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{item}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 打印 e d c b a}

\PYG{k}{class} \PYG{n+nc}{Iterator\PYGZus{}test2}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{it}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{it}\PYG{p}{]}
\PYG{n}{no\PYGZus{}iter} \PYG{o}{=} \PYG{n}{Iterator\PYGZus{}test2}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcde}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{no\PYGZus{}iter}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{item}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 打印 a b c d e}
\end{sphinxVerbatim}

常见的可迭代对象：
\begin{itemize}
\item {} 
集合数据类型，如list、tuple、dict、set、str等。

\item {} 
generator，包括生成器和带yield的generator function。

\end{itemize}

\sphinxstylestrong{可以被next()函数调用并不断返回下一个值的对象称为迭代器（Iterator）} 。生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。

\sphinxstylestrong{所有的Iterable均可以通过内置函数iter()来转变为Iterator} 。

判断一个对象是否是可迭代对象：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{Iterable}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{Iterable}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} True}

\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 或 a.next()，返回 1}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 返回 2}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 返回 3}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 抛出 StopIteration 异常}
\end{sphinxVerbatim}

一个可迭代对象是不能独立进行迭代的，Python中， 迭代是通过 \sphinxcode{\sphinxupquote{for ... in}} 来完成的 。
for循环会不断调用迭代器对象的 \sphinxcode{\sphinxupquote{\_\_next\_\_()}} 方法（python3  \sphinxcode{\sphinxupquote{\_\_next\_\_()}} ；python2  \sphinxcode{\sphinxupquote{next()}} ），每次循环，都返回迭代器对象的下一个值，直到遇到 \sphinxcode{\sphinxupquote{StopIteration}} 异常。

任何实现了 \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 和 \sphinxcode{\sphinxupquote{\_\_next\_\_()}} （python2中实现 \sphinxcode{\sphinxupquote{next()}} ）方法的对象都是迭代器， \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 返回迭代器自身， \sphinxcode{\sphinxupquote{\_\_next\_\_()}} 返回容器中的下一个值 。


\subsection{生成器（generator）}
\label{\detokenize{python/05_iterator:generator}}
生成器其实是一种特殊的迭代器。它不需要再像上面的类一样写 \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 和 \sphinxcode{\sphinxupquote{\_\_next\_\_()}} 方法了，只需要一个 \sphinxcode{\sphinxupquote{yiled}} 关键字。 \sphinxcode{\sphinxupquote{yield}} 就是return返回的一个值，并且记住这个返回的位置。下一次迭代就从这个位置开始。
生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{generator\PYGZus{}winter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}
  \PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{:}
      \PYG{k}{yield} \PYG{n}{i}
      \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n}{generator\PYGZus{}iter} \PYG{o}{=} \PYG{n}{generator\PYGZus{}winter}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 1}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 2}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 3}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 抛出 StopIteration 异常}
\end{sphinxVerbatim}

\sphinxstylestrong{生成器表达式} （类似于列表推导式，只是把{[}{]}换成()）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gen} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZlt{}generator object \PYGZlt{}genexpr\PYGZgt{} at 0x0000000012BC4990\PYGZgt{}}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{gen}\PYG{p}{:}
  \PYG{k}{print} \PYG{n}{item}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} fibonacci 数列}
\PYG{k}{def} \PYG{n+nf}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
  \PYG{k}{while} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{n}\PYG{p}{:}
      \PYG{k}{yield} \PYG{n}{b}
      \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{item}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/05_iterator:id2}}\begin{enumerate}
\item {} 
Python迭代器，生成器\textendash{}精华中的精华

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/deeper/p/7565571.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
python 生成器和迭代器有这篇就够了

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/wj-1314/p/8490822.html}
\end{quote}


\section{lambda用法}
\label{\detokenize{python/06_lambda::doc}}\label{\detokenize{python/06_lambda:lambda}}
使用：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{p}{[}\PYG{n}{arg1}\PYG{p}{[}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{argN}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:} \PYG{n}{expression}
\end{sphinxVerbatim}
\begin{description}
\item[{特性：}] \leavevmode\begin{itemize}
\item {} 
匿名函数。函数没有名字。

\item {} 
输入是arg list，输出是根据expression计算得到的值。

\item {} 
功能简单。

\end{itemize}

\end{description}


\subsection{使用场景}
\label{\detokenize{python/06_lambda:id1}}\begin{enumerate}
\item {} 
将lambda函数赋值给一个变量，通过这个变量间接调用该函数。

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{plus} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}
\PYG{k}{print} \PYG{n}{plus}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
将lambda函数赋值给其他函数，从而屏蔽其他函数本来的功能。

\item {} 
将lambda函数作为其他函数的返回值（内部函数）。

\item {} 
将lambda函数作为参数传递给其他函数。

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxstylestrong{map} ：将序列中的元素通过处理函数处理后返回一个新的列表。

\item {} 
\sphinxstylestrong{filter} ：将序列中的元素通过函数过滤后返回一个新的列表。

\item {} 
\sphinxstylestrong{reduce} ：将序列中的元素通过一个二元函数处理返回一个结果。

\item {} 
\sphinxstylestrong{sorted} ：结合lambda对列表进行排序。 \sphinxcode{\sphinxupquote{sorted(iterable, cmp=None, key=None, reverse=False)}}

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 每个元素加1}
\PYG{n}{b} \PYG{o}{=} \PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} [2, 3, 7, 6, 3, \PYGZhy{}7, \PYGZhy{}4, 0, \PYGZhy{}9]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 提取序列中大于0的数}
\PYG{n}{c} \PYG{o}{=} \PYG{n+nb}{filter}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} [1, 2, 6, 5, 2]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 返回所有元素相乘的结果}
\PYG{n}{d} \PYG{o}{=} \PYG{n+nb}{reduce}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{n}{y}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 48000}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 负数排在正数前面，同时绝对值大的排在后面}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 两个key，先按第一个key排序，若第一个key相同则按下一个key排序}
\PYG{n}{e} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} [\PYGZhy{}1, \PYGZhy{}5, \PYGZhy{}8, \PYGZhy{}10, 1, 2, 2, 5, 6]}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/06_lambda:id2}}\begin{enumerate}
\item {} 
关于Python中的lambda，这可能是你见过的最完整的讲解

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zjuxsl/article/details/79437563}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
在Python中使用lambda高效操作列表的教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/mxp-neu/articles/5316557.html}
\end{quote}


\section{*args和**kwargs}
\label{\detokenize{python/07_arg:args-kwargs}}\label{\detokenize{python/07_arg::doc}}

\subsection{*args}
\label{\detokenize{python/07_arg:args}}
\sphinxcode{\sphinxupquote{*args}} 用来将 \sphinxstylestrong{不定数量} 的参数打包成 \sphinxcode{\sphinxupquote{tuple}} 给函数体使用。

例一：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{args[\PYGZob{}\PYGZcb{}]:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{args}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{200k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{args[0]: 100}
\PYG{g+go}{args[1]: 200k}
\PYG{g+go}{args[2]: 300}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{args} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{x: A}
\PYG{g+go}{args[0]: 1}
\PYG{g+go}{args[1]: 2}
\PYG{g+go}{args[2]: abc}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 注：此时把args当做一个参数，参数类型为列表}
\PYG{g+go}{x: A}
\PYG{g+go}{args[0]: [1, 2, \PYGZsq{}abc\PYGZsq{}]}
\end{sphinxVerbatim}

例二：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{var1}\PYG{p}{,} \PYG{n}{var2}\PYG{p}{,} \PYG{n}{var3}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var1:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var1}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var2:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var2}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var3:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var3}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{args} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} list}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{TypeError: foo() takes exactly 4 arguments (2 given)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: 1}
\PYG{g+go}{var2: 2}
\PYG{g+go}{var3: A}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{args} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} tuple}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{TypeError: foo() takes exactly 4 arguments (2 given)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: 1}
\PYG{g+go}{var2: 2}
\PYG{g+go}{var3: A}
\end{sphinxVerbatim}


\subsection{**kwargs}
\label{\detokenize{python/07_arg:kwargs}}
\sphinxcode{\sphinxupquote{**kwargs}} 打包 \sphinxstylestrong{不定数量} 的键值对参数成 \sphinxcode{\sphinxupquote{dict}} 给函数体使用。

例一：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{key}\PYG{p}{,} \PYG{n}{val} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{} : \PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{n}{var1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{var2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{var3}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{var1 : 1}
\PYG{g+go}{var3 : [1, 2, 3]}
\PYG{g+go}{var2 : a}
\end{sphinxVerbatim}

例二：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{var1}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{var2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var1:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var1}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var2:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var2}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dict\PYGZus{}input} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{dict\PYGZus{}input}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: \PYGZob{}\PYGZsq{}var1\PYGZsq{}: 10, \PYGZsq{}var2\PYGZsq{}: \PYGZsq{}A\PYGZsq{}\PYGZcb{}}
\PYG{g+go}{var2: a}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{dict\PYGZus{}input}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: 10}
\PYG{g+go}{var2: A}
\end{sphinxVerbatim}


\subsection{arg，*args，**kwargs}
\label{\detokenize{python/07_arg:arg-args-kwargs}}
位置参数、*args、**kwargs三者的顺序必须是（arg，*args，**kwargs）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{arg:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{arg}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{args:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{args}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kwargs:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{kwargs}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{arg: 1}
\PYG{g+go}{args: (2, 3, 4)}
\PYG{g+go}{kwargs: \PYGZob{}\PYGZsq{}y\PYGZsq{}: \PYGZsq{}b\PYGZsq{}, \PYGZsq{}x\PYGZsq{}: 1\PYGZcb{}}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{SyntaxError: non\PYGZhy{}keyword arg after keyword arg}
\end{sphinxVerbatim}

位置参数、默认参数、**kwargs三者的顺序必须是（位置参数，默认参数，**kwargs）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 不能出现 (x=1,y,**kwargs)}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{y}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kwargs:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{kwargs}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{var1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{var2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{x: 4}
\PYG{g+go}{y: 1}
\PYG{g+go}{kwargs: \PYGZob{}\PYGZsq{}var1\PYGZsq{}: 1, \PYGZsq{}var2\PYGZsq{}: \PYGZsq{}b\PYGZsq{}\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/07_arg:id1}}\begin{enumerate}
\item {} 
大话Python中*args和**kargs的使用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/shitaotao/p/7609990.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
python函数——形参中的：*args和**kwargs

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/xuyuanyuan123/p/6674645.html}
\end{quote}


\section{基本数据类型}
\label{\detokenize{python/08_basicType::doc}}\label{\detokenize{python/08_basicType:id1}}

\subsection{类型与方法}
\label{\detokenize{python/08_basicType:id2}}\begin{itemize}
\item {} 
\sphinxstylestrong{str}
\begin{itemize}
\item {} 
索引、切片：{[}ind{]}，{[}first:last{]}获取区间 {[}first, last) 内的元素。

\item {} 
长度：len()

\item {} 
查找：若字符/序列不在字符串内，index()报错 ValueError，find()返回-1。

\item {} 
判断字符串内容：字母，isalpha()；数字，isdigit()；数字或字母，isalnum()。

\item {} 
大小写转换：capitalize()、lower()、upper()。

\item {} 
判断以什么开头结尾：startswith()、endswith()。

\item {} 
连接：join()，将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串。

\item {} 
分割：split()、partition()。 \sphinxstylestrong{如果想把字符串分割成独立的字符，用 list(string)。}

\item {} 
替代：replace()

\item {} 
清除空白: strip()、lstrip()、rstrip()

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{abcde}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{a\PYGZhy{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{def}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ghi}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{abc\PYGZus{}def\PYGZus{}ghi}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}
\PYG{g+go}{[\PYGZsq{}abc\PYGZsq{}, \PYGZsq{}def\PYGZsq{}, \PYGZsq{}ghi\PYGZsq{}]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a\PYGZhy{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{partion}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 只能分割为3部分}
\PYG{g+go}{(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZsq{}, \PYGZsq{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e\PYGZsq{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}, \PYGZsq{}e\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}
\PYG{g+go}{\PYGZdq{}a\PYGZhy{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxstylestrong{str} 是不可变对象，其所有方法都 \sphinxstylestrong{不改变对象本身} ，而是返回所创建的新对象。
\end{sphinxadmonition}

\item {} 
\sphinxstylestrong{list}
\begin{itemize}
\item {} 
索引、切片：{[}ind{]}，{[}first:last{]}获取区间 {[}first, last) 内的元素。

\item {} 
统计元素出现的次数：count()

\item {} 
追加：append()

\item {} 
拓展：extend()

\item {} 
插入：insert()

\item {} 
弹出元素：pop()，默认弹出列表末尾的元素

\item {} 
移除/删除元素：remove()，del （del可删除切片）

\item {} 
排序：sort()

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 2, 3, 4]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 2, 3, 4, 10, 20, 30]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 在第一个元素之后插入}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 5, 2, 3, 4, 10, 20, 30]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 5, 3, 4, 10, 20, 30]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 5, 3, 10, 20, 30]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{reverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[30, 20, 10, 5, 3, 1] \PYGZsh{}\PYGZsh{} 直接修改 a，无返回值。使用 sorted 返回排序后的副本。}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a2} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 5, 10, 20, 30] \PYGZsh{}\PYGZsh{} a}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{dict}
\begin{itemize}
\item {} 
获取：keys()，values()，items()。

\item {} 
清除：clear()

\item {} 
访问：get(key)，不存在时返回None。

\item {} 
更新：update(d)，把另一个字典d中的项添加到当前字典。

\item {} 
浅复制：copy()

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info} \PYG{o}{=}\PYG{p}{\PYGZob{}}
\PYG{g+gp}{... }     \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tom}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{g+gp}{... }      \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{,}
\PYG{g+gp}{... }      \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sex}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{man}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{g+gp}{... }     \PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}age\PYGZsq{}, \PYGZsq{}name\PYGZsq{}, \PYGZsq{}sex\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[25, \PYGZsq{}Tom\PYGZsq{}, \PYGZsq{}man\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[(\PYGZsq{}age\PYGZsq{}, 25), (\PYGZsq{}name\PYGZsq{}, \PYGZsq{}Tom\PYGZsq{}), (\PYGZsq{}sex\PYGZsq{}, \PYGZsq{}man\PYGZsq{})]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{age}\PYG{p}{)}
\PYG{g+go}{25}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{new} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{60}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{new}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}
\PYG{g+go}{\PYGZob{}\PYGZsq{}age\PYGZsq{}: 25, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}Tom\PYGZsq{}, \PYGZsq{}weight\PYGZsq{}: 60, \PYGZsq{}sex\PYGZsq{}: \PYGZsq{}man\PYGZsq{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}
\PYG{g+go}{\PYGZob{}\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{collections.defaultdict} ：defaultdict类使用一种给定数据类型来初始化。当所访问的key不存在的时候，会实例化一个value作为默认值。因此，判断某个key是否存在，可使用get(key)。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{defaultdict}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dd} \PYG{o}{=} \PYG{n}{defaultdict}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 使用 list 作为value type}
\PYG{g+go}{defaultdict(\PYGZlt{}type \PYGZsq{}list\PYGZsq{}\PYGZgt{}, \PYGZob{}\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dd}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{[]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dd}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{defaultdict(\PYGZlt{}type \PYGZsq{}list\PYGZsq{}\PYGZgt{}, \PYGZob{}\PYGZsq{}a\PYGZsq{}: [], \PYGZsq{}b\PYGZsq{}: [\PYGZsq{}hello\PYGZsq{}]\PYGZcb{})}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{set}
\begin{itemize}
\item {} 
特征：无重复，无须，每个元素为不可变类型

\item {} 
增加元素：单个元素，add()；多个元素，update()

\item {} 
删除：删除元素不存在，remove()报错，discard()无反应。

\item {} 
集合操作：\&，\textbar{}，-，\textasciicircum{}（交差补集，去除交集后剩下元素的并集），issubset() 、isupperset()。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 或者 s1 = set([\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}
\PYG{g+go}{set([\PYGZsq{}a\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}e\PYGZsq{}, \PYGZsq{}d\PYGZsq{}])}
\end{sphinxVerbatim}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
对于 \sphinxcode{\sphinxupquote{切片（slice）}} 操作，下标越界 \sphinxstylestrong{不会} 报错，返回空。

对于 \sphinxcode{\sphinxupquote{索引（index）}} 操作，下标越界 \sphinxstylestrong{会} 报错。
\end{sphinxadmonition}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{j}\PYG{p}{]}

\PYG{n}{The} \PYG{n+nb}{slice} \PYG{n}{of} \PYG{n}{s} \PYG{k+kn}{from} \PYG{n+nn}{i} \PYG{n}{to} \PYG{n}{j} \PYG{o+ow}{is} \PYG{n}{defined} \PYG{k}{as} \PYG{n}{the} \PYG{n}{sequence} \PYG{n}{of} \PYG{n}{items} \PYG{k}{with} \PYG{n}{index} \PYG{n}{k} \PYG{n}{such} \PYG{n}{that} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{o}{.}

\PYG{n}{If} \PYG{n}{i} \PYG{o+ow}{or} \PYG{n}{j} \PYG{o+ow}{is} \PYG{n}{greater} \PYG{n}{than} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{,} \PYG{n}{use} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{If} \PYG{n}{i} \PYG{o+ow}{is} \PYG{n}{omitted} \PYG{o+ow}{or} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{use} \PYG{l+m+mf}{0.}
\PYG{n}{If} \PYG{n}{j} \PYG{o+ow}{is} \PYG{n}{omitted} \PYG{o+ow}{or} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{use} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{If} \PYG{n}{i} \PYG{o+ow}{is} \PYG{n}{greater} \PYG{n}{than} \PYG{o+ow}{or} \PYG{n}{equal} \PYG{n}{to} \PYG{n}{j}\PYG{p}{,} \PYG{n}{the} \PYG{n+nb}{slice} \PYG{o+ow}{is} \PYG{n}{empty}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{深复制和浅复制}
\label{\detokenize{python/08_basicType:id3}}\begin{itemize}
\item {} 
\sphinxstylestrong{直接赋值} ：并没有拷贝对象，而是拷贝了对象的引用，因此原始对象或被赋值对象的改变，都会导致另一个对象被修改。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{alist} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 引用}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{alist}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 复制}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}
\PYG{g+go}{[1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{[1, 2, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{[1, 2, 3]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{浅复制} ：只会复制父对象，而不会复制对象的内部的子对象。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{copy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} [\PYGZsq{}a\PYGZsq{},\PYGZsq{}b\PYGZsq{}] 是列表，是一个子对象}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy} \PYG{o}{=} \PYG{n}{copy}\PYG{p}{(}\PYG{n}{alist}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} dict类有copy()方法，e.g.，d.copy()}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 非子对象的修改}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}], 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}], 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}]]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 子对象的修改}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}], 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}], 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}]]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{深复制} ：复制对象及其子对象，原始对象的改变不会造成深复制里任何子元素的改变。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{deepcopy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} [\PYGZsq{}a\PYGZsq{},\PYGZsq{}b\PYGZsq{}] 是列表，是一个子对象}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{alist}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 子对象的修改}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}d\PYGZsq{}]]}
\end{sphinxVerbatim}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
对于可变对象 \sphinxstylestrong{dict} 和 \sphinxstylestrong{list} ，需要暂存临时对象或者作为函数参数传递时，如果不希望对象被更改，都需要使用深复制。
\end{sphinxadmonition}


\subsection{再谈可变对象与不可变对象}
\label{\detokenize{python/08_basicType:id4}}
第一章曾提到过可变对象与不可变对象。

\sphinxstylestrong{dict} 和 \sphinxstylestrong{set} 的底层实现都是 \sphinxstylestrong{哈希表} 。哈希要求key唯一，因此 \sphinxstylestrong{dict} 和 \sphinxstylestrong{set} 的key都要求是 \sphinxstylestrong{不可变对象} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcd}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{313010056L}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcd}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{g+go}{313010056L}
\PYG{g+go}{\PYGZsh{}\PYGZsh{} x 和 y 都是 str 对象，值相同，占用同一块内存。}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{314009096L}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} b = a[:]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{314011080L}
\PYG{g+go}{\PYGZsh{}\PYGZsh{} a 和 b 的 id 不同，尽管值相同。因此 list 不能作为 key。}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/08_basicType:id5}}\begin{enumerate}
\item {} 
Python基本数据类型

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/littlefivebolg/p/8982889.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
切片python字符串时 为何不会引起下标越界?

\end{enumerate}
\begin{quote}

\sphinxurl{https://segmentfault.com/q/1010000011412371}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
python中defaultdict方法的使用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/dancesir/p/8142775.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
python的复制，深拷贝和浅拷贝的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/xueli/p/4952063.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Python学习日记之字典深复制与浅复制

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/mokero/p/6662202.html}
\end{quote}


\section{random}
\label{\detokenize{python/09_random:random}}\label{\detokenize{python/09_random::doc}}

\subsection{random}
\label{\detokenize{python/09_random:id1}}
python自带的random库。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{random.random()}
\begin{itemize}
\item {} 
生成0\textasciitilde{}1的随机浮点数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.uniform(a,b)}
\begin{itemize}
\item {} 
生成指定范围{[}a, b{]}内的随机浮点数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.randint(a,b)}
\begin{itemize}
\item {} 
生成指定范围{[}a, b{]}内的随机整数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.randrange(start,stop,step)}
\begin{itemize}
\item {} 
指定范围内，按step递增的集合中的随机数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.choice(lst)}
\begin{itemize}
\item {} 
给定的集合中选择一个元素。

\end{itemize}

\item {} 
\sphinxstylestrong{random.shuffle(lst)}
\begin{itemize}
\item {} 
对一个序列或者元组随机打乱。

\end{itemize}

\end{itemize}


\subsection{numpy.random}
\label{\detokenize{python/09_random:numpy-random}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{numpy.random.random({[}} \(d_0, d_1, ... ,d_n\) \sphinxstylestrong{{]})}
\begin{itemize}
\item {} 
生成0\textasciitilde{}1的随机浮点数，维度为 \(d_0 \times d_1 \times ... \times d_n\) （缺省为1）。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.rand(} \(d_0, d_1, ... ,d_n\) \sphinxstylestrong{)}
\begin{itemize}
\item {} 
生成0\textasciitilde{}1的随机浮点数，维度为 \(d_0 \times d_1 \times ... \times d_n\) （缺省为1）。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.randn(} \(d_0, d_1, ... ,d_n\) \sphinxstylestrong{)}
\begin{itemize}
\item {} 
标准正态分布。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.randint(low, high=None, size=None, dtype=’l’)}
\begin{itemize}
\item {} 
返回随机的整数，位于半开区间 {[}low, high)。如果high=None，区间为{[}0, low)。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.choice(arr, size=None, replace=True, p=None)}
\begin{itemize}
\item {} 
从一个给定的一维数组，按概率p抽样一定数量的元素，replace=True表示允许重复元素。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.shuffle(arr)}
\begin{itemize}
\item {} 
随机打乱arr。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.permutation(arr)}
\begin{itemize}
\item {} 
返回一个随机排列。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.seed(n)}
\begin{itemize}
\item {} 
改变随机数生成器的种子。设置相同的seed，每次生成的随机数相同；如果不设置seed，则每次会生成不同的随机数。

\end{itemize}

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 注：生成的数组都是 numpy array 类型}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{2.5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{3}
\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.52410303}  \PYG{l+m+mf}{1.68461615} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.04895917}  \PYG{l+m+mf}{2.81907944}\PYG{p}{]}
 \PYG{p}{[} \PYG{l+m+mf}{6.89754303}  \PYG{l+m+mf}{2.95949232}  \PYG{l+m+mf}{1.85296809}  \PYG{l+m+mf}{1.56361545}\PYG{p}{]}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{]}
 \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 从 np.arange(4) 选取 3 个元素}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{9} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{3}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{shuffle}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{arr}
\PYG{p}{[}\PYG{l+m+mi}{6} \PYG{l+m+mi}{9} \PYG{l+m+mi}{0} \PYG{l+m+mi}{8} \PYG{l+m+mi}{1} \PYG{l+m+mi}{7} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{5} \PYG{l+m+mi}{8} \PYG{l+m+mi}{9} \PYG{l+m+mi}{7} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{6} \PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{[} \PYG{l+m+mi}{9}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{4} \PYG{l+m+mi}{12} \PYG{l+m+mi}{15}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}
\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5}\PYG{p}{]}
 \PYG{p}{[}\PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{l+m+mi}{8}\PYG{p}{]}
 \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{0.417022004702574}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{0.417022004702574}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{0.7203244934421581}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/09_random:id2}}\begin{enumerate}
\item {} 
random与numpy.random

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/36a4bbb5536e}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
numpy的random模块详细解析

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/zuoshoushizi/p/8727773.html}
\end{quote}


\section{归一化}
\label{\detokenize{python/10_normalize::doc}}\label{\detokenize{python/10_normalize:id1}}

\subsection{numpy.linalg.norm}
\label{\detokenize{python/10_normalize:numpy-linalg-norm}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n+nb}{ord}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{sklearn.preprocessing.normalize}
\label{\detokenize{python/10_normalize:sklearn-preprocessing-normalize}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sklearn.preprocessing.normalize(X, norm=’l2’, axis=1, copy=True, return\PYGZus{}norm=False)
\end{sphinxVerbatim}


\subsection{torch.nn.functional.normalize}
\label{\detokenize{python/10_normalize:torch-nn-functional-normalize}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{torch}\PYG{o}{.}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{functional}\PYG{o}{.}\PYG{n}{normalize}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{dim}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{eps}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}12}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy.linalg} \PYG{k+kn}{as} \PYG{n+nn}{la}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{arr}
\PYG{g+go}{[[ 2.  1.  2.]}
\PYG{g+go}{ [ 2.  1.  1.]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{norm} \PYG{o}{=} \PYG{n}{la}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{norm}
\PYG{g+go}{[[ 2.82842708  1.41421354  2.23606801]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{arr} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tile}\PYG{p}{(}\PYG{n}{norm}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[[ 0.70710677  0.70710677  0.89442718]}
\PYG{g+go}{ [ 0.70710677  0.70710677  0.44721359]]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{n}{preprocessing}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{preprocessing}\PYG{o}{.}\PYG{n}{normalize}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{norm}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[[ 0.70710677  0.70710677  0.89442718]}
\PYG{g+go}{ [ 0.70710677  0.70710677  0.44721359]]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{torch.nn.functional} \PYG{k+kn}{as} \PYG{n+nn}{F}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{F}\PYG{o}{.}\PYG{n}{normalize}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{from\PYGZus{}numpy}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{dim}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{0.7071  0.7071  0.8944}
\PYG{g+go}{0.7071  0.7071  0.4472}
\PYG{g+go}{[torch.FloatTensor of size 2x3]}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/10_normalize:id2}}\begin{enumerate}
\item {} 
numpy.linalg.norm

\end{enumerate}
\begin{quote}

\sphinxurl{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.linalg.norm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
sklearn.preprocessing.normalize

\end{enumerate}
\begin{quote}

\sphinxurl{https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
torch.nn.functional.normalize

\end{enumerate}
\begin{quote}

\sphinxurl{https://pytorch.org/docs/0.3.0/nn.html?highlight=normalize\#torch.nn.functional.normalize}
\end{quote}


\section{常用数据结构}
\label{\detokenize{python/11_dataStruct::doc}}\label{\detokenize{python/11_dataStruct:id1}}

\subsection{栈}
\label{\detokenize{python/11_dataStruct:id2}}
\sphinxstylestrong{list} 的 \sphinxcode{\sphinxupquote{append()}} 和 \sphinxcode{\sphinxupquote{pop()}} 方法使得list类型可以作为简单的栈使用。


\subsection{队列}
\label{\detokenize{python/11_dataStruct:id3}}

\subsubsection{Queue}
\label{\detokenize{python/11_dataStruct:queue}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Queue}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
FIFO

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Queue.Queue(maxsize=0)
先进先出。
maxsize指明了队列中能存放的数据个数的上限。
一旦达到上限，插入会导致阻塞，直到队列中的数据被消费掉。
如果maxsize小于或者等于0，队列大小没有限制。
\end{sphinxVerbatim}

\item {} 
LIFO

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Queue.LifoQueue(maxsize=0)
后进先出，类似于栈。
\end{sphinxVerbatim}

\item {} 
Priority

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Queue.PriorityQueue(maxsize=0)
优先队列。
一般使用tuple（优先级+数据）作为队列元素，优先级为tuple的第一项。
默认sorted(list(entries))[0])，即tuple第一项越小，优先级越高，越先出队列。
\end{sphinxVerbatim}

\end{itemize}

插入元素

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} que is an initialization of Queue}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
\end{sphinxVerbatim}

弹出并返回元素

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{item} \PYG{o}{=} \PYG{n}{que}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

判断是否为空

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{que}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

队列大小

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{que}\PYG{o}{.}\PYG{n}{qsize}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{Queue} \PYG{k+kn}{import} \PYG{n}{PriorityQueue}
\PYG{n}{que} \PYG{o}{=} \PYG{n}{PriorityQueue}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{app}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{que}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{que}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{que}\PYG{o}{.}\PYG{n}{qsize}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} print result}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} (1, \PYGZsq{}apple\PYGZsq{}) 2}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} (5, \PYGZsq{}banana\PYGZsq{}) 1}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} (10, \PYGZsq{}app\PYGZsq{}) 0}
\end{sphinxVerbatim}


\subsubsection{deque}
\label{\detokenize{python/11_dataStruct:deque}}
double-ended queue，双端队列。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k}{import} \PYG{n}{deque}
\end{sphinxVerbatim}
\begin{description}
\item[{方法：}] \leavevmode\begin{itemize}
\item {} 
append(), appendleft()

\item {} 
pop(), popleft()

\item {} 
extend(), extendleft()

\item {} 
reverse()

\item {} 
rotate()

\item {} 
count()

\item {} 
clear()

\end{itemize}

\end{description}

例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([0, 1, 2, 3, 4])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} right\PYGZhy{}shift}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([4, 0, 1, 2, 3])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([1, 2, 3, 4, 0])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} left\PYGZhy{}shift}
\PYG{g+go}{deque([4, 0, 1, 2, 3])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([3, 2, 1, 0, 4])}
\end{sphinxVerbatim}


\subsection{堆}
\label{\detokenize{python/11_dataStruct:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{heapq}
\end{sphinxVerbatim}

heapq创建的是 \sphinxstylestrong{小顶堆} ，堆顶元素是堆的最小元素。


\subsubsection{创建堆}
\label{\detokenize{python/11_dataStruct:id5}}\begin{itemize}
\item {} 
\sphinxstylestrong{heappush()}

基于空列表{[}{]}，使用 \sphinxcode{\sphinxupquote{heappush()}} 把元素逐个插入堆中。 \sphinxcode{\sphinxupquote{heappop(h)}} 弹出并返回堆顶元素。h{[}0{]}是最小值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{heapsort}\PYG{p}{(}\PYG{n}{iterable}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{iterable}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappush}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{p}{[}\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 不能直接返回 h}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapsort}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{heapify(list\_x)}

把列表转换为堆，in-place，线性时间。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{132}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heapify}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{h}
\PYG{g+go}{[1, 2, 5, 3, 54, 23, 132] \PYGZsh{}\PYGZsh{} h 是堆，但是h不一定是有序的，只能保证 h[0] 是最小值。}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{p}{[}\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{[1, 2, 3, 5, 23, 54, 132]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{merge}

合并多个排序后的序列，返回排序后的序列的迭代器。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{132}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{656}\PYG{p}{,} \PYG{l+m+mi}{324}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h1} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{h1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h2} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{h2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{merge}\PYG{p}{(}\PYG{n}{h1}\PYG{p}{,} \PYG{n}{h2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}type \PYGZsq{}generator\PYGZsq{}\PYGZgt{} [2, 3, 5, 12, 23, 23, 23, 32, 34, 54, 54, 132, 324, 656]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{heapreplace}

删除堆中最小元素，并插入新的元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{132}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heapify}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heapreplace}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{p}{[}\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{[5, 9, 23, 32, 34, 54, 132]}
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{获取最值}
\label{\detokenize{python/11_dataStruct:id6}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nlargest}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{iterable}\PYG{p}{[}\PYG{p}{,} \PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nsmallest}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{iterable}\PYG{p}{[}\PYG{p}{,} \PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

返回一个长度为n的列表，包含数据中的前n个最大/最小的元素。使用key定义排序关键字。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nums} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nlargest}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}
\PYG{g+go}{[5, 4, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nsmallest}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}
\PYG{g+go}{[1, 2, 3]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info} \PYG{o}{=} \PYG{p}{[}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IBM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{91.1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{AAPL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{543.22}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FB}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{21.09}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HPQ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{31.75}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{YHOO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{16.35}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ACME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{115.65}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{... }\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cheap} \PYG{o}{=} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nsmallest}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{info}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{n}{x}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{expensive} \PYG{o}{=} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nlargest}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{info}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{n}{x}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{cheap}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}price\PYGZsq{}: 16.35, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}YHOO\PYGZsq{}\PYGZcb{}, \PYGZob{}\PYGZsq{}price\PYGZsq{}: 21.09, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}FB\PYGZsq{}\PYGZcb{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{expensive}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}price\PYGZsq{}: 543.22, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}AAPL\PYGZsq{}\PYGZcb{}, \PYGZob{}\PYGZsq{}price\PYGZsq{}: 115.65, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}ACME\PYGZsq{}\PYGZcb{}]}
\end{sphinxVerbatim}


\subsubsection{大顶堆}
\label{\detokenize{python/11_dataStruct:id7}}
heapq默认创建小顶堆，为了创建大顶堆，有以下trick:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappush}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 插入 x}
\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 弹出堆顶元素}
\end{sphinxVerbatim}


\subsubsection{数列前K大的数}
\label{\detokenize{python/11_dataStruct:k}}
Hint：建立大小为K的小顶堆，对后续所有数进行遍历：如果大于堆顶元素，则有可能是前K大的数，堆顶元素弹出，插入该数。
时间复杂度 \(\mathcal{O}(NlogK)\)。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{heapq} \PYG{k+kn}{as} \PYG{n+nn}{hq}

\PYG{k}{class} \PYG{n+nc}{TopKHeap}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{k} \PYG{o}{=} \PYG{n}{k}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

  \PYG{k}{def} \PYG{n+nf}{push}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{k}\PYG{p}{:}
      \PYG{n}{hq}\PYG{o}{.}\PYG{n}{heappush}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
      \PYG{n}{min\PYGZus{}number} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
      \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{n}{min\PYGZus{}number}\PYG{p}{:}
        \PYG{n}{hq}\PYG{o}{.}\PYG{n}{heapreplace}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}

  \PYG{k}{def} \PYG{n+nf}{topk}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{reversed}\PYG{p}{(}\PYG{p}{[}\PYG{n}{hq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{nums} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
  \PYG{n}{tkh} \PYG{o}{=} \PYG{n}{TopKHeap}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{nums}\PYG{p}{:}
    \PYG{n}{tkh}\PYG{o}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
  \PYG{k}{print} \PYG{n}{tkh}\PYG{o}{.}\PYG{n}{topk}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} [9, 8, 7]}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
  \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{计数器}
\label{\detokenize{python/11_dataStruct:id8}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k}{import} \PYG{n}{Counter}
\end{sphinxVerbatim}

Counter用于统计频率。属性与字典类似，有keys()，values()，items()等。

\begin{sphinxadmonition}{note}{Note:}
Counter统计之后并不一定是按照频率从高到低排列的。
\end{sphinxadmonition}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 空计数器}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{word} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{cnt}\PYG{p}{[}\PYG{n}{word}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}blue\PYGZsq{}: 3, \PYGZsq{}red\PYGZsq{}: 2, \PYGZsq{}green\PYGZsq{}: 1\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}blue\PYGZsq{}: 3, \PYGZsq{}red\PYGZsq{}: 2, \PYGZsq{}green\PYGZsq{}: 1\PYGZcb{})}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt}\PYG{o}{.}\PYG{n}{most\PYGZus{}common}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 返回出现频率最高的两个元素}
\PYG{g+go}{[(\PYGZsq{}blue\PYGZsq{}, 3), (\PYGZsq{}red\PYGZsq{}, 2)]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gallahad}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}a\PYGZsq{}: 3, \PYGZsq{}l\PYGZsq{}: 2, \PYGZsq{}h\PYGZsq{}: 1, \PYGZsq{}g\PYGZsq{}: 1, \PYGZsq{}d\PYGZsq{}: 1\PYGZcb{})}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}blue\PYGZsq{}: 12, \PYGZsq{}red\PYGZsq{}: 4\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 访问不存在关键字, 可使用 c.get(\PYGZsq{}green\PYGZsq{})}
\PYG{g+go}{0}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/11_dataStruct:id9}}\begin{enumerate}
\item {} 
python中的Queue(队列)详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/wdliu/p/6905396.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Python collections使用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/f2a429aa5963}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Python标准库模块之heapq

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/801318c77ab5}

\sphinxurl{https://docs.python.org/2/library/heapq.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
python使用heapq实现小顶堆（TopK大）/大顶堆（BtmK小）

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/tanghaiyu777/article/details/55271004}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Counter

\end{enumerate}
\begin{quote}

\sphinxurl{https://docs.python.org/2/library/collections.html?highlight=counter}
\end{quote}


\chapter{Linux/Shell}
\label{\detokenize{linux/index:linux-shell}}\label{\detokenize{linux/index::doc}}

\section{基本命令}
\label{\detokenize{linux/01_basic::doc}}\label{\detokenize{linux/01_basic:id1}}

\subsection{文件和目录}
\label{\detokenize{linux/01_basic:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} ..
\PYG{n+nb}{pwd}
ls \PYGZhy{}a \PYGZhy{}F \PYGZhy{}R \PYGZhy{}l

cp \PYG{o}{[}\PYGZhy{}i\PYG{o}{]} src dst
cp \PYGZhy{}R

mv src des
rm \PYGZhy{}i \PYGZhy{}r \PYGZhy{}f folder

touch new \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 创建新文件或修改文件时间属性}

mkdir new
rmdir new

file my\PYGZus{}file \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 查看文件类型}

cat \PYGZhy{}n log.txt
tail log.txt
head \PYGZhy{}5 log.txt

wc file \PYGZhy{}c \PYGZhy{}w \PYGZhy{}l
\end{sphinxVerbatim}


\subsection{磁盘空间}
\label{\detokenize{linux/01_basic:id3}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
df \PYGZhy{}h
du \PYG{o}{[}\PYGZhy{}s\PYG{o}{]} \PYGZhy{}h
\end{sphinxVerbatim}


\subsection{处理数据文件}
\label{\detokenize{linux/01_basic:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sort \PYG{o}{[}\PYGZhy{}n\PYG{o}{]} log.txt \PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}n : 行号}

grep \PYG{o}{[}\PYGZhy{}n\PYG{o}{]} \PYG{o}{[}\PYGZhy{}c\PYG{o}{]} t file \PYG{c+c1}{\PYGZsh{}\PYGZsh{} find *t* in file}

gzip my*
gunzip myfile.gz

tar \PYGZhy{}cvf test.tar test/
tar \PYGZhy{}xvf test.tar
tar \PYGZhy{}xzvf test.tgz
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{linux/01_basic:id5}}\begin{enumerate}
\item {} 
《Linux命令行与shell脚本编程大全》

\item {} 
每天一个linux命令目录

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/peida/archive/2012/12/05/2803591.html}
\end{quote}


\section{更多指令}
\label{\detokenize{linux/02_more::doc}}\label{\detokenize{linux/02_more:id1}}

\subsection{Debian系PMS}
\label{\detokenize{linux/02_more:debianpms}}
\sphinxstylestrong{PMS} : Package Management System，包管理系统。主要介绍：
\begin{itemize}
\item {} 
\sphinxstylestrong{dpkg}

\item {} 
\sphinxstylestrong{apt-get}

\item {} 
\sphinxstylestrong{apt-cache}

\item {} 
\sphinxstylestrong{aptitude}

\end{itemize}


\subsubsection{dpkg}
\label{\detokenize{linux/02_more:dpkg}}\begin{itemize}
\item {} 
dpkg -L package\_name：列出软件包所安装的所有文件

\item {} 
dpkg -S absolute\_file\_name：查找特定的某个文件属于哪个软件包（使用绝对路径）

\end{itemize}


\subsubsection{apt-get}
\label{\detokenize{linux/02_more:apt-get}}\begin{itemize}
\item {} 
apt-get install package\_name：安装一个新软件包

\item {} 
apt-get remove package\_name：卸载一个已安装的软件包（保留配置文件）

\item {} 
apt-get \textendash{}purge remove package\_name：卸载一个已安装的软件包（删除配置文件）

\item {} 
apt-get clean：删除安装的软件的备份，不过不影响软件的使用。

\item {} 
apt-get update：更新 \sphinxstylestrong{软件包列表}

\item {} 
apt-get upgrade：升级所有已安装的 \sphinxstylestrong{软件包} （upgrade之前先update，确保升级的是最新版本）

\end{itemize}


\subsubsection{apt-cache}
\label{\detokenize{linux/02_more:apt-cache}}\begin{itemize}
\item {} 
apt-cache showpkg package\_name：显示软件包信息

\item {} 
apt-cache policy package\_name：显示软件包是否已经安装、版本号等

\end{itemize}


\subsubsection{aptitude}
\label{\detokenize{linux/02_more:aptitude}}\begin{itemize}
\item {} 
aptitude install package\_name：安装软件包

\item {} 
aptitude remove package\_name：删除软件包

\item {} 
aptitude purge package\_name：删除软件包及其配置文件

\item {} 
aptitude search package\_name：搜索软件包

\item {} 
aptitude show package\_name：显示软件包的详细信息

\item {} 
aptitude clean：删除下载的软件包文件

\item {} 
aptitude autoclean：仅删除过期的软件包文件

\item {} 
aptitude update：更新可用的软件包列表

\item {} 
aptitude upgrade：升级可用的软件包

\end{itemize}


\subsection{tee}
\label{\detokenize{linux/02_more:tee}}
读取标准输入的数据，并将其内容输出成文件。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
tee \PYG{o}{[}\PYGZhy{}ai\PYG{o}{]} \PYG{o}{[}\PYGZhy{}\PYGZhy{}help\PYG{o}{]} \PYG{o}{[}\PYGZhy{}\PYGZhy{}version\PYG{o}{]} \PYG{o}{[}file ...\PYG{o}{]}
\end{sphinxVerbatim}
\begin{description}
\item[{参数}] \leavevmode\begin{itemize}
\item {} 
-a或- -append：追加到既有文件

\item {} 
-i或- -ignore-interrupts：忽略中断信号

\item {} 
- -help：帮助

\item {} 
- -version：版本信息

\end{itemize}

\end{description}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 将用户输入的数据同时保存到 out1 out2}
\PYGZdl{} tee out1 out2
a b c d e f g \PYG{c+c1}{\PYGZsh{} 输入}
a b c d e f g \PYG{c+c1}{\PYGZsh{} 反馈}
\PYGZca{}C            \PYG{c+c1}{\PYGZsh{} 结束输入}
\PYGZdl{} cat out1
a b c d e f g
\PYGZdl{} cat out2
a b c d e f g

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 管道：将屏幕的输出保存到文件}
\PYGZdl{} \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}hello world\PYGZdq{}} \PYG{p}{\textbar{}} tee out
hello world
\PYGZdl{} cat out
hello world

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 把python程序打印到屏幕的内容保存到文件}
\PYGZdl{} python test.py \PYG{p}{\textbar{}} tee out
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{查找}
\label{\detokenize{linux/02_more:id2}}
\sphinxstylestrong{which}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
which \PYG{o}{[}可执行文件...\PYG{o}{]}
\end{sphinxVerbatim}

在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。

\sphinxstylestrong{whereis}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
whereis \PYG{o}{[}\PYGZhy{}bmsu\PYG{o}{]} \PYG{o}{[}\PYGZhy{}BMS \PYGZhy{}f 目录...\PYG{o}{]} \PYG{o}{[}文件...\PYG{o}{]}
\end{sphinxVerbatim}

只能用于程序名的搜索，而且只搜索二进制文件（-b）、帮助说明文件（-m）和源代码文件（-s）。如果省略参数，则返回所有信息。
参数：
\begin{itemize}
\item {} 
-b：定位可执行文件。

\item {} 
-m：定位帮助文件。

\item {} 
-s：定位源代码文件。

\item {} 
-u：搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。

\item {} 
-B：指定搜索可执行文件的路径。

\item {} 
-M：指定搜索帮助文件的路径。

\item {} 
-S：指定搜索源代码文件的路径。

\end{itemize}

\sphinxstylestrong{locate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
locate \PYG{o}{[}\PYGZhy{}d\PYG{o}{]} \PYG{o}{[}\PYGZhy{}\PYGZhy{}help\PYG{o}{]} \PYG{o}{[}\PYGZhy{}\PYGZhy{}version\PYG{o}{]} \PYG{o}{[}范本样式...\PYG{o}{]}
\end{sphinxVerbatim}

配合数据库查找文件位置。参数：
\begin{itemize}
\item {} 
-d：配置locate指令使用的数据库。locate指令预设的数据库位于/var/lib/slocate目录里，文档名为slocate.db。

\end{itemize}

\sphinxstylestrong{find}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
find pathname \PYGZhy{}options \PYG{o}{[}\PYGZhy{}print \PYGZhy{}exec \PYGZhy{}ok ...\PYG{o}{]}
\end{sphinxVerbatim}

find是在硬盘文件树查找。参数：
\begin{itemize}
\item {} 
pathname：查找的目录。例如用 . 来表示当前目录，用 / 来表示系统根目录。

\item {} 
-name：按照文件名查找文件。

\item {} 
-print：将匹配的文件输出到标准输出。也可以使用 \sphinxcode{\sphinxupquote{\textgreater{}}} 或  \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}}} （追加）写到文件。

\item {} 
-exec：对匹配的文件执行该参数所给出的shell命令。相应命令的形式为 \sphinxcode{\sphinxupquote{'command' \{\} \textbackslash{};}} ，注意 \sphinxcode{\sphinxupquote{\{\}}} 和 \sphinxcode{\sphinxupquote{\textbackslash{};}} 之间的空格。

\item {} 
-ok：和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。

\end{itemize}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} which python
/usr/bin/python

\PYGZdl{} whereis \PYGZhy{}s \PYGZhy{}S /usr/lib \PYGZhy{}f python
python: /usr/lib/python3.5 /usr/lib/python2.7

\PYGZdl{} locate /usr/bin/pytho \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 以 pytho 开头的文件}
/usr/bin/python
/usr/bin/python\PYGZhy{}config
/usr/bin/python2
...

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 查找 /var/log 中扩展名为 .tmp 的文件，并在删除之前询问用户 （y/n）}
\PYGZdl{} find /var/log \PYGZhy{}name \PYG{l+s+s2}{\PYGZdq{}*.tmp\PYGZdq{}} \PYGZhy{}ok rm \PYG{o}{\PYGZob{}}\PYG{o}{\PYGZcb{}} \PYG{l+s+se}{\PYGZbs{};}
\PYGZlt{} rm ... ./t.tmp \PYGZgt{} ? y
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{参考资料}
\label{\detokenize{linux/02_more:id3}}\begin{enumerate}
\item {} 
runoob.com

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.runoob.com/linux/linux-comm-tee.html}

\sphinxurl{https://www.runoob.com/linux/linux-comm-find.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
每天一个linux命令目录

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/peida/archive/2012/12/05/2803591.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
aptitude和apt-get的区别和联系【转，有添加和修改】

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/u010670794/article/details/42520209}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
apt-get update与upgrade的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/42a1850bdcf6}
\end{quote}


\section{权限管理}
\label{\detokenize{linux/03_authority::doc}}\label{\detokenize{linux/03_authority:id1}}

\subsection{文件描述符}
\label{\detokenize{linux/03_authority:id2}}
\sphinxcode{\sphinxupquote{ls -l}} 命令输出的第一个字段就是描述文件和目录权限的编码。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{drwxrwxr}\PYG{o}{\PYGZhy{}}\PYG{n}{x} \PYG{l+m+mi}{13} \PYG{n}{fong} \PYG{n}{fong} \PYG{l+m+mi}{4096} \PYG{l+m+mi}{5}\PYG{n}{月}   \PYG{l+m+mi}{7} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{33} \PYG{n}{source}\PYG{o}{/}
\end{sphinxVerbatim}

该字段的第一个字符代表对象的类型：
\begin{itemize}
\item {} 
-：文件

\item {} 
d：目录

\item {} 
l：链接

\item {} 
c：字符型设备

\item {} 
b：块设备

\item {} 
n：网络设备

\end{itemize}

之后是3组三字符的编码，每一组定义了3种访问权限（若没有某种权限，使用 - 代替）：
\begin{itemize}
\item {} 
r：可读

\item {} 
w：可写

\item {} 
x：可执行

\end{itemize}

\sphinxcode{\sphinxupquote{ls -F}} 能够在可执行文件的文件名后加一个 *，目录后方加 /。

3组权限对应对象的3个安全等级：
\begin{itemize}
\item {} 
对象的属主（登录名fong）

\item {} 
对象的属组（组名fong）

\item {} 
系统其它用户

\end{itemize}


\subsection{默认文件权限}
\label{\detokenize{linux/03_authority:id3}}
\sphinxcode{\sphinxupquote{umask}} 查看默认文件权限，

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} \PYG{n+nb}{umask}
\PYG{l+m}{0002}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 临时修改默认权限 （若要长期生效，把 umask 0022 写进 \PYGZti{}/.bashrc 并 source）}
\PYGZdl{} \PYG{n+nb}{umask} \PYG{l+m}{0022}
\PYGZdl{} \PYG{n+nb}{umask}
\PYG{l+m}{0022}
\end{sphinxVerbatim}

第1位代表粘着位（sticky bit），后3位表示文件或目录对应的umask八进制值（对应3组权限）。


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Linux文件权限码}\label{\detokenize{linux/03_authority:id6}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
权限
&\sphinxstyletheadfamily 
二进制值
&\sphinxstyletheadfamily 
八进制值
\\
\hline
- - -
&
000
&
0
\\
\hline
- - x
&
001
&
1
\\
\hline
- w -
&
010
&
2
\\
\hline
- w x
&
011
&
3
\\
\hline
r - -
&
100
&
4
\\
\hline
r - x
&
101
&
5
\\
\hline
r w -
&
110
&
6
\\
\hline
r w x
&
111
&
7
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

umask值只是 \sphinxstylestrong{掩码} ，屏蔽不想授予的权限，即：真正的权限是用 \sphinxstylestrong{全权限} 值减去umask值。
文件的全权限值是 \sphinxstylestrong{666} ，目录的全权限值是 \sphinxstylestrong{777} 。当umask=0022，文件默认权限是644，目录默认权限是755。


\subsection{改变权限}
\label{\detokenize{linux/03_authority:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chmod} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{cfvR}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{help}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{version}\PYG{p}{]} \PYG{p}{[}\PYG{n}{mode}\PYG{p}{]} \PYG{p}{[}\PYG{n}{file}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
\end{sphinxVerbatim}

参数：
\begin{itemize}
\item {} 
c：若该文件权限确实已经更改，才打印更改动作

\item {} 
f：若该文件权限无法被更改，也不打印错误讯息

\item {} 
v：打印权限变更的详细动作

\item {} 
R：对目前目录下的所有文件与子目录进行相同的权限变更（即以递回的方式逐个变更）

\end{itemize}

mode:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{ugoa}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{p}{]} \PYG{p}{[}\PYG{n}{rwxX}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
u 表示对象的属主，g 表示对象的属组成员，o 表示系统其它用户，a 表示所有用户。

\item {} 
+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。

\item {} 
r 表示可读，w 表示可写，x 表示可执行。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} mkdir \PYG{n+nb}{test}
\PYGZdl{} ls \PYGZhy{}l
drwxr\PYGZhy{}xr\PYGZhy{}x  \PYG{l+m}{2} fong fong \PYG{l+m}{4096} \PYG{l+m}{5}月   \PYG{l+m}{7} \PYG{l+m}{13}:34 test/
\PYGZdl{} chmod \PYGZhy{}v \PYG{l+m}{777} \PYG{n+nb}{test}
mode of \PYG{l+s+s1}{\PYGZsq{}test\PYGZsq{}} changed from \PYG{l+m}{0755} \PYG{o}{(}rwxr\PYGZhy{}xr\PYGZhy{}x\PYG{o}{)} to \PYG{l+m}{0777} \PYG{o}{(}rwxrwxrwx\PYG{o}{)}
\PYGZdl{} chmod \PYGZhy{}v a\PYGZhy{}w \PYG{n+nb}{test}
mode of \PYG{l+s+s1}{\PYGZsq{}test\PYGZsq{}} changed from \PYG{l+m}{0777} \PYG{o}{(}rwxrwxrwx\PYG{o}{)} to \PYG{l+m}{0555} \PYG{o}{(}r\PYGZhy{}xr\PYGZhy{}xr\PYGZhy{}x\PYG{o}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{linux/03_authority:id5}}
1.《Linux命令行与shell脚本编程大全》
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Linux chmod命令

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.runoob.com/linux/linux-comm-chmod.html}
\end{quote}


\chapter{Git}
\label{\detokenize{git/index:git}}\label{\detokenize{git/index::doc}}

\section{本地版本库}
\label{\detokenize{git/01_localRep::doc}}\label{\detokenize{git/01_localRep:id1}}
\sphinxstylestrong{Git} 是目前世界上最先进的分布式版本控制系统。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{01_git-operations}.png}\hspace*{\fill}}

（图片来源：\sphinxurl{http://blog.podrezo.com/git-introduction-for-cvssvntfs-users/}）
\begin{itemize}
\item {} 
\sphinxstylestrong{workspace} ：工作区

\item {} 
\sphinxstylestrong{stage} ：暂存区

\item {} 
\sphinxstylestrong{local repository} ：本地版本库

\item {} 
\sphinxstylestrong{remote repository} ：远程仓库

\end{itemize}


\subsection{本地版本库}
\label{\detokenize{git/01_localRep:id2}}

\subsubsection{创建与修改}
\label{\detokenize{git/01_localRep:id3}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git init}} 把当前目录变为Git可管理的仓库（目录下多了子目录.git/，自动创建的第一个分支master，以及指向master的一个指针叫 \sphinxcode{\sphinxupquote{HEAD}} ）。

\item {} 
\sphinxcode{\sphinxupquote{git add my\_file}} 把文件加入暂存区。

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
git add . ：把工作时的 \sphinxstylestrong{所有变化} 提交到暂存区，包括文件内容 \sphinxstylestrong{修改（modified）} 以及 \sphinxstylestrong{新文件（new）} ，但不包括被删除的文件。

git add -u ：git add - -update，仅监控已经被add的文件（即 \sphinxstylestrong{tracked file} ），他会将被修改的文件提交到暂存区。不会提交新文件（untracked file）。

git add -A ：git add - -all，是上面两个功能的合集。
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git commit -m "add my\_file"}}  提交到本地版本库，并写log。

\item {} 
\sphinxcode{\sphinxupquote{git status}} 查看当前仓库的状态（文件是不是被tracked？修改是不是已经commit？… 等）。

\item {} 
\sphinxcode{\sphinxupquote{git diff}} 查看当前状态和最新的commit之间的不同（修改还没有add），命令可以加具体文件名以查看某个文件的修改。

\item {} 
\sphinxcode{\sphinxupquote{git diff \textless{}版本号，如7ed6b16\textgreater{}}} 查看当前状态和之前某次commit之间的不同。

\item {} 
\sphinxcode{\sphinxupquote{git log}} 查看commit记录。

\item {} 
\sphinxcode{\sphinxupquote{git reflog}} 查看之前每次commit之后的分支状态。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} git reflog
41c873a \PYG{o}{(}HEAD \PYGZhy{}\PYGZgt{} master\PYG{o}{)} HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{0}\PYG{o}{\PYGZcb{}}: commit: update b
3e2b7f2 HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{1}\PYG{o}{\PYGZcb{}}: reset: moving to HEAD
3e2b7f2 HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{2}\PYG{o}{\PYGZcb{}}: commit: update out
7ed6b16 HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{3}\PYG{o}{\PYGZcb{}}: reset: moving to HEAD
7ed6b16 HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{4}\PYG{o}{\PYGZcb{}}: commit: add a
\PYG{l+m}{8337301} HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{5}\PYG{o}{\PYGZcb{}}: commit \PYG{o}{(}initial\PYG{o}{)}: add readme
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{版本管理}
\label{\detokenize{git/01_localRep:id4}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{01_head}.jpg}\hspace*{\fill}}

（图片来源：\sphinxurl{https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576}）

\sphinxstylestrong{HEAD 指针指向当前版本的master分支。}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git checkout -{-} my\_file}} 如果修改或删除了已经commit的内容，这条指令可以丢弃该操作，一键还原。

\item {} 
\sphinxcode{\sphinxupquote{git reset -{-}hard}} 撤销修改，回到上一次commit之后的状态。

\item {} 
\sphinxcode{\sphinxupquote{git reset -{-}hard \textless{}版本号，如7ed6b16\textgreater{}}} 回到某一次commit之后的状态，同时会删除该次commit之后的commit log。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{git/01_localRep:id5}}\begin{enumerate}
\item {} 
Git和Github简单教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/schaepher/p/5561193.html\#reset}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Git教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.liaoxuefeng.com/wiki/896043488029600}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Git使用教程

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/tugenhua0707/p/4050072.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Git操作详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/bestzhang/p/6903338.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
git add -A 和 git add . 的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/skura23/p/5859243.html}
\end{quote}


\section{远程仓库}
\label{\detokenize{git/02_remoteRep::doc}}\label{\detokenize{git/02_remoteRep:id1}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{01_git-operations}.png}\hspace*{\fill}}

（图片来源：\sphinxurl{http://blog.podrezo.com/git-introduction-for-cvssvntfs-users/}）
\begin{itemize}
\item {} 
\sphinxstylestrong{workspace} ：工作区

\item {} 
\sphinxstylestrong{stage} ：暂存区

\item {} 
\sphinxstylestrong{local repository} ：本地版本库

\item {} 
\sphinxstylestrong{remote repository} ：远程仓库

\end{itemize}


\subsection{远程仓库}
\label{\detokenize{git/02_remoteRep:id2}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git clone \textless{}版本库的网址\textgreater{}}} 从远程主机克隆一个版本库。

\item {} 
\sphinxcode{\sphinxupquote{git remote}} 管理主机名，使用参数 -v，可以参看远程主机的网址。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} git remote \PYGZhy{}v
origin  git@github.com:******/******.git \PYG{o}{(}fetch\PYG{o}{)}
origin  git@github.com:******/******.git \PYG{o}{(}push\PYG{o}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 结果表明：当前只有一台远程主机，叫做 origin 。}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{git fetch \textless{}远程主机名\textgreater{}}} 将某个远程主机的更新，全部取回本地。默认情况下，git fetch取回所有分支（branch）的更新。

\item {} 
\sphinxcode{\sphinxupquote{git fetch \textless{}远程主机名\textgreater{} \textless{}分支名\textgreater{}}} 如果只想取回特定分支的更新，可以指定分支名，比如master。

\item {} 
\sphinxcode{\sphinxupquote{git branch}} -r：查看远程分支，-a：查看所有分支（包括本地分支）。

\item {} 
\sphinxcode{\sphinxupquote{git merge origin/master}} 在本地分支上合并远程分支（origin/master）。

\item {} 
\sphinxcode{\sphinxupquote{git pull \textless{}远程主机名\textgreater{} \textless{}远程分支名\textgreater{}:\textless{}本地分支名\textgreater{}}} 取回远程主机某个分支的更新，再与本地的指定分支合并。比如，取回origin主机的next分支，与本地的master分支合并，需要写成 \sphinxcode{\sphinxupquote{git pull origin next:master}} 。如果远程分支是与当前分支合并，可直接写为 \sphinxcode{\sphinxupquote{git pull origin next}} 。等效于fetch+merge： \sphinxcode{\sphinxupquote{git fetch origin}} ， \sphinxcode{\sphinxupquote{git merge origin/next}} 。

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Git Pull Failed: Your local changes would be overwritten by merge. Commit, stash or revert them.
\begin{itemize}
\item {} 
保留未push的本地代码，并把git服务器上的代码pull到本地（本地刚才修改的代码将会被暂时封存起来）。
\begin{itemize}
\item {} 
git stash

\item {} 
git pull origin master（其中origin master表示git的主分支）

\item {} 
… （一些别的操作，直到结束了对pull到本地的代码的操作。例如，push之后。）

\item {} 
git stash pop

\end{itemize}

\item {} 
完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pull。
\begin{itemize}
\item {} 
git reset - -hard

\item {} 
git pull origin master

\end{itemize}

\end{itemize}
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git push \textless{}远程主机名\textgreater{} \textless{}本地分支名\textgreater{}:\textless{}远程分支名\textgreater{}}} 将本地分支的更新，推送到远程主机。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{git/02_remoteRep:id3}}\begin{enumerate}
\item {} 
Git和Github简单教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/schaepher/p/5561193.html\#reset}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Git教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.liaoxuefeng.com/wiki/896043488029600}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Git使用教程

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/tugenhua0707/p/4050072.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Git操作详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/bestzhang/p/6903338.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Git Pull Failed

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/gymaisyl/article/details/84899191}
\end{quote}


\section{分支管理}
\label{\detokenize{git/03_branch::doc}}\label{\detokenize{git/03_branch:id1}}

\subsection{分支管理}
\label{\detokenize{git/03_branch:id2}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git checkout -b dev}} 创建分支dev，并切换到dev分支（此时可以正常add，commit等）。相当于下面两条指令：
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git branch dev}} 创建分支

\item {} 
\sphinxcode{\sphinxupquote{git checkout dev}} 切换分支

\end{itemize}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
dev分支的仓库已经包含了master分支的内容，但是在master分支下，无法看到dev分支新增或修改的内容。
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git branch}} 查看当前分支。

\item {} 
\sphinxcode{\sphinxupquote{git merge dev}} 把dev分支的内容合并到当前分支（如，master分支）。

\item {} 
\sphinxcode{\sphinxupquote{git branch -d dev}} （合并之后）删除dev分支。

\end{itemize}

流程如下（图片来源于 \sphinxhref{https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424}{Git教程 - 廖雪峰的官方网站} ）：

\sphinxstylestrong{1.} 初始状态： \sphinxstylestrong{master} 分支。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{03_master}.png}\hspace*{\fill}}

\sphinxstylestrong{2.} 创建并切换到 \sphinxstylestrong{dev} 分支。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{03_create_branch}.png}\hspace*{\fill}}

\sphinxstylestrong{3.} 更新 \sphinxstylestrong{dev} 分支。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{03_commit_branch}.png}\hspace*{\fill}}

\sphinxstylestrong{4.} 合并 \sphinxstylestrong{dev} 分支到 \sphinxstylestrong{master} 分支。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{03_merge_branch}.png}\hspace*{\fill}}

\sphinxstylestrong{5.} 删除 \sphinxstylestrong{dev} 分支。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{03_delete_branch}.png}\hspace*{\fill}}


\subsection{参考资料}
\label{\detokenize{git/03_branch:id3}}\begin{enumerate}
\item {} 
Git和Github简单教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/schaepher/p/5561193.html\#reset}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Git教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.liaoxuefeng.com/wiki/896043488029600}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Git使用教程

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/tugenhua0707/p/4050072.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Git操作详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/bestzhang/p/6903338.html}
\end{quote}


\chapter{机器学习}
\label{\detokenize{machineLearning/index::doc}}\label{\detokenize{machineLearning/index:id1}}

\section{Logistic Regression}
\label{\detokenize{machineLearning/01_lr:logistic-regression}}\label{\detokenize{machineLearning/01_lr::doc}}
模型：
\begin{equation*}
\begin{split}h_\theta(\mathbf{x}) = g(\theta^\top \mathbf{x}),\\
g(z) = \frac{1}{1+e^{-z}},\\
g^\prime(z) = (1-g(z))g(z) \in (0, 0.25].\end{split}
\end{equation*}
对数损失函数（极大似然）：
\begin{equation*}
\begin{split}\mathcal{l}_\theta = -\frac{1}{m} \sum_{i=1}^m y^{(i)}log\  h_\theta(\mathbf{x}^{(i)}) + (1 - y^{(i)})log(1 - h_\theta(\mathbf{x}^{(i)}))\end{split}
\end{equation*}
虽然使用了sigmoid函数，但该模型仍然是线性分类器，因为即使不经过sigmoid函数也可以得出分类结果（与0比较），sigmoid将其转化为概率。


\subsection{基本假设}
\label{\detokenize{machineLearning/01_lr:id1}}\begin{enumerate}
\item {} 
数据服从伯努利分布， \(y \sim Bernoulli(\phi)\)

\item {} 
样例为正例的概率为 \(\phi=h_\theta(\mathbf{x})\)

\end{enumerate}


\subsection{求解方法}
\label{\detokenize{machineLearning/01_lr:id2}}\begin{description}
\item[{梯度下降}] \leavevmode\begin{itemize}
\item {} 
批梯度下降：全局最优；每次参数更新需要遍历所有样本，计算量大，效率低。

\item {} 
随机梯度下降（SGD）：以高方差频繁更新，能跳到新的、更好的局部最优解；收敛到局部最优的过程更加复杂。

\item {} 
小批量梯度下降：减少了参数更新次数，达到更稳定的收敛结果。

\end{itemize}

\end{description}


\subsection{优缺点}
\label{\detokenize{machineLearning/01_lr:id3}}\begin{description}
\item[{优点}] \leavevmode\begin{itemize}
\item {} 
模型简单，可解释性好，效果不错

\item {} 
训练速度快，资源占用少

\item {} 
直接输出样本的分类概率，便于做阈值划分

\end{itemize}

\item[{缺点}] \leavevmode\begin{itemize}
\item {} 
准确性不高

\item {} 
很难处理数据不平衡问题

\item {} 
只能处理线性问题

\item {} 
逻辑回归本身无法筛选特征

\end{itemize}

\end{description}


\subsection{解析}
\label{\detokenize{machineLearning/01_lr:id4}}\begin{enumerate}
\item {} 
为什么使用极大似然函数作为损失函数？

\end{enumerate}
\begin{itemize}
\item {} 
极大似然：希望最大化每个样本的分类正确概率，样本服从伯努利分布。

\item {} 
将极大似然取对数后就等同于对数损失函数，在LR模型中，这个损失函数使参数更新速度较快：
\begin{equation*}
\begin{split}\theta_j := \theta_j + \alpha \frac{1}{m} \sum_{i=1}^m (y^{(i)} - h_\theta(\mathbf{x}^{(i)}))\mathbf{x}_j^{(i)}\end{split}
\end{equation*}
只与 \(y^{(i)},\mathbf{x}^{(i)}\) 有关，与 \(h_\theta\) 的梯度无关。

\item {} 
为什么不用平方损失函数（多用于线性回归）？在线性回归中，前提假设是 \(y\) 服从正态分布，即 \(y \sim \mathcal{N}(\mu, \sigma^2)\) 。
另外，如果使用平方损失函数， \(\theta\) 更新与 \(h_\theta\) 的梯度有关，而sigmoid函数的梯度在定义域内小于0.25，导致参数更新慢。

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
训练中如何有很多特征高度相关或将某个特征重复100遍，影响如何？

\end{enumerate}
\begin{quote}

如果损失函数收敛，不影响分类结果（每个特征对应的权重 \(\theta_j\) 变为原来的百分之一）。将相关特征去除，使模型具有更好的解释性，也能加快训练速度。
\end{quote}


\subsection{参考资料}
\label{\detokenize{machineLearning/01_lr:id5}}\begin{enumerate}
\item {} 
逻辑回归的常见面试点总结

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/ModifyRong/p/7739955.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
LR逻辑斯回归分析（优缺点）

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/touch\_dream/article/details/79371462}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
logistic 回归（内附推导）

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/894bda167422}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
周志华《机器学习》Page 57 \textendash{} 60。

\end{enumerate}


\section{支持向量机}
\label{\detokenize{machineLearning/02_svm::doc}}\label{\detokenize{machineLearning/02_svm:id1}}
样本空间中任意点到超平面的距离为：
\begin{equation*}
\begin{split}r = \frac{|w^T x + b|}{\| w \|}\end{split}
\end{equation*}
原始问题：
\begin{equation*}
\begin{split}\underset{w,b}{min} \  \frac{1}{2} \left \| w \right \|^2 \\
s.t. \  y_i(w^T x + b) \geqslant 1, i=1,2,...,m\end{split}
\end{equation*}
拉格朗日函数：
\begin{equation*}
\begin{split}L(w,b,\alpha) = \frac{1}{2}w^Tw + \sum_{i=1}^m \alpha_i(1 - y_i(w^T x + b)),\\
\underset{w,b}{min}(\underset{\alpha_i>0}{max}L(w,b,\alpha))\end{split}
\end{equation*}
对偶问题：
\begin{equation*}
\begin{split}\underset{\alpha_i>0}{max}(\underset{w,b}{min}L(w,b,\alpha))\end{split}
\end{equation*}
即：
\begin{equation*}
\begin{split}\underset{\alpha>0}{max} \sum_{i=1}^m\alpha_i - \frac{1}{2} \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j x_i^T x_j,\  w=\sum_{i=1}^m\alpha_i y_i x_i\end{split}
\end{equation*}
KKT条件：
\begin{equation*}
\begin{split}y_i(w^T x + b) \geqslant 1, \\
\sum_{i=1}^m \alpha_i y_i = 0,\\
\alpha_i (1 - y_i(w^T x + b)) = 0.\end{split}
\end{equation*}

\subsection{核函数}
\label{\detokenize{machineLearning/02_svm:id2}}
核函数 \(\mathcal{K}\)
\begin{itemize}
\item {} 
对称半正定。( \(\mathcal{K} \geqslant 0: \forall z,\  z^T\mathcal{K}z \geqslant 0.\) )

\item {} 
主要使用线性核，高斯核（RBF）。

\item {} 
当特征维度高且样本少，不宜使用高斯核，容易过拟合。

\item {} 
当特征维度低，且样本够多，考虑使用高斯核。首先需要特征缩放（归一化）。若 \(\sigma\) 过大，导致特征间差异变小，欠拟合。

\end{itemize}


\subsection{多分类}
\label{\detokenize{machineLearning/02_svm:id3}}\begin{enumerate}
\item {} 
一对一（ \(O(N^2)\) ）

\item {} 
一对多（ \(O(N)\) ）

\item {} 
使用多分类loss

\end{enumerate}


\subsection{SVM库}
\label{\detokenize{machineLearning/02_svm:svm}}
sklearn, libsvm


\subsection{优缺点}
\label{\detokenize{machineLearning/02_svm:id4}}\begin{description}
\item[{优点}] \leavevmode\begin{itemize}
\item {} 
基于结构风险最小化，泛化能力强（自带正则化， \(\left \| w \right \|^2\) ）。

\item {} 
它是凸优化问题，可得到全局最优。

\item {} 
SVM在小样本训练集上可得到比其他方法好的结果。

\item {} 
利用核函数，可借助线性可分问题的求解方法，直接求解对应高维空间的问题。

\end{itemize}

\item[{缺点}] \leavevmode\begin{itemize}
\item {} 
SVM对缺失特征敏感。

\item {} 
如何确定核函数？

\item {} 
求解问题的二次规划，耗时耗存储。

\end{itemize}

\end{description}


\subsection{解析}
\label{\detokenize{machineLearning/02_svm:id5}}\begin{enumerate}
\item {} 
为什么要间隔最大化？

\end{enumerate}
\begin{quote}

最优超平面，解唯一，更加鲁棒。
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
为什么转化为对偶问题？

\end{enumerate}
\begin{itemize}
\item {} 
便于求解（交换 \(\alpha\) 和 \((w,b)\) 位置之后，可直接对 \((w,b)\) 求导）。

\item {} 
解的过程可以引入核函数。

\end{itemize}


\subsection{SVM与LR的异同}
\label{\detokenize{machineLearning/02_svm:svmlr}}
相同点：
\begin{itemize}
\item {} 
都是分类算法。

\item {} 
不考虑核函数，分类面都是线性。

\item {} 
都是监督学习算法。

\item {} 
都是判别模型。（判别模型：KNN，SVM，LR；生成模型：HMM，朴素贝叶斯）

\end{itemize}

不同点：
\begin{itemize}
\item {} 
本质不同：loss function不同

\item {} 
SVM只有支持向量影响模型，LR中每个样本都有作用。

\item {} 
SVM针对线性不可分问题有核函数。

\item {} 
SVM依赖样本间的距离测度，样本特征需要归一化，也就是说SVM基于距离，LR基于概率。

\item {} 
SVM是结构风险最小化算法（在训练误差和模型复杂度之间的折中，防止过拟合，从而达到真实误差最小化）。因为SVM自带正则（ \(\left \| w \right \|^2\) ）。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{machineLearning/02_svm:id6}}\begin{enumerate}
\item {} 
LR与SVM的异同

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/zhizhan/p/5038747.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
核函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/loujiayu/archive/2013/12/19/3481320.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
SVM面试题

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/fa02098bc220}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
SVM的优缺点

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/fengzhizizhizizhizi/article/details/23911699}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
机器学习技法\textendash{}SVM的对偶问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/de882f0fc434}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
周志华《机器学习》Page 121 \textendash{} 124。

\end{enumerate}


\section{主成分分析PCA}
\label{\detokenize{machineLearning/03_pca:pca}}\label{\detokenize{machineLearning/03_pca::doc}}
\sphinxstylestrong{最大可分性} ：样本点到超平面的投影能尽可能分开（投影后样本点方差最大化）。


\subsection{优化目标}
\label{\detokenize{machineLearning/03_pca:id1}}\begin{equation*}
\begin{split}\underset{W}{max} \ tr(W^TXX^TW) \\
s.t. \ W^TW=I. \\
X \in \mathbb{R}^{d \times m}, \\
W \in \mathbb{R}^{d \times d^\prime}, \ d^\prime < d.\end{split}
\end{equation*}

\subsection{求解}
\label{\detokenize{machineLearning/03_pca:id2}}\begin{enumerate}
\item {} 
计算样本的协方差矩阵 \(C = XX^T\) ；

\item {} 
对协方差矩阵做特征值分解（EVD）；

\item {} 
取最大的 \(d^\prime\) 个特征值 \((\lambda_1, \lambda_2,...,\lambda_{d^\prime})\) 对应的特征向量：
\begin{quote}
\begin{equation*}
\begin{split}W = (w_1, w_2,...,w_{d^\prime})\end{split}
\end{equation*}\end{quote}

\end{enumerate}


\subsection{PCA白化}
\label{\detokenize{machineLearning/03_pca:id3}}\begin{description}
\item[{白化的目的是降低输入的冗余性：}] \leavevmode\begin{itemize}
\item {} 
特征之间相关性降低

\item {} 
所有特征具有相同的方差

\end{itemize}

\end{description}
\begin{equation*}
\begin{split}x_{rot} = W^T x, \\
x_{pca\ white, i} \ = \frac{x_{rot, i}}{\sqrt{\lambda_i}}\end{split}
\end{equation*}

\subsection{SVD分解}
\label{\detokenize{machineLearning/03_pca:svd}}\begin{equation*}
\begin{split}A = U \Sigma V^T,\\
A \in \mathbb{R}^{m \times n}, \\
rank(A) = r,\\
U \in \mathbb{R}^{m \times r}, \\
\Sigma \in \mathbb{R}^{r \times r}, \\
V \in \mathbb{R}^{n \times r}\end{split}
\end{equation*}
其中 \(U\) 是 \(AA^T\) 的特征向量矩阵， \(V\) 是 \(A^TA\) 的特征向量矩阵。

当 \(d\) 很大时， \(C=XX^T\) 是很高维的矩阵，计算该矩阵并求特征向量开销大。此时对 \(X\) 做SVD分解，得到 \(U\) 便是
协方差矩阵 \(C\) 的特征向量。


\subsection{参考资料}
\label{\detokenize{machineLearning/03_pca:id4}}\begin{enumerate}
\item {} 
周志华《机器学习》Page 229 \textendash{} 232。

\item {} 
ufldl

\end{enumerate}
\begin{quote}

\sphinxurl{http://ufldl.stanford.edu/wiki/index.php/PCA}
\end{quote}


\chapter{深度学习}
\label{\detokenize{deepLearning/index::doc}}\label{\detokenize{deepLearning/index:id1}}

\section{pytorch的多GPU模式}
\label{\detokenize{deepLearning/01_dataParallel::doc}}\label{\detokenize{deepLearning/01_dataParallel:pytorchgpu}}
\sphinxstylestrong{pytorch} 中可以通过 \sphinxcode{\sphinxupquote{torch.nn.DataParallel}} 切换到多GPU(multi-GPU)模式，有两种使用方式：网络外指定、网络内指定。


\subsection{网络外指定}
\label{\detokenize{deepLearning/01_dataParallel:id1}}
使用方法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} 在GPU上运行}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 使用第0、1、2个GPU，注意设定batch\PYGZus{}size大一些，否则数据不足以跑多GPU}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{parallel}\PYG{o}{.}\PYG{n}{DataParallel}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{device\PYGZus{}ids}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{DataParallel} 只对  \sphinxcode{\sphinxupquote{forward()}} 和 \sphinxcode{\sphinxupquote{backward()}} 有效，直接调用model中自定义的  \sphinxcode{\sphinxupquote{attribute}} 如 \sphinxcode{\sphinxupquote{forward\_1()}} 无效。

另外，在 \sphinxstylestrong{DataParallel} 模式下，引用model的  \sphinxcode{\sphinxupquote{attribute}} 必须采用如下格式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 相比于\PYGZsq{}model.attribute\PYGZsq{}多了\PYGZsq{}module\PYGZsq{}。}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{module}\PYG{o}{.}\PYG{n}{attribute}
\end{sphinxVerbatim}

比如，\sphinxcode{\sphinxupquote{model.module.classifier.parameters()}} 。


\subsection{网络内指定}
\label{\detokenize{deepLearning/01_dataParallel:id2}}
使用方法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} 定义网络结构}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer1} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{227}\PYG{p}{,} \PYG{l+m+mi}{128}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer1} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{DataParallel}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer1}\PYG{p}{,} \PYG{n}{device\PYGZus{}ids}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

在CPU模式下不需要更改代码。


\subsection{参考资料}
\label{\detokenize{deepLearning/01_dataParallel:id3}}\begin{enumerate}
\item {} 
pytorch documentation

\end{enumerate}
\begin{quote}

\sphinxurl{https://pytorch.org/docs/stable/nn.html\#torch.nn.DataParallel}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
网络内指定

\end{enumerate}
\begin{quote}

\sphinxurl{https://ptorch.com/docs/3/parallelism\_tutorial}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
引用attribute

\end{enumerate}
\begin{quote}

\sphinxurl{https://discuss.pytorch.org/t/how-to-reach-model-attributes-wrapped-by-nn-dataparallel/1373}
\end{quote}


\section{激活函数(Activation Function)}
\label{\detokenize{deepLearning/02_activationFunction::doc}}\label{\detokenize{deepLearning/02_activationFunction:activation-function}}
神经网络引入激活函数主要是为了增强网络的非线性，提升网络的拟合能力和学习能力。激活函数有以下几个性质：
\begin{itemize}
\item {} 
非线性

\item {} 
可微性

\item {} 
单调性：保证单层网络是凸函数

\end{itemize}

下面介绍 \sphinxstylestrong{sigmoid} 、\sphinxstylestrong{tanh} 以及 \sphinxstylestrong{ReLU} 。


\subsection{sigmoid}
\label{\detokenize{deepLearning/02_activationFunction:sigmoid}}
\sphinxstylestrong{sigmoid} 函数的数学表达式如下：
\begin{equation*}
\begin{split}\sigma(z) = \frac{1}{1 + e^{-z}}.\end{split}
\end{equation*}
其导数具有如下性质：
\begin{equation*}
\begin{split}\sigma^\prime(z) = \sigma(z)(1-\sigma(z)).\end{split}
\end{equation*}
\sphinxstylestrong{sigmoid} 函数能够把输入的连续值压缩到(0, 1)范围内，其函数曲线如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_sigmoid}.jpeg}\hspace*{\fill}}

优点：
\begin{itemize}
\item {} 
单调连续，输出范围有限，优化稳定

\item {} 
求导容易

\end{itemize}

缺点：
\begin{itemize}
\item {} 
容易饱和。当输入很大、很小时(saturation, 饱和)，神经元的梯度接近0，出现“梯度消失”(gradient vanishing)，导致无法完成深层网络的训练。

\item {} 
输出不是零均值的(not zero-centered)。假设某个神经元的输入一直是正的，即 \(x>0\) . 对于 \(f(x)=w^Tx+b\) ，则 \(w\) 获得的梯度将是恒正或者恒负
（取决于 \(f\) 得到的梯度的符号），导致 \(w\) 的更新非常“曲折”(zig-zagging)。
当然，如果是按batch训练，最终梯度是各个样本下梯度的和，而每个样本下的梯度可能是符号各异的，因此在一定程度上可以缓解这个问题。

\end{itemize}


\subsection{tanh}
\label{\detokenize{deepLearning/02_activationFunction:tanh}}
\sphinxstylestrong{tanh} 函数的数学表达式如下：
\begin{align*}\!\begin{aligned}
tanh(z) = \frac{e^z-e^{-z}}{e^z+e^{-z}},\\
tanh(z) = 2\sigma(2z)-1.\\
\end{aligned}\end{align*}
其函数曲线如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_tanh}.jpeg}\hspace*{\fill}}

与 \sphinxstylestrong{sigmoid} 一样， \sphinxstylestrong{tanh} 也会产生饱和现象，但是 \sphinxstylestrong{tanh} 的输出是零均值的(zero-centered)。


\subsection{ReLU}
\label{\detokenize{deepLearning/02_activationFunction:relu}}
\sphinxstylestrong{ReLU} 函数的数学表达式如下：
\begin{equation*}
\begin{split}relu(z) = max(0,z).\end{split}
\end{equation*}
其函数曲线如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_relu}.jpeg}\hspace*{\fill}}

优点：
\begin{itemize}
\item {} 
计算简单。 \sphinxstylestrong{sigmoid} 和 \sphinxstylestrong{tanh} 都需要计算指数。

\item {} 
收敛速度快。 \sphinxhref{http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf}{Krizhevsky et al. 论文} 指出 \sphinxstylestrong{ReLU} 收敛速度比 \sphinxstylestrong{tanh} 快6倍。
\begin{quote}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_alexplot}.jpeg}\hspace*{\fill}}
\end{quote}

\end{itemize}

缺点:
\begin{itemize}
\item {} 
容易产生死亡节点(dead ReLU)。一个非常大的梯度流过一个 \sphinxstylestrong{ReLU} 神经元，更新过参数之后，这个神经元对很多输入数据都输出0，则梯度一直为0。
当然 \sphinxstylestrong{ReLU} 的输出依靠 \(w\) 和 \(x\) 的共同作用，死亡节点可能会被重新激活。

\end{itemize}

\sphinxstylestrong{LeakyReLU} 可以有效应对上述缺点。


\subsection{参考资料}
\label{\detokenize{deepLearning/02_activationFunction:id1}}\begin{enumerate}
\item {} 
CS231n

\end{enumerate}
\begin{quote}

\sphinxurl{http://cs231n.github.io/neural-networks-1/\#actfun}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
神经网络之激活函数(Activation Function)

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/memray/article/details/51442059}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
What is the “dying ReLU” problem in neural networks?

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.quora.com/What-is-the-dying-ReLU-problem-in-neural-networks}
\end{quote}


\section{Batch Normalization}
\label{\detokenize{deepLearning/03_batchnorm:batch-normalization}}\label{\detokenize{deepLearning/03_batchnorm::doc}}\begin{equation*}
\begin{split}\hat{x}^{(k)} = \frac{x^{(k)} - E[x^{(k)}]}{\sqrt{Var[x^{{(k)}}] + \epsilon}} \\
y^{(k)} = \gamma^{(k)} \hat{x}^{(k)} + \beta^{(k)}\end{split}
\end{equation*}

\subsection{BN允许更大的学习率}
\label{\detokenize{deepLearning/03_batchnorm:bn}}
由于网络参数不断更新，导致各层输入的分布不断变化，导致往往需要使用较小的学习率，并精心设计参数初始化。

使用BN进行归一化之后，各层输入的分布相同，因此可以使用更大的学习率更快地收敛，并降低网络对初始化的依赖。


\subsection{BN提供了正则化的作用}
\label{\detokenize{deepLearning/03_batchnorm:id1}}
进行BN之后，各样本的feature map已经融合了一个batch之中其他样本的特性（均值，方差），因此单一样本的影响变小，网络更好学习整体的规律
，有效地较小了过拟合的可能性。因此，可以不使用dropout。


\subsection{BN回滚}
\label{\detokenize{deepLearning/03_batchnorm:id2}}
如果网络发现这种normalization是多余的，可以通过学习使得：
\begin{equation*}
\begin{split}\gamma^{(k)} = \sqrt{Var[x^{{(k)}}]} \\
\beta^{(k)} = E[x^{(k)}]\end{split}
\end{equation*}
从而消除BN的作用。


\subsection{缺点}
\label{\detokenize{deepLearning/03_batchnorm:id3}}
BN统计均值、方差与batch size有关，batch size太小会导致性能变差。而某些任务受内存限制，batch size难以设置很大，因此BN作用难以显现。
这时候出现了Group Normalization。


\subsection{参考资料}
\label{\detokenize{deepLearning/03_batchnorm:id4}}\begin{enumerate}
\item {} 
Batch Normalization

\end{enumerate}
\begin{quote}

\sphinxurl{https://arxiv.org/pdf/1502.03167.pdf}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Group Normalization

\end{enumerate}
\begin{quote}

\sphinxurl{http://openaccess.thecvf.com/content\_ECCV\_2018/papers/Yuxin\_Wu\_Group\_Normalization\_ECCV\_2018\_paper.pdf}
\end{quote}


\section{过拟合}
\label{\detokenize{deepLearning/04_overfit::doc}}\label{\detokenize{deepLearning/04_overfit:id1}}
复杂的模型将训练数据的抽样误差考虑在内，对抽样误差也进行了拟合。过拟合的模型可以看成是完全记忆型模型。


\subsection{表现}
\label{\detokenize{deepLearning/04_overfit:id2}}
训练误差小，测试误差大，泛化能力差。


\subsection{原因}
\label{\detokenize{deepLearning/04_overfit:id3}}
训练集大小与模型复杂度不匹配；

样本的噪声太大甚至掩盖了真实样本的分布规律；

训练迭代次数太多（over-training）。


\subsection{解决方案}
\label{\detokenize{deepLearning/04_overfit:id4}}
\sphinxstylestrong{1}. 调小模型复杂度。

\sphinxstylestrong{2}. data augmentation.

\sphinxstylestrong{3}. dropout.

\sphinxstylestrong{4}. early stopping. 记录观察validation accuracy，及时停止训练。

\sphinxstylestrong{5}. 集成学习。Bagging：并行化模型生成，减小模型variance。Boosting：串行化模型生成，减小模型bias。

\sphinxstylestrong{6}. 正则化。
\begin{quote}

\textless{}1\textgreater{}. L0正则化（非0元素个数），难以优化求解（NP-hard）。

\textless{}2\textgreater{}. L1正则化（元素绝对值之和， Lasso regression），是L0范数的最优凸近似，使权值稀疏。权值稀疏的好处：特征选择 \&\& 可解释性。

\textless{}3\textgreater{}. L2正则化（元素平方和，Ridge regression / weight dacay），使权值分布均匀且值较小。
\end{quote}


\section{pytorch模型保存与读取}
\label{\detokenize{deepLearning/05_modelSave:pytorch}}\label{\detokenize{deepLearning/05_modelSave::doc}}

\subsection{简单}
\label{\detokenize{deepLearning/05_modelSave:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} save}
\PYG{n}{torch}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model.pkl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} load}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model.pkl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

这种方法存储的模型包括了模型框架及模型参数，一般存取的pkl文件较大。


\subsection{详细}
\label{\detokenize{deepLearning/05_modelSave:id2}}
模型除了本身的框架、参数信息，还应包括训练的信息，比如训练迭代次数、优化器参数等。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{shutil}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} save}
\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}checkpoint}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{is\PYGZus{}best}\PYG{p}{,} \PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}
  \PYG{n}{torch}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}
  \PYG{k}{if} \PYG{n}{is\PYGZus{}best}\PYG{p}{:}
    \PYG{n}{bestname} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model\PYGZus{}best.pth.tar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{shutil}\PYG{o}{.}\PYG{n}{copyfile}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{bestname}\PYG{p}{)}

\PYG{n}{save\PYGZus{}checkpoint}\PYG{p}{(}\PYG{p}{\PYGZob{}}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{cur\PYGZus{}epoch}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{model}\PYG{o}{.}\PYG{n}{state\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{best\PYGZus{}prec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{best\PYGZus{}prec}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss\PYGZus{}train}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{loss\PYGZus{}train}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{optimizer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{state\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
      \PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{is\PYGZus{}best}\PYG{p}{,} \PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch\PYGZhy{}\PYGZob{}\PYGZcb{}\PYGZus{}checkpoint.pth.tar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{cur\PYGZus{}epoch}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} load}
\PYG{k}{def} \PYG{n+nf}{load\PYGZus{}checkpoint}\PYG{p}{(}\PYG{n}{checkpoint}\PYG{p}{,} \PYG{n}{model}\PYG{p}{,} \PYG{n}{optimizer}\PYG{p}{)}\PYG{p}{:}
  \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} loads state into model and optimizer and returns:}
\PYG{l+s+sd}{      epoch, best\PYGZus{}precision, loss\PYGZus{}train[]}
\PYG{l+s+sd}{      e.g., model = alexnet(pretrained=False)}
\PYG{l+s+sd}{  \PYGZdq{}\PYGZdq{}\PYGZdq{}}
  \PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{isfile}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=\PYGZgt{} loading checkpoint }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}\PYG{p}{)}
      \PYG{n}{checkpoint} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}
      \PYG{n}{epoch} \PYG{o}{=} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{best\PYGZus{}prec} \PYG{o}{=} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{best\PYGZus{}prec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{loss\PYGZus{}train} \PYG{o}{=} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss\PYGZus{}train}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{model}\PYG{o}{.}\PYG{n}{load\PYGZus{}state\PYGZus{}dict}\PYG{p}{(}\PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
      \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{load\PYGZus{}state\PYGZus{}dict}\PYG{p}{(}\PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{optimizer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
      \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=\PYGZgt{} loaded checkpoint }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ (epoch \PYGZob{}\PYGZcb{})}\PYG{l+s+s2}{\PYGZdq{}}
            \PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{epoch}\PYG{p}{,} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
      \PYG{k}{return} \PYG{n}{epoch}\PYG{p}{,} \PYG{n}{best\PYGZus{}prec}\PYG{p}{,} \PYG{n}{loss\PYGZus{}train}
  \PYG{k}{else}\PYG{p}{:}
      \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=\PYGZgt{} no checkpoint found at }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}\PYG{p}{)}
      \PYG{c+c1}{\PYGZsh{} epoch, best\PYGZus{}precision, loss\PYGZus{}train}
      \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{load部分参数}
\label{\detokenize{deepLearning/05_modelSave:load}}
当我们只需要从 \sphinxcode{\sphinxupquote{state\_dict()}} load部分模型参数是，可以采用如下方法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} args has the model name, num classes and other irrelevant stuff}
\PYG{n}{pretrained\PYGZus{}state} \PYG{o}{=} \PYG{n}{model\PYGZus{}zoo}\PYG{o}{.}\PYG{n}{load\PYGZus{}url}\PYG{p}{(}\PYG{n}{model\PYGZus{}names}\PYG{p}{[}\PYG{n}{args}\PYG{o}{.}\PYG{n}{arch}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{model\PYGZus{}state} \PYG{o}{=} \PYG{n}{my\PYGZus{}model}\PYG{o}{.}\PYG{n}{state\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{pretrained\PYGZus{}state} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{n}{k}\PYG{p}{:}\PYG{n}{v} \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{pretrained\PYGZus{}state}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{(}\PYG{p}{)} \PYG{k}{if} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{model\PYGZus{}state} \PYG{o+ow}{and} \PYG{n}{v}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{model\PYGZus{}state}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZcb{}}
\PYG{n}{model\PYGZus{}state}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{pretrained\PYGZus{}state}\PYG{p}{)}
\PYG{n}{my\PYGZus{}model}\PYG{o}{.}\PYG{n}{load\PYGZus{}state\PYGZus{}dict}\PYG{p}{(}\PYG{n}{model\PYGZus{}state}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{deepLearning/05_modelSave:id3}}\begin{enumerate}
\item {} 
Saving and loading a model in Pytorch?

\end{enumerate}
\begin{quote}

\sphinxurl{https://discuss.pytorch.org/t/saving-and-loading-a-model-in-pytorch/2610}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
How to load part of pre trained model?

\end{enumerate}
\begin{quote}

\sphinxurl{https://discuss.pytorch.org/t/how-to-load-part-of-pre-trained-model/1113/8}
\end{quote}


\section{pytorch: cuda()}
\label{\detokenize{deepLearning/06_cuda:pytorch-cuda}}\label{\detokenize{deepLearning/06_cuda::doc}}

\subsection{使用指定GPU}
\label{\detokenize{deepLearning/06_cuda:gpu}}\begin{itemize}
\item {} 
\sphinxstylestrong{直接终端中设定}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CUDA\PYGZus{}VISIBLE\PYGZus{}DEVICES}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{python} \PYG{n}{my\PYGZus{}script}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{代码中设定}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{environ}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CUDA\PYGZus{}VISIBLE\PYGZus{}DEVICES}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{使用函数 set\_device}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{n}{torch}\PYG{o}{.}\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{set\PYGZus{}device}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\subsection{cuda()}
\label{\detokenize{deepLearning/06_cuda:cuda}}
对于一个 \sphinxcode{\sphinxupquote{tensor}} 对象，cuda()返回该对象在CUDA内存中的拷贝

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{obj} \PYG{o}{=} \PYG{n}{obj}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

对于一个 \sphinxcode{\sphinxupquote{nn.Module}} 实例，cuda()直接将该模型的参数和buffers转移到GPU。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{deepLearning/06_cuda:id1}}\begin{enumerate}
\item {} 
PyTorch中使用指定的GPU

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/darkknightzh/p/6836568.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
pytorch documentation

\end{enumerate}
\begin{quote}

\sphinxurl{https://pytorch.org/docs/0.3.1/tensors.html?highlight=cuda\#torch.Tensor.cuda}

\sphinxurl{https://pytorch.org/docs/0.3.1/nn.html?highlight=cuda\#torch.nn.Module.cuda}
\end{quote}


\chapter{资源链接}
\label{\detokenize{link/index::doc}}\label{\detokenize{link/index:id1}}

\section{Github Page}
\label{\detokenize{link/index:github-page}}
\sphinxurl{https://fongyq.github.io/}


\section{AnyKnew}
\label{\detokenize{link/index:anyknew}}
\sphinxurl{https://www.anyknew.com/\#/}


\section{arXiv}
\label{\detokenize{link/index:arxiv}}
\sphinxurl{https://arxiv.org/}


\section{Read the Docs}
\label{\detokenize{link/index:read-the-docs}}
\sphinxurl{https://readthedocs.org/}


\section{C++ Reference}
\label{\detokenize{link/index:c-reference}}
\sphinxurl{http://www.cplusplus.com/reference/}


\section{Numpy}
\label{\detokenize{link/index:numpy}}
\sphinxurl{http://cs231n.github.io/python-numpy-tutorial/}


\section{Pytorch}
\label{\detokenize{link/index:pytorch}}
Tutorials: \sphinxurl{https://pytorch.org/tutorials/}

Docs: \sphinxurl{https://pytorch.org/docs/master/index.html}


\section{Jupyter Notebook}
\label{\detokenize{link/index:jupyter-notebook}}
\sphinxurl{https://jupyter.org/}


\section{Standford University Lectures}
\label{\detokenize{link/index:standford-university-lectures}}
CS229: \sphinxurl{http://cs229.stanford.edu/syllabus.html}

CS231: \sphinxurl{http://cs231n.github.io/}


\section{ShareLatex}
\label{\detokenize{link/index:sharelatex}}
\sphinxurl{https://www.sharelatex.com/login}


\section{PlanetB}
\label{\detokenize{link/index:planetb}}
\sphinxurl{http://www.planetb.ca/syntax-highlight-word}


\section{Vision Open Source Library}
\label{\detokenize{link/index:vision-open-source-library}}
检索： \sphinxurl{http://yael.gforge.inria.fr/index.html}

特征： \sphinxurl{http://www.vlfeat.org/index.html}


\section{牛客网}
\label{\detokenize{link/index:id2}}
\sphinxurl{https://www.nowcoder.com/}


\chapter{实用软件}
\label{\detokenize{softwares/index::doc}}\label{\detokenize{softwares/index:id1}}

\section{Listary}
\label{\detokenize{softwares/index:listary}}
\begin{sphinxadmonition}{note}{Note:}
Windows下快速查找文件及应用程序

\sphinxurl{http://www.listary.com/}
\end{sphinxadmonition}


\section{FreeCommander}
\label{\detokenize{softwares/index:freecommander}}
\begin{sphinxadmonition}{note}{Note:}
Windows下的资源管理器

\sphinxurl{https://freecommander.com/en/summary/}
\end{sphinxadmonition}


\section{MobaXterm}
\label{\detokenize{softwares/index:mobaxterm}}
\begin{sphinxadmonition}{note}{Note:}
Windows下连接服务器的终端

\sphinxurl{https://mobaxterm.mobatek.net/}
\end{sphinxadmonition}


\section{TeamViewer}
\label{\detokenize{softwares/index:teamviewer}}
\begin{sphinxadmonition}{note}{Note:}
远程连接

\sphinxurl{https://www.teamviewer.com/zhCN/}
\end{sphinxadmonition}


\section{Notepad++}
\label{\detokenize{softwares/index:notepad}}
\begin{sphinxadmonition}{note}{Note:}
强大的文本阅读/编辑器

\sphinxurl{https://notepad-plus-plus.org/}
\end{sphinxadmonition}


\section{cmder}
\label{\detokenize{softwares/index:cmder}}
\begin{sphinxadmonition}{note}{Note:}
Windows下终端神器

\sphinxurl{https://cmder.net/}
\end{sphinxadmonition}


\chapter{Tech}
\label{\detokenize{tech/index:tech}}\label{\detokenize{tech/index::doc}}

\section{技巧}
\label{\detokenize{tech/index:id1}}\begin{itemize}
\item {} 
怎样安装 Windows 7 与 Linux 的双系统？
\begin{quote}

\sphinxurl{https://www.zhihu.com/question/19867618?sort=created}
\end{quote}

\item {} 
Windows10终端优化方案：Ubuntu子系统+cmder+oh-my-zsh
\begin{quote}

\sphinxurl{https://zhuanlan.zhihu.com/p/34152045}

\sphinxurl{https://www.jianshu.com/p/dc32a75e2de4}
\end{quote}

\item {} 
将DOS格式文本文件转换成UNIX格式
\begin{quote}

\sphinxurl{https://codingstandards.iteye.com/blog/810900}
\end{quote}

\item {} 
加速 git clone
\begin{quote}

\sphinxurl{https://blog.51cto.com/11887934/2051323}

\sphinxurl{https://blog.lizebang.top/2018/02/git-clone-slow/}
\end{quote}

\end{itemize}


\section{问题}
\label{\detokenize{tech/index:id2}}\begin{itemize}
\item {} 
Unable to locate package python-pip
\begin{quote}

\sphinxurl{https://askubuntu.com/questions/268539/unable-to-locate-package-python-pip-on-live-system}
\end{quote}

\end{itemize}


\chapter{其他}
\label{\detokenize{else/index::doc}}\label{\detokenize{else/index:id1}}

\section{复习}
\label{\detokenize{else/01_interview::doc}}\label{\detokenize{else/01_interview:id1}}

\subsection{汇总}
\label{\detokenize{else/01_interview:id2}}\begin{enumerate}
\item {} 
github

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxurl{https://github.com/imhuay/Algorithm\_Interview\_Notes-Chinese}

\item {} 
\sphinxurl{https://github.com/jwasham/coding-interview-university/blob/master/translations/README-cn.md}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
2018校招算法岗面试题汇总

\end{enumerate}
\begin{quote}

\sphinxurl{https://zhuanlan.zhihu.com/p/36801851}
\end{quote}


\subsection{编程算法}
\label{\detokenize{else/01_interview:id3}}\begin{enumerate}
\item {} 
动态规划

\end{enumerate}
\begin{itemize}
\item {} 
有面值1,5,10,20,50,100的人民币，求问10000有多少种组成方法？
\begin{quote}

\sphinxurl{https://www.zhihu.com/question/315108379}
\end{quote}

\item {} 
如何用最少的次数测出鸡蛋会在哪一层摔碎？
\begin{quote}

\sphinxurl{https://www.zhihu.com/question/19690210}
\end{quote}

\item {} 
{[}LeetCode{]} Maximum Product Subarray 求连续子数组的最大乘积
\begin{quote}

\sphinxurl{https://blog.csdn.net/xblog\_/article/details/72872263}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
排序算法之桶排序

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/developer1024/article/details/79770240}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
找出数组中N个出现1（或奇数次）次的数字

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/e1331664c8cf}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
均匀分布生成其他分布的方法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/haolexiao/article/details/60511164}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
海量数据处理

\end{enumerate}
\begin{itemize}
\item {} 
面试题集锦
\begin{quote}

\sphinxurl{https://blog.csdn.net/v\_july\_v/article/details/6685962}
\end{quote}

\item {} 
大文件中返回频数最高的100个词
\begin{quote}

\sphinxurl{https://blog.csdn.net/tiankong\_/article/details/77240283}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
链表

\end{enumerate}
\begin{itemize}
\item {} 
求有环单链表中的环长、环起点、链表长
\begin{quote}

\sphinxurl{https://www.cnblogs.com/xudong-bupt/p/3667729.html}
\end{quote}

\item {} 
判断两个链表是否相交并找出交点
\begin{quote}

\sphinxurl{https://blog.csdn.net/jiary5201314/article/details/50990349}
\end{quote}

\item {} 
单链表O(1)时间删除给定节点
\begin{quote}

\sphinxurl{https://blog.csdn.net/qq\_35546040/article/details/80341136}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
全排列的非递归和递归实现（含重复元素）。Hint：在交换第i个元素与第j个元素之前，要求数组的{[}i, j)区间中的元素没有与第j个元素重复。

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/so\_geili/article/details/71078945}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{7}
\item {} 
排列组合 “n个球放入m个盒子”问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qwb492859377/article/details/50654627?tdsourcetag=s\_pctim\_aiomsg}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{8}
\item {} 
Next Permutation 下一个排列

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/grandyang/p/4428207.html}

\(\color{darkgreen}{Show/Hide\ Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 从后往前先找到第一个开始下降的数字x（下标i），再从后往前找到第一个比x大的数y（下标j）；交换x，y；翻转区间 [i+1, end)。}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{void} \PYG{n}{nextPermutation}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{num}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{n} \PYG{o}{=} \PYG{n}{num}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{num}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{num}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{for} \PYG{p}{(}\PYG{n}{j} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{n}{i}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if} \PYG{p}{(}\PYG{n}{num}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{num}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{swap}\PYG{p}{(}\PYG{n}{num}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{num}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{num}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{num}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{return}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{num}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{num}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 当前排列是最大的排列，则翻转为最小的排列}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{9}
\item {} 
LeetCode 75. Sort Colors（三颜色排序\(\rightarrow\)K颜色排序）

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/princexiexiaofeng/article/details/79645511}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{10}
\item {} 
找到数组第k大的数

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/kth-largest-element-in-an-array/}

\(\color{darkgreen}{Show/Hide\ Code}\)

\fvset{hllines={, 7, 8, 14, 15, 24, 25, 28, 29,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{partition}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{pivot} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{r} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{l}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{j} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{n}{pivot}\PYG{p}{)} \PYG{n}{l}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{r}\PYG{o}{\PYGZgt{}}\PYG{n}{i} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{n}{pivot}\PYG{p}{)} \PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{l}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{r}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
            \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{l}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// partition 可用如下更简洁的形式}
    \PYG{k+kt}{int} \PYG{n}{partition}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{pivot} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{r} \PYG{o}{=} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{o}{+}\PYG{o}{+}\PYG{n}{l}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{n}{pivot} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{l}\PYG{o}{\PYGZlt{}}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{r}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{n}{pivot}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{l}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{r}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
            \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{int} \PYG{n}{quicksort}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{p} \PYG{o}{=} \PYG{n}{partition}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{=}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)} \PYG{k}{return} \PYG{n}{p}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{)} \PYG{k}{return} \PYG{n}{quicksort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{k} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else} \PYG{k}{return} \PYG{n+nf}{quicksort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{p}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{int} \PYG{n}{findKthLargest}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{k\PYGZus{}id} \PYG{o}{=} \PYG{n}{quicksort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k\PYGZus{}id}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{11}
\item {} 
{[}LeetCode{]} Best Time to Buy and Sell Stock 买卖股票的最佳时间

\end{enumerate}
\begin{itemize}
\item {} 
最多一次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4280131.html}
\end{quote}

\item {} 
无限次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4280803.html}
\end{quote}

\item {} 
最多两次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4281975.html}
\end{quote}

\item {} 
最多k次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4295761.html}

\sphinxurl{https://blog.csdn.net/linhuanmars/article/details/23236995}
\end{quote}

\item {} 
交易冷却
\begin{quote}

\sphinxurl{https://www.cnblogs.com/grandyang/p/4997417.html}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{12}
\item {} 
{[}LeetCode{]} Partition Equal Subset Sum 数组分成两个子集，和相等

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/partition-equal-subset-sum/}

\(\color{darkgreen}{Show/Hide\ Code}\)

\fvset{hllines={, 2, 7, 9, 23,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
\PYG{k}{def} \PYG{n+nf}{backtrack}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}current}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} self}
    \PYG{k}{if} \PYG{n}{sum\PYGZus{}current} \PYG{o}{==} \PYG{n}{sum\PYGZus{}nums}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{True}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{False}
    \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{backtrack}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}current}\PYG{o}{+}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} self}
        \PYG{k}{return} \PYG{n+nb+bp}{True}
    \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{backtrack}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}current}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} self}
        \PYG{k}{return} \PYG{n+nb+bp}{True}
    \PYG{k}{return} \PYG{n+nb+bp}{False}

\PYG{k}{def} \PYG{n+nf}{canPartition}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    :type nums: List[int]}
\PYG{l+s+sd}{    :rtype: bool}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{False}
    \PYG{n}{sum\PYGZus{}nums} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{sum\PYGZus{}nums} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{False}
    \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{backtrack}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}nums}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} self}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{13}
\item {} 
{[}LeetCode{]} Find All Anagrams in a String 统计变位词出现的位置。Hint：采用滑动窗口和 \sphinxstylestrong{计数器} 进行比较。

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/find-all-anagrams-in-a-string/}

\(\color{darkgreen}{Show/Hide\ Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/* https://leetcode.com/problems/find\PYGZhy{}all\PYGZhy{}anagrams\PYGZhy{}in\PYGZhy{}a\PYGZhy{}string/discuss/92027/C\PYGZpc{}2B\PYGZpc{}2B\PYGZhy{}O(n)\PYGZhy{}sliding\PYGZhy{}window\PYGZhy{}concise\PYGZhy{}solution\PYGZhy{}with\PYGZhy{}explanation */}

\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{findAnagrams}\PYG{p}{(}\PYG{n}{string} \PYG{n}{s}\PYG{p}{,} \PYG{n}{string} \PYG{n}{p}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{vec}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n}{p}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{k}{return} \PYG{n}{vec}\PYG{p}{;}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{p\PYGZus{}counter}\PYG{p}{(}\PYG{l+m+mi}{26}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s\PYGZus{}counter}\PYG{p}{(}\PYG{l+m+mi}{26}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{o}{+}\PYG{o}{+} \PYG{n}{p\PYGZus{}counter}\PYG{p}{[}\PYG{n}{p}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{;}
            \PYG{o}{+}\PYG{o}{+} \PYG{n}{s\PYGZus{}counter}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{p\PYGZus{}counter} \PYG{o}{=}\PYG{o}{=} \PYG{n}{s\PYGZus{}counter}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{p}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{s\PYGZus{}counter}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{;}
            \PYG{o}{+}\PYG{o}{+} \PYG{n}{s\PYGZus{}counter}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{s\PYGZus{}counter} \PYG{o}{=}\PYG{o}{=} \PYG{n}{p\PYGZus{}counter}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{vec}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

15. {[}LeetCode{]} Find the Duplicate Number 寻找重复数。Hint：把数组元素的值当做下标，由于元素存在重复，因此必然会 \sphinxstylestrong{重复多次访问同一个位置} 。
从另一个角度讲，访问序列中存在“环”。哈希不满足空间复杂度为O(1)的要求。
\begin{quote}
\begin{itemize}
\item {} 
找到一个重复数字。
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4843654.html}
\end{quote}

\end{itemize}

\(\color{darkgreen}{Show/Hide\ Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 解法一：快慢指针，寻找某个“环”的入口}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{findDuplicate}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{slow} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fast} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while} \PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{slow} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{slow}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{fast} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{fast}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{slow} \PYG{o}{=}\PYG{o}{=} \PYG{n}{fast}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{while} \PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{slow} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{slow}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{t} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{slow} \PYG{o}{=}\PYG{o}{=} \PYG{n}{t}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{slow}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// 解法二：不断交换位置，找到第一个重复访问的元素}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{findDuplicate}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{duplicate}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{duplicate} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{;}
                    \PYG{k}{break}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{duplicate}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
找到所有重复数字。
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/6209746.html}
\end{quote}

\end{itemize}

\(\color{darkgreen}{Show/Hide\ Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 解法一：将访问过的元素置为相反数（负数），如果下次访问到一个负数，说明这个元素被重复访问}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{findDuplicates}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{res}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{idx} \PYG{o}{=} \PYG{n}{abs}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{res}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{idx} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{nums}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// 解法二：不断交换位置使得 i == nums[i]\PYGZhy{}1}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{findDisappearedNumbers}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{disappear}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{disappear}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)} \PYG{n}{disappear}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{disappear}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{15}
\item {} 
{[}LeetCode{]} Spiral Matrix 环形打印矩阵

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/spiral-matrix/}

\(\color{darkgreen}{Show/Hide\ Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{void} \PYG{n}{tranverseMatrixAccorindTo4Directions}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{matrix}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{row}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{col}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{start}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{vec}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// 特别注意}
        \PYG{c+c1}{// 如果把 start, endX, endY, k 声明为 unsigned int 类型，在减到 0 的时候可能会死循环，因为 unsigned int 类型不会小于 0。}

        \PYG{k+kt}{int} \PYG{n}{endX} \PYG{o}{=} \PYG{n}{row}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{endY} \PYG{o}{=} \PYG{n}{col}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{;}

        \PYG{c+c1}{// 1 向右}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{start}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{endY}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{start}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// 2 向下}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{start}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{endX}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{n}{endY}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// 3 向左：要求至少存在两行（不加判断会重复扫描同一行）}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{endX} \PYG{o}{\PYGZgt{}} \PYG{n}{start}\PYG{p}{)} \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{endY}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{start}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{endX}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// 4 向上：要求至少存在两列（不加判断会重复扫描同一列）}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{endY} \PYG{o}{\PYGZgt{}} \PYG{n}{start}\PYG{p}{)} \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{endX}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZgt{}} \PYG{n}{start}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{n}{start}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{spiralOrder}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{matrix}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{vec}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{row} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{row} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{n}{vec}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{col} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{col} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{n}{vec}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{start} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{c+c1}{// 循环中止条件：圈数判断（ (start,start) 是每一圈的入口坐标）}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{start}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}} \PYG{n}{row} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{start}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}} \PYG{n}{col}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tranverseMatrixAccorindTo4Directions}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,} \PYG{n}{row}\PYG{p}{,} \PYG{n}{col}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{vec}\PYG{p}{)}\PYG{p}{;}
            \PYG{o}{+}\PYG{o}{+} \PYG{n}{start}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{vec}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{16}
\item {} 
{[}LeetCode{]} Longest Consecutive Sequence 最长连续序列。Hint：方法一，排序；方法二，对于每个元素n，搜索n+1是否在数组中，使用 hash（set）可以获得 O(1) 的查找复杂度。

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/longest-consecutive-sequence/}

\(\color{darkgreen}{Show/Hide\ Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}\PYG{p}{(}\PYG{n}{object}\PYG{p}{)}\PYG{o}{:}
\PYG{n}{def} \PYG{n}{longestConsecutive}\PYG{p}{(}\PYG{n}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}\PYG{o}{:}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}
    \PYG{o}{:}\PYG{n}{type} \PYG{n+nl}{nums}\PYG{p}{:} \PYG{n}{List}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}
    \PYG{o}{:}\PYG{n+nl}{rtype}\PYG{p}{:} \PYG{k+kt}{int}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}

    \PYG{n}{longest} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{num\PYGZus{}set} \PYG{o}{=} \PYG{n}{set}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{num} \PYG{n}{in} \PYG{n+nl}{nums}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{num}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{not} \PYG{n}{in} \PYG{n+nl}{num\PYGZus{}set}\PYG{p}{:}
            \PYG{n}{current\PYGZus{}long} \PYG{o}{=} \PYG{l+m+mi}{1}
            \PYG{k}{while} \PYG{n}{num} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{n}{in} \PYG{n+nl}{num\PYGZus{}set}\PYG{p}{:}
                \PYG{n}{current\PYGZus{}long} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
                \PYG{n}{num} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
            \PYG{n}{longest} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{longest}\PYG{p}{,} \PYG{n}{current\PYGZus{}long}\PYG{p}{)}

    \PYG{n}{num\PYGZus{}set}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{longest}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{17}
\item {} 
最小公约数与最大公倍数。Hint：辗转相除法；最大公倍数等于两数乘积除以最大公约数。

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/Arvin-JIN/p/7247619.html}
\end{quote}


\subsection{C++}
\label{\detokenize{else/01_interview:c}}\begin{enumerate}
\item {} 
虚函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/fighting\_coder/article/details/77187151}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
重载、重写（覆盖）和隐藏的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zx3517288/article/details/48976097}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++ STL中vector内存用尽后，为啥每次是两倍的增长，而不是3倍或其他数值？

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.zhihu.com/question/36538542}
\end{quote}


\subsection{python}
\label{\detokenize{else/01_interview:python}}\begin{enumerate}
\item {} 
基本数据类型

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/littlefivebolg/p/8982889.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Python中的None

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/changbaishan/p/8084863.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
使用lambda高效操作列表的教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/mxp-neu/articles/5316557.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
经典7大Python面试题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qq\_41597912/article/details/81459804}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
迭代器和生成器

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/chongdongxiaoyu/p/9054847.html}
\end{quote}


\subsection{机器学习（深度学习）}
\label{\detokenize{else/01_interview:id4}}\begin{enumerate}
\item {} 
激活函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/deepLearning/02\_activationFunction.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Batch Normalization

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/deepLearning/03\_batchnorm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
过拟合

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/deepLearning/03\_batchnorm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
正则化项L1和L2的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/lyr2015/p/8718104.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
KMeans秘籍之如何确定K值

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/alicelmx/article/details/80991870}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
决策树

\end{enumerate}
\begin{itemize}
\item {} 
ID3、C4.5
\begin{quote}

\sphinxurl{https://www.cnblogs.com/coder2012/p/4508602.html}
\end{quote}

\item {} 
预剪枝与后剪枝
\begin{quote}

\sphinxurl{https://blog.csdn.net/zfan520/article/details/82454814}
\end{quote}

\item {} 
CART分类与回归树
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/b90a9ce05b28}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
Logistic Regression

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/machineLearning/01\_lr.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{7}
\item {} 
Support Vector Machine

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/machineLearning/02\_svm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{8}
\item {} 
PCA

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/machineLearning/03\_pca.html}
\end{quote}


\subsection{论文相关}
\label{\detokenize{else/01_interview:id5}}\begin{enumerate}
\item {} 
AlexNet/VGG/GoogleNet

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/gdymind/article/details/83042729}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
CNN卷积神经网络\_ GoogLeNet 之 Inception(V1-V4)

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/haiyang21/p/7243200.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
R-CNN系列

\end{enumerate}
\begin{itemize}
\item {} 
【RCNN系列】【超详细解析】
\begin{quote}

\sphinxurl{https://blog.csdn.net/amor\_tila/article/details/78809791}
\end{quote}

\item {} 
实例分割模型Mask R-CNN详解：从R-CNN，Fast R-CNN，Faster R-CNN再到Mask R-CNN
\begin{quote}

\sphinxurl{https://blog.csdn.net/jiongnima/article/details/79094159}
\end{quote}

\item {} 
RCNN（三）：Fast R-CNN
\begin{quote}

\sphinxurl{https://blog.csdn.net/u011587569/article/details/52151871}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
CapsuleNet解读

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/u013010889/article/details/78722140/}
\end{quote}


\subsection{其他}
\label{\detokenize{else/01_interview:id6}}\begin{enumerate}
\item {} 
理解数据库的事务，ACID，CAP和一致性

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/2c30d1fe5c4e}
\end{quote}


\section{rst语法}
\label{\detokenize{else/02_test_code:rst}}\label{\detokenize{else/02_test_code::doc}}
\sphinxcode{\sphinxupquote{makefile}} 规则：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{target ... }\PYG{o}{:} \PYG{n}{prerequisites} ...
    \PYG{n+nb}{command}
    ...
    ...
\end{sphinxVerbatim}

下面是几个定义：
\begin{description}
\item[{target}] \leavevmode
可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对
于标签这种特性，在后续的“伪目标”章节中会有叙述。

\item[{prerequisites}] \leavevmode
生成该target所依赖的文件和/或target

\item[{command}] \leavevmode
该target要执行的命令（任意的shell命令）

\end{description}

这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，
其生成规则定义在command中。说白一点就是说:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。
\end{sphinxVerbatim}

这就是 \sphinxcode{\sphinxupquote{makefile}} 的规则，也就是 \sphinxcode{\sphinxupquote{makefile}} 中最核心的内容。

\sphinxcode{\sphinxupquote{echo "Hello World!";}}

行内公式使用 \sphinxcode{\sphinxupquote{math}} 这个 \sphinxcode{\sphinxupquote{role}}: \(a^2 + b^2 = c^2\).
\begin{equation*}
\begin{split}(a + b)^2  &=  (a + b)(a + b) \\
           &=  a^2 + 2ab + b^2\end{split}
\end{equation*}
\sphinxcode{\sphinxupquote{latex}} math测试:
\begin{equation*}
\begin{split}X_k =  \sum_{n=0}^{N-1} x_n e^{-{i 2\pi k \frac{n}{N}}} \qquad k = 0,\dots,N-1.\end{split}
\end{equation*}
将高亮语言设置为 \sphinxcode{\sphinxupquote{C}}

测试 \sphinxcode{\sphinxupquote{C}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{c} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}c}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

这里是 \sphinxcode{\sphinxupquote{C++}} :

\fvset{hllines={, 3, 4, 5,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{;}
  \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{j}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// 主函数注释}
\end{sphinxVerbatim}

斜体 \sphinxtitleref{text}

将高亮语言设置为 \sphinxcode{\sphinxupquote{python}}

测试 \sphinxcode{\sphinxupquote{python}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello world}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

这里是 \sphinxcode{\sphinxupquote{python}} (code):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Love Python, Love FreeDome}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E文标点,.0123456789,中文标点,. }\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

如果数据库有问题, 执行下面的 \sphinxcode{\sphinxupquote{SQL}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Dumping data for table {}`item\PYGZus{}table{}`}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{item\PYGZus{}table} \PYG{k}{VALUES} \PYG{p}{(}
\PYG{l+m+mi}{0000000001}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Manual\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}0.18.0\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}This is the manual for Mantis version 0.18.0.\PYGZbs{}r\PYGZbs{}n\PYGZbs{}r\PYGZbs{}nThe Mantis manual is modeled after the [url=http://www.php.net/manual/en/]PHP Manual[/url]. It is authored via the \PYGZbs{}\PYGZbs{}\PYGZdq{}manual\PYGZbs{}\PYGZbs{}\PYGZdq{} module in Mantis CVS.  You can always view/download the latest version of this manual from [url=http://mantisbt.sourceforge.net/manual/]here[/url].\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{20030811192655}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{python}}：

\fvset{hllines={, 2, 3,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} 测试注释}
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Love Python, Love FreeDome}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E文标点,.0123456789,中文标点,. }\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{javescipt}} 的 \sphinxcode{\sphinxupquote{rst}} 源码:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{o}{.}\PYG{o}{.} \PYG{n}{code}\PYG{o}{\PYGZhy{}}\PYG{n}{block}\PYG{p}{:}\PYG{p}{:} \PYG{n}{javascript}
    \PYG{p}{:}\PYG{n}{linenos}\PYG{p}{:}

    \PYG{n}{function} \PYG{n}{whatever}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{such color}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{bash}} :

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} home
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}PATH}
\PYG{n+nb}{source} \PYGZti{}/.bashrc
ls \PYGZhy{}l
mkdir filefolder
\PYG{n+nb}{cd} ..
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{python}} (code-block):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{jump\PYGZus{}from\PYGZus{}i}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}
        \PYG{n}{max\PYGZus{}step} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i} \PYG{o}{+} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{max\PYGZus{}step}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{jump\PYGZus{}from\PYGZus{}i}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{return} \PYG{n+nb+bp}{True}
        \PYG{k}{return} \PYG{n+nb+bp}{False}
    \PYG{k}{def} \PYG{n+nf}{canJump}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        https://leetcode.com/problems/jump\PYGZhy{}game/}
\PYG{l+s+sd}{        Each element in the array represents your maximum jump length at that position.}

\PYG{l+s+sd}{        Input: [2,3,1,1,4]}
\PYG{l+s+sd}{        Output: true}
\PYG{l+s+sd}{        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.}

\PYG{l+s+sd}{        :type nums: List[int]}
\PYG{l+s+sd}{        :rtype: bool}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{n}{nums} \PYG{o}{==} \PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{False}
        \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{jump\PYGZus{}from\PYGZus{}i}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

代码显示与隐藏：

\(\color{darkgreen}{Show/Hide\ Code}\)

\(\color{darkgreen}{Show/Hide\ Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
from plone import api
...
\end{sphinxVerbatim}

插入空行使用 \sphinxcode{\sphinxupquote{\textbar{}}} 。

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}

上面是两个空行。


\subsection{参考资料}
\label{\detokenize{else/02_test_code:id1}}\begin{enumerate}
\item {} 
reStructuredText(rst)快速入门语法说明

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/1885d5570b37}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
RST 语法

\end{enumerate}
\begin{quote}

\sphinxurl{https://3vshej.cn/rstSyntax/rstSyntax.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
代码隐藏（自定义，\_templates放在conf.py同目录下）

\end{enumerate}
\begin{quote}

\sphinxurl{http://cn.voidcc.com/question/p-pnfmhomd-v.html}

\sphinxurl{https://stackoverflow.com/questions/2454577/sphinx-restructuredtext-show-hide-code-snippets}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
代码隐藏（安装扩展，全屏显示，体验不好）

\end{enumerate}
\begin{quote}

\sphinxurl{https://sphinxcontrib-contentui.readthedocs.io/en/latest/installation.html}

\sphinxurl{https://sphinxcontrib-contentui.readthedocs.io/en/latest/toggle.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Sphinx + Github Page + Read the Docs

\end{enumerate}
\begin{quote}

\sphinxurl{https://kyzhang.me/2018/05/08/Sphinx-Readthedocs-GitHub2build-wiki/}

\sphinxurl{https://www.jianshu.com/p/78e9e1b8553a}

\sphinxurl{https://blog.csdn.net/baidu\_25464429/article/details/80805237}

\sphinxurl{https://github.com/mathLab/PyGeM/issues/94}

\sphinxurl{https://jamwheeler.com/college-productivity/how-to-write-beautiful-code-documentation/}

\sphinxurl{https://daler.github.io/sphinxdoc-test/includeme.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
latex 颜色

\end{enumerate}
\begin{quote}

\sphinxurl{http://latexcolor.com/}
\end{quote}



\renewcommand{\indexname}{Index}
\printindex
\end{document}