%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{目录}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}


	    % Use some font with UTF-8 support with XeLaTeX
        \usepackage[UTF8]{ctex}
        \usepackage{amsmath,bm}
        \usepackage{color}
        \usepackage{xcolor}
        \definecolor{darkgreen}{rgb}{0.0, 0.2, 0.13}
     

\title{Fong Documentation}
\date{Jun 10, 2019}
\release{alpha}
\author{fong}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{文中可能存在错误，欢迎 PR。}

\sphinxurl{https://github.com/fongyk}

\sphinxurl{https://github.com/fongyq}
\end{sphinxadmonition}


\chapter{C/C++}
\label{\detokenize{cpp/index:c-c}}\label{\detokenize{cpp/index::doc}}\label{\detokenize{cpp/index:id1}}

\section{main函数}
\label{\detokenize{cpp/01_main:main}}\label{\detokenize{cpp/01_main::doc}}

\subsection{返回值}
\label{\detokenize{cpp/01_main:id1}}
C++ main函数的返回值必须是 \sphinxcode{\sphinxupquote{int}} ，即整型类型。在大多数系统中，main 的返回值被用来指示状态，返回值 \sphinxcode{\sphinxupquote{0}} 表示执行成功，非0的返回值含义由系统定义，通常用来指出错误类型。

Windows系统下运行可执行文件(如launch.exe)可以直接忽略其扩展名 \sphinxcode{\sphinxupquote{.exe}} ：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{launch}
\end{sphinxVerbatim}

Unix系统下需要使用全文件名，包括扩展名：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
./a.out
\end{sphinxVerbatim}

访问main函数返回之后的方法依赖于系统。在Windows和Unix系统中，执行完一个程序之后，都可以通过 \sphinxcode{\sphinxupquote{echo}} 命令来获取返回值。

Windows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo} \PYGZpc{}ERRORLEVEL\PYGZpc{}
\end{sphinxVerbatim}

Unix:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}?}
\end{sphinxVerbatim}


\subsection{处理命令行选项}
\label{\detokenize{cpp/01_main:id2}}
main函数的形参列表有两种形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

第一种形参 \sphinxcode{\sphinxupquote{*argv{[}{]}}} 中，\sphinxcode{\sphinxupquote{argv}} 是一个数组，它的元素是指向C风格的字符串的指针；
第二种形参 \sphinxcode{\sphinxupquote{**argv}} 中，\sphinxcode{\sphinxupquote{argv}} 指向 \sphinxcode{\sphinxupquote{char*}} 。
参数 \sphinxcode{\sphinxupquote{argc}} 表示数组中字符串的数量。

当实参传给main函数之后，\sphinxcode{\sphinxupquote{argv}} 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。
例如，执行：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{launch} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{ofile} \PYG{n}{data}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{launch}} 是可执行文件。那么， \sphinxcode{\sphinxupquote{argc=5}} ，\sphinxcode{\sphinxupquote{argv}} 包含如下的C风格字符串：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{launch}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}o}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ofile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
当使用 \sphinxcode{\sphinxupquote{argv}} 中的实参时，实参是从 \sphinxcode{\sphinxupquote{argv{[}1{]}}} 开始的； \sphinxcode{\sphinxupquote{argv{[}0{]}}} 保存的是程序名，而非用户输入。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/01_main:id3}}
《C++ Primer 第5版 中文版》 Page 2, Page 197。


\section{数组}
\label{\detokenize{cpp/02_array::doc}}\label{\detokenize{cpp/02_array:id1}}

\subsection{指针}
\label{\detokenize{cpp/02_array:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}ctime\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{TreeNode}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{val}\PYG{p}{;}
  \PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{left}\PYG{p}{;}
  \PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{right}\PYG{p}{;}
  \PYG{n}{TreeNode}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)} \PYG{o}{:}\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{left}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{,} \PYG{n}{right}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}} \PYG{c+cm}{/* 唯一的构造函数，必须给的参数x */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{c+c1}{//int* p = new int(1); /* 这两行与下面三行等效 */}
  \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} *p \PYGZlt{}\PYGZlt{} endl;}
  \PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{;}
  \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}                \PYG{c+cm}{/* p已经申请了内存空间，可以直接赋值 */}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{p} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{q} \PYG{o}{=} \PYG{k}{new} \PYG{n}{TreeNode}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{q}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{n}{TreeNode} \PYG{n}{node}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{r} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{node}\PYG{p}{;}   \PYG{c+cm}{/* r 不能delete */}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{k}{delete} \PYG{n}{p}\PYG{p}{;}
  \PYG{k}{delete} \PYG{n}{q}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
两个指针变量的值相同，则这两个指针 \sphinxstylestrong{指向同一内存单元地址} 或都为 \sphinxstylestrong{空指针} 。不存在多个变量占用同一内存单元的情形。
\end{sphinxadmonition}


\subsection{指向函数的指针}
\label{\detokenize{cpp/02_array:id3}}
定义形式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{函数返回值类型} \PYG{p}{(}\PYG{o}{*}\PYG{n}{指针变量名}\PYG{p}{)}\PYG{p}{(}\PYG{n}{参数列表}\PYG{p}{)}
\end{sphinxVerbatim}

指向函数的指针是让函数的入口地址赋给指针变量，类似于指向数组的指针是把数组首地址赋给指针变量。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{double} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{n}{x} \PYG{o}{*} \PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{double} \PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{p} \PYG{o}{=} \PYG{n}{square}\PYG{p}{;} \PYG{c+c1}{// 用函数名square初始化指针}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{square}\PYG{p}{(}\PYG{l+m+mf}{1.6}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{(}\PYG{l+m+mf}{1.6}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.6}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 三者等效}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

还可以定义指针数组，

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 定义一个指向函数的指针类型，名为 MenuFood。函数参数列表为空，返回值为空。}
\PYG{k}{typedef} \PYG{n+nf}{void} \PYG{p}{(}\PYG{o}{*} \PYG{n}{MenuFood}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{food1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{food2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{food3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{food4}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{MenuFood} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{food1}\PYG{p}{,} \PYG{n}{food2}\PYG{p}{,} \PYG{n}{food3}\PYG{p}{,} \PYG{n}{food4}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// 该数组的每一个元素都是指向函数的指针。}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
指针数组：\sphinxcode{\sphinxupquote{类型 *数组名{[}长度{]}}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{char} \PYG{o}{*}\PYG{n}{name}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{allen}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{martin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{clark}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

指向行向量的指针变量：\sphinxcode{\sphinxupquote{类型 (*变量名){[}长度{]}}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
int (*pa)[10];
int *p;
int a[3][10];

p = a[0]; // 或 \PYGZam{}a[0][0]
pa = a; // 使用：*(*(pa + i) + j)
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{动态数组}
\label{\detokenize{cpp/02_array:id4}}
声明与定义一个动态数组的格式一般如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{da} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{da}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

內存释放：

\fvset{hllines={, 4, 7,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{da}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 释放指针指向的内存空间}
    \PYG{n}{da}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;} \PYG{c+c1}{// 置为空指针，防止出现‘野指针’}
\PYG{p}{\PYGZcb{}}
\PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{da}\PYG{p}{;}
\PYG{n}{da} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\end{sphinxVerbatim}

内存组织形式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
动态数组在堆(heap)区分配内存，静态数组在栈(stack)区分配內存。
\end{sphinxVerbatim}

假如我们已经得到一个3x4的动态数组da，其指针关系如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_dynamicArray}.png}\hspace*{\fill}}

其中，da{[}0{]}、da{[}1{]}、da{[}2{]}的 \sphinxstylestrong{地址} 是连续的，依次相差 \sphinxcode{\sphinxupquote{sizeof(da{[}0{]})}} (一个指针的大小，32位编译器下为4，64位编译器下为8)，比如:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZam{}}\PYG{n}{da}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{da}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{o}{\PYGZam{}}\PYG{n}{da}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

如果把da看作3行4列的二维数组，那么da的每一行元素的地址是连续的，依次相差 \sphinxcode{\sphinxupquote{sizeof(da{[}0{]}{[}0{]})}} ；但是行与行之间的地址是不连续的，比如:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
da[0][0], da[0][1], da[0][2], da[0][3]地址连续；
da[1][0], da[1][1], da[1][2], da[1][3]地址连续；
da[0][3]与da[1][0]地址不连续；
\end{sphinxVerbatim}

另外:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZam{}da, \PYGZam{}da[0], \PYGZam{}da[0][0]三者的数值是不相等的。
如果数组是静态数组，则\PYGZam{}da, \PYGZam{}da[0], \PYGZam{}da[0][0]三者的数值是相等的；
且静态数组的行与行之间的地址连续。
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
对于动态数组，指针的地址和指针的值不能混淆，我们讲da{[}0{]}、da{[}1{]}、da{[}2{]}的地址是连续的，但是他们本身的值没有关系，即 \sphinxcode{\sphinxupquote{da{[}0{]} + sizeof(da{[}0{]}) != da{[}1{]}}} 。
注意有没有 \sphinxcode{\sphinxupquote{\&}} 的区别。
\end{sphinxadmonition}

如果想要定义连续内存空间的动态数组，可以按如下方式进行：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// int** f; // f的声明}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{Init2DArray}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*}\PYG{o}{*} \PYG{o}{\PYGZam{}}\PYG{n}{f}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{row}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{col}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{f} \PYG{o}{=} \PYG{k}{new} \PYG{n}{T}\PYG{o}{*}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{k}{new} \PYG{n}{T}\PYG{p}{[}\PYG{n}{row} \PYG{o}{*} \PYG{n}{col}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{col}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{f}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{col} \PYG{o}{*} \PYG{n}{i}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

内存释放方式如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{Delete2DArray}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*}\PYG{o}{*} \PYG{o}{\PYGZam{}}\PYG{n}{f}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{f} \PYG{o}{!}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{f}\PYG{p}{;}
        \PYG{n}{f} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

上面的 \sphinxcode{\sphinxupquote{Init2DArray}} 在申请内存的时候，建立了row x col的二维动态数组。实际上，二维动态数组不强求列对齐，即各行的长度可以不一样，
因此可以下面像这样定义:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{offset\PYGZus{}i}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{offset\PYGZus{}i是第i行首地址相对于第0行首地址的偏移量}
\end{sphinxVerbatim}


\subsection{另类的数组表达}
\label{\detokenize{cpp/02_array:id5}}
有如下程序：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}

\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{l+m+mi}{9}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;}
\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\end{sphinxVerbatim}

这些表达式能够正常编译和执行，是因为对于C/C++而言:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{n}{等价于}\PYG{o}{*}\PYG{n}{a等价于}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{n}{等价于}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{+}\PYG{n}{a}\PYG{p}{)} \PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{等价于0}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

所以可以推出二维表达式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{[}\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
b: 相当于 \&b{[}0{]}，第0行的首地址。

*b: 相当于 b{[}0{]}，\&b{[}0{]}{[}0{]}，第0行第0列的首地址。

b{[}0{]}{[}1{]}等价于*(b{[}0{]} + 1)，*(*(b+0)+1)，(*(b+0)){[}1{]}（ {[}{]} 优先级高于 * ）。
\end{sphinxadmonition}


\subsection{数组实参}
\label{\detokenize{cpp/02_array:id6}}
以 \sphinxstylestrong{非引用} 类型传递数组实参时，数组会退化为指针，形参复制的是这个指针的值(指向数组的第一个元素)。通过指针形参做的任何改变，都是在修改数组元素本身。

如果以 \sphinxstylestrong{引用} 形式传递数组实参，那么编译器不会将数组实参转化为指针，而是传递数组的引用本身。

编译器会检查数组实参的大小与形参大小是否匹配。

非引用形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 函数可能会改变数组}
\PYG{k+kt}{void} \PYG{n+nf}{func2}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 不能改变数组}

\PYG{k+kt}{void} \PYG{n+nf}{func3}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}\PYG{c+c1}{// 4}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// int arr[100];}
\PYG{c+c1}{// func3(arr); // 调用func3}
\end{sphinxVerbatim}

引用形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func4}\PYG{p}{(}\PYG{k+kt}{int} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}\PYG{c+c1}{// 100}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// int arr[100];}
\PYG{c+c1}{// func4(arr); // 调用func4}
\end{sphinxVerbatim}


\subsection{数组地址与加法}
\label{\detokenize{cpp/02_array:id7}}
假设我们已经定义了一个数组：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Type} \PYG{n}{a}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]}\PYG{p}{[}\PYG{n}{M}\PYG{p}{]}\PYG{p}{[}\PYG{n}{N}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{1}. \sphinxcode{\sphinxupquote{a}} , \sphinxcode{\sphinxupquote{a{[}0{]}}} , \sphinxcode{\sphinxupquote{a{[}0{]}{[}0{]}}} , \sphinxcode{\sphinxupquote{\&a}} , \sphinxcode{\sphinxupquote{\&a{[}0{]}}} , \sphinxcode{\sphinxupquote{\&a{[}0{]}{[}0{]}}} , \sphinxcode{\sphinxupquote{\&a{[}0{]}{[}0{]}{[}0{]}}} 的数值都是一样的。

\sphinxstylestrong{2}. \sphinxcode{\sphinxupquote{\&a}} 是4级指针, 类型是 \sphinxcode{\sphinxupquote{int (*){[}L{]}{[}M{]}{[}N{]}}} ，指向a这个数组。

\sphinxstylestrong{3}. \sphinxcode{\sphinxupquote{a}} 是3级指针，类型是 \sphinxcode{\sphinxupquote{int (*){[}M{]}{[}N{]}}} ，三维数组的数组名，是数组a的首地址。

\sphinxstylestrong{4}. 大小计算如下:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sizeof(\PYGZam{}a) = 4;// 指针的大小，32位编译器
sizeof(a[0][0][0]) = sizeof(Type);
sizeof(a[0][0]) = N * sizeof(Type);
sizeof(a[0]) = M * N * sizeof(Type);
sizeof(a) = L * M * N * sizeof(Type);// 整个数组的大小
\end{sphinxVerbatim}

\sphinxstylestrong{5}. 加法运算:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
a + i = a + i * sizeof(a[0]);
\PYGZam{}a + i = a + i * sizeof(a);
这里（\PYGZam{}a + 1）就已经跳过了整个数组。
\end{sphinxVerbatim}

\sphinxstylestrong{6}. 定义指针 \sphinxcode{\sphinxupquote{int *ptr = (int *)(\&a + 1)}} ，则 \sphinxcode{\sphinxupquote{(ptr - 1)}} 指向数组a的最后一个元素。


\subsection{malloc/free与new/delete}
\label{\detokenize{cpp/02_array:malloc-freenew-delete}}

\subsubsection{相同点}
\label{\detokenize{cpp/02_array:id8}}
都可用于申请动态内存和释放内存。


\subsubsection{不同点}
\label{\detokenize{cpp/02_array:id9}}\begin{enumerate}
\item {} 
属性
\begin{quote}

\sphinxcode{\sphinxupquote{malloc/free}} 是C/C++的 \sphinxstylestrong{库函数} ，在头文件 \sphinxcode{\sphinxupquote{stdlib.h}} 中声明。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{o}{*}\PYG{n+nf}{malloc}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{size}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{free}\PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{pointer}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

因为malloc()函数的返回值类型为 \sphinxcode{\sphinxupquote{void*}} ，所以需要在函数前面进行相应的强制类型转换。

\sphinxcode{\sphinxupquote{new/delete}} 是C++的 \sphinxstylestrong{运算符} 。
\end{quote}

\item {} 
参数
\begin{quote}

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
int *pi=new int[n]; //指针pi指向长度为n的数组，未初始化
\end{sphinxVerbatim}

而malloc则需要显式地指出所需内存的尺寸。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{o}{*}\PYG{n}{p}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{int} \PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{n}{sizeof}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/}\PYG{n}{指向整型的指针p指向一个25个int整型空间的地址}
\PYG{n+nb}{int} \PYG{o}{*}\PYG{n}{p}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{int} \PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{l+m+mi}{99}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/}\PYG{n}{指向整型的指针p指向一个大小为99字节的内存的地址}
\end{sphinxVerbatim}

malloc可以分配任意字节，new 只能分配实例所占内存的整数倍数大小。
\end{quote}

\item {} 
分配失败
\begin{quote}

new内存分配失败时，会抛出 \sphinxcode{\sphinxupquote{bad\_alloc}} 异常；malloc分配内存失败时返回 \sphinxcode{\sphinxupquote{NULL}} 。
\end{quote}

\item {} 
功能
\begin{quote}

new做两件事，先分配内存，再调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。

对于内部数据类型(如 \sphinxcode{\sphinxupquote{int}} , \sphinxcode{\sphinxupquote{char}} 等)的对象，没有构造和析构的过程，对它们而言， \sphinxcode{\sphinxupquote{malloc/free}} 和 \sphinxcode{\sphinxupquote{new/delete}} 等价。

对于非内部数据类型的对象而言， \sphinxcode{\sphinxupquote{malloc/free}} 无法满足动态对象的要求。
\end{quote}

\item {} 
重载(overload)
\begin{quote}

\sphinxcode{\sphinxupquote{new/delete}} 可以重载成为函数，可以自定义申请过程，比如记录申请内存的长度以及跟踪每个对象的指针。

\sphinxcode{\sphinxupquote{malloc/free}} 不能重载。
\end{quote}

\end{enumerate}

\begin{sphinxadmonition}{warning}{Warning:}\begin{itemize}
\item {} 
new和delete一定要配对使用。

\item {} 
对空指针使用delete是安全的。

\item {} 
不能使用delete释放绑定到对象的指针。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{val} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n+nb}{int}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{val}\PYG{p}{;}
\PYG{n}{delete} \PYG{n}{p}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{error}\PYG{p}{,} \PYG{n}{memory} \PYG{o+ow}{not} \PYG{n}{allocated} \PYG{n}{by} \PYG{n}{new}
\end{sphinxVerbatim}

\end{itemize}
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/02_array:id10}}\begin{enumerate}
\item {} 
静态数组与动态数组：

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/liupeng900605/article/details/7526753}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
浅谈new/delete和malloc/free的用法与区别：

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/maluning/p/7944231.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
malloc/free与new/delete的区别：

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/hackbuteer1/article/details/6789164}
\end{quote}


\section{数据类型}
\label{\detokenize{cpp/03_typeSize::doc}}\label{\detokenize{cpp/03_typeSize:id1}}

\subsection{常用内置数据类型的大小}
\label{\detokenize{cpp/03_typeSize:id2}}
以下结果若非特别指出，均在Windows系统下由编译器Visual Studio测试得到。


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{类型大小}\label{\detokenize{cpp/03_typeSize:id4}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
类型
&\sphinxstyletheadfamily 
size/32位编译器
&\sphinxstyletheadfamily 
size/64位编译器
\\
\hline
char
&
1
&
1
\\
\hline
char*
&
4
&
8
\\
\hline
int
&
4
&
4
\\
\hline
int*
&
4
&
8
\\
\hline
short
&
2
&
2
\\
\hline
long
&
4
&
4 (8/linux)
\\
\hline
long*
&
4
&
8
\\
\hline
long long
&
8
&
8
\\
\hline
float
&
4
&
4
\\
\hline
double
&
8
&
8
\\
\hline
size\_t
&
4
&
8
\\
\hline
size\_type
&
4
&
8
\\
\hline
bool
&
1
&
1
\\
\hline
string
&
28
&
40
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{sizeof与strlen}
\label{\detokenize{cpp/03_typeSize:sizeofstrlen}}\begin{enumerate}
\item {} 
sizeof
\begin{quote}

\sphinxcode{\sphinxupquote{sizeof()}} 是 \sphinxstylestrong{运算符} ，计算的是分配的内存空间大小(单位为字节)，编译时就会计算，不受里面存储内容的影响。

\sphinxcode{\sphinxupquote{sizeof()}} 可以用数据类型、数组、字符串等做参数。
\end{quote}

\item {} 
strlen
\begin{quote}

\sphinxcode{\sphinxupquote{strlen()}} 是 \sphinxstylestrong{函数} ，计算的是字符串的实际长度(字符的个数)，以 \sphinxcode{\sphinxupquote{'\textbackslash{}0'}} 结束但长度 \sphinxstylestrong{不包括} \sphinxcode{\sphinxupquote{'\textbackslash{}0'}} ，程序执行时才计算结果。
\sphinxcode{\sphinxupquote{strlen()}} 只能用 \sphinxcode{\sphinxupquote{char*}} 类型做参数。
\end{quote}

\item {} 
实例
\begin{quote}

定义以下变量：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{strA} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdef}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strB}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdef}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strC}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strD}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strE}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{strF}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

结果如下:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sizeof(strA) = 4 : 指针的大小
sizeof(strB) = 7 : 该字符数组用字符串初始化，因此strB就是一个字符串，字符串以\PYGZsq{}\PYGZbs{}0\PYGZsq{}结尾，则大小为6+1=7
sizeof(strC) = 5 : 字符数组所占内存为5字节
sizeof(strD) = 3 : 字符数组所占内存为3字节
sizeof(strE) = 3 : 字符数组中有3个字符
sizeof(strF) = 4 : 字符数组中有4个字符，包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
sizeof(y) = 12 : 4 * 3 = 12 字节

strlen(strA) = 6 : 字符串长度为6，不包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
strlen(strB) = 6 : 字符串长度为6，不包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
strlen(strC) = 1 : 字符数组中只有1个字符
strlen(strD)不定，因为数组strD末尾没有人为补\PYGZsq{}\PYGZbs{}0\PYGZsq{}，因此strD是一个普通的字符数组，而不是字符串
strlen(strE)不定，因为数组strE末尾没有人为补\PYGZsq{}\PYGZbs{}0\PYGZsq{}，因此strD是一个普通的字符数组，而不是字符串
strlen(strF) = 3 : 字符串长度为3，不包括\PYGZsq{}\PYGZbs{}0\PYGZsq{}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
如果字符数组以字符常量进行初始化且字符个数大于1，如上例中的 \sphinxcode{\sphinxupquote{strD}} 和 \sphinxcode{\sphinxupquote{strE}} ，
如果不在末尾人为添加 \sphinxcode{\sphinxupquote{'\textbackslash{}0'}} ，则该字符数组不是字符串，
使用函数 \sphinxcode{\sphinxupquote{strlen}} 求得的大小不定，且该字符数组的内容也是未知的。
虽然 \sphinxcode{\sphinxupquote{strD}} 只有3个字节空间且刚好包含3个字符，但是 \sphinxcode{\sphinxupquote{cout\textless{}\textless{}strD}} 的结果也是不定的。
正确的定义应该是 \sphinxcode{\sphinxupquote{strF}} 。
\end{sphinxadmonition}
\end{quote}

\end{enumerate}


\subsection{float和double}
\label{\detokenize{cpp/03_typeSize:floatdouble}}
单精度浮点型 \sphinxstylestrong{float} 的精度为 \sphinxstylestrong{6 \textendash{} 7} 位有效数字，双精度浮点型 \sphinxstylestrong{double} 的精度为 \sphinxstylestrong{15 \textendash{} 16} 位有效数字。

\fvset{hllines={, 17, 18, 19, 20, 22,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{200000003} \PYG{o}{/} \PYG{l+m+mi}{100000002}\PYG{p}{;} \PYG{c+c1}{// 1.9999999900000003}

  \PYG{k+kt}{float} \PYG{n}{f\PYGZus{}i} \PYG{o}{=} \PYG{l+m+mi}{200000003} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{l+m+mi}{100000002}\PYG{p}{;} \PYG{c+c1}{// 浮点型常数默认为 const double，或用 200000003.0f 指定为 float。}
  \PYG{k+kt}{float} \PYG{n}{f\PYGZus{}f} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{l+m+mf}{200000003.0} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{l+m+mf}{100000002.0}\PYG{p}{;} \PYG{c+c1}{// 若不进行强制类型转换，会有 warning: truncation from \PYGZsq{}double\PYGZsq{} to \PYGZsq{}float\PYGZsq{}}
  \PYG{k+kt}{float} \PYG{n}{f\PYGZus{}d} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{l+m+mf}{200000003.0} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{l+m+mi}{100000002}\PYG{p}{;}\PYG{c+c1}{// warning: truncation from \PYGZsq{}double\PYGZsq{} to \PYGZsq{}float\PYGZsq{}}
  \PYG{k+kt}{double} \PYG{n}{d\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mi}{200000003} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{l+m+mi}{100000002}\PYG{p}{;}

  \PYG{n}{cout}\PYG{p}{.}\PYG{n}{setf}\PYG{p}{(}\PYG{n}{ios}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fixed}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 浮点数定点输出}
  \PYG{n}{cout}\PYG{p}{.}\PYG{n}{setf}\PYG{p}{(}\PYG{n}{ios}\PYG{o}{:}\PYG{o}{:}\PYG{n}{showpoint}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 显示小数位}
  \PYG{n}{cout}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 固定为10位精度（四舍五入）}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 1}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f\PYGZus{}i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f\PYGZus{}i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 2.0000000000 2}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f\PYGZus{}f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f\PYGZus{}f}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 2.0000000000 2}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f\PYGZus{}d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f\PYGZus{}d}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 2.0000000000 2}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d\PYGZus{}d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{d\PYGZus{}d}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 1.9999999900 1}
  \PYG{n}{cout}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d\PYGZus{}d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{d\PYGZus{}d}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 2.00 1}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{boolalpha}\PYG{p}{;} \PYG{c+c1}{// 设置布尔型输出格式}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f\PYGZus{}f}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// false}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f\PYGZus{}d}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// false}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{d\PYGZus{}d}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// true （只有double转换到int的结果与 i 一致）}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{cpp/03_typeSize:id3}}\begin{enumerate}
\item {} 
数据类型的数值范围

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qianbitou000/article/details/51939055/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
关于strlen与sizeof的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zhengqijun\_/article/details/51815081}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++ 中的 cout.setf() 函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/baishuiniyaonulia/article/details/79144033}
\end{quote}


\section{类的大小}
\label{\detokenize{cpp/04_classSize::doc}}\label{\detokenize{cpp/04_classSize:id1}}
计算类的大小遵循以下原则：
\begin{itemize}
\item {} 
内存对齐。

\item {} 
类的大小与普通数据成员有关，与成员函数、静态成员无关。即普通成员函数、静态成员函数、静态数据成员均对类的大小无影响。

\item {} 
虚函数对类的大小的影响体现在 \sphinxstylestrong{虚函数表指针} 的大小。

\item {} 
虚继承对类的大小的影响体现在 \sphinxstylestrong{虚基类表指针} 的大小。

\end{itemize}

以下结果均是在32位 Visual Studio 2013 下编译得到。


\subsection{空类}
\label{\detokenize{cpp/04_classSize:id2}}
C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。这是由于：
\begin{itemize}
\item {} 
new需要分配不同的内存地址，不能分配内存大小为0的空间 。

\item {} 
避免除以sizeof(*)时得到除以0错误

\end{itemize}

每个类在内存中都有唯一的标识，因此空类被实例化时，编译器会隐含地为其添加一个字节，以作区分。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Empty}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Empty) = 1}
\end{sphinxVerbatim}


\subsection{普通数据成员}
\label{\detokenize{cpp/04_classSize:id3}}
遵循内存对齐原则。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(A) = 4 + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{B}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(B) = 8 + 8 = 16}
\end{sphinxVerbatim}


\subsection{普通继承}
\label{\detokenize{cpp/04_classSize:id4}}
普通类的继承，派生类的大小=派生类数据成员大小+基类数据成员大小。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{B}\PYG{o}{:} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{ch}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{b}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(B) = 8 + 8 = 16 (对齐： 4+1 \PYGZhy{}\PYGZgt{} 8)}

\PYG{k}{class} \PYG{n+nc}{C}\PYG{o}{:} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{c}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{ch}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(C) = 8 + 8 + 8 = 24 (对齐： 4 \PYGZhy{}\PYGZgt{} 8, 1 \PYGZhy{}\PYGZgt{} 8)}
\end{sphinxVerbatim}


\subsubsection{继承空类}
\label{\detokenize{cpp/04_classSize:id5}}
派生类继承空类后，派生类如果有自己的数据成员，而空基类的一个字节并不会加到派生类中去。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Empty}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{A}\PYG{o}{:} \PYG{k}{public} \PYG{n}{Empty}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(A) = 4}
\end{sphinxVerbatim}


\subsubsection{类包含空类对象数据成员}
\label{\detokenize{cpp/04_classSize:id6}}
空类的1字节是会被计算进去的。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Empty}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Empty} \PYG{n}{e}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// sizeof(A) = 4 + 4 = 8}
\end{sphinxVerbatim}


\subsection{虚函数与继承}
\label{\detokenize{cpp/04_classSize:id7}}
虚函数（Virtual Function）是通过一张 \sphinxstylestrong{虚函数表（Virtual Table, vtable）} 来实现的。
每当 \sphinxstylestrong{创建一个包含有虚函数的类} 或 \sphinxstylestrong{从包含有虚函数的类派生一个类} 时，编译器就会为这个类创建一个虚函数表保存该类 \sphinxstylestrong{所有虚函数} 的地址。

当一个类中包含虚函数时，会有一个指向其虚函数表的指针vptr，系统为类指针分配大小为4个字节(即使有多个虚函数)。
当构造该派生类对象时，其成员vptr被初始化指向该派生类的vtable。
所以可以认为vtable是该类的所有对象共有的，在定义该类时被初始化；而vptr则是每个类对象都有独立一份的，且在该类对象被构造时被初始化。


\subsubsection{单继承}
\label{\detokenize{cpp/04_classSize:id8}}
派生类的大小 = 派生类的普通数据成员的大小 + 1个vptr指针的大小

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Base}
\PYG{p}{\PYGZob{}}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Base) = 4}

\PYG{k}{class} \PYG{n+nc}{Derived}\PYG{o}{:} \PYG{k}{public} \PYG{n}{Base}
\PYG{p}{\PYGZob{}}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 覆盖了基类中的f1()，多态}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Derived) = 4}
\end{sphinxVerbatim}


\subsubsection{多继承}
\label{\detokenize{cpp/04_classSize:id9}}
每个基类都有自己的虚表(vtable)。

派生类的成员函数被放到了第一个基类的表中。

派生类的大小 = 派生类的普通数据成员的大小 + 基类的普通数据成员的大小 + \sphinxstylestrong{n} 个vptr指针的大小。 \sphinxstylestrong{n} 是继承的有虚函数的基类的个数。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(A) = 1}

\PYG{k}{class} \PYG{n+nc}{B}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{ch}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f0}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(B) = 4 + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{C}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{ch1}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{ch2}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(C) = 4 + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{D}\PYG{o}{:} \PYG{k}{public} \PYG{n}{A}\PYG{p}{,} \PYG{k}{public} \PYG{n}{C}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{d}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(D) = 4 + 4 + 1*4 = 12}

\PYG{k}{class} \PYG{n+nc}{E}\PYG{o}{:} \PYG{k}{public} \PYG{n}{B}\PYG{p}{,} \PYG{k}{public} \PYG{n}{C}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{e}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f0}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(E) = 4 + 4 + 4 + 2*4 = 20}
\end{sphinxVerbatim}


\subsection{虚继承}
\label{\detokenize{cpp/04_classSize:id10}}
尽管派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接
继承某个基类，然后通过另一个基类再一次间接继承该类。

在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现多次，则派生类中将包含该类的多个子对象。这会导致两个问题：第一，
浪费存储空间；第二，存在二义性。

虚继承可以解决上述问题。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{04_virtualInheritance}.png}\hspace*{\fill}}

虚继承的目的是令某个类做出声明，承诺共享它的基类。其中，共享的基类子对象称为 \sphinxstylestrong{虚基类} （上图中的类 \sphinxstylestrong{A} ）。
在这种机制下，不论虚基类在继承体系中
出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。

虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现。
每个虚继承的子类都有一个 \sphinxstylestrong{虚基类指针（Virtual Base Table Pointer，vbptr，占用一个指针的存储空间）} 和虚基类表（ \sphinxstylestrong{不占用} 类对象的存储空间）
需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了。

实际上，虚基类指针指向了一个 \sphinxstylestrong{虚基类表（Virtual Table）} ，虚基类表中记录了虚基类与本类的偏移地址。
通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

当虚继承的子类被当做父类继承时，虚基类指针也会被继承。上图中，C继承了B1，B2，也就继承了2个虚基类指针。

总体需要考虑：数据成员的大小、虚基类指针的大小 、虚函数指针的大小。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A} \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(A) = 4}

\PYG{k}{class} \PYG{n+nc}{B} \PYG{o}{:}\PYG{k}{virtual} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
      \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{myfunB}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(B) = 16}

\PYG{k}{class} \PYG{n+nc}{C} \PYG{o}{:}\PYG{k}{virtual} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{double} \PYG{n}{c}\PYG{p}{;}
      \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{myfunC}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(C) = 28}

\PYG{k}{class} \PYG{n+nc}{D} \PYG{o}{:}\PYG{k}{public} \PYG{n}{B}\PYG{p}{,} \PYG{k}{public} \PYG{n}{C}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{d}\PYG{p}{;}
      \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{myfunD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(D) = 52}
\end{sphinxVerbatim}


\subsection{内存对齐}
\label{\detokenize{cpp/04_classSize:id11}}\begin{description}
\item[{内存对齐，是为了让内存存取更有效率而采用的一种编译阶段优化内存存取的手段。}] \leavevmode\begin{itemize}
\item {} 
内存对齐是指首地址对齐，而不是说每个变量大小对齐。

\item {} 
分配内存的顺序是按照声明的顺序。

\item {} 
\sphinxstylestrong{每个变量} 相对于起始位置的偏移量必须是 \sphinxstylestrong{该变量类型大小的整数倍} ，如果不是整数倍则空出内存，直到偏移量是整数倍为止。

\item {} 
结构体内存对齐要求结构体内每一个成员变量都是内存对齐的。

\item {} 
整个结构体的大小必须是结构体里面变量类型最大值的整数倍。

\item {} 
如果一个结构里有某些结构体成员，则结构体成员要从其内部”最宽基本类型成员”的整数倍偏移地址开始存储。比如，struct A里存有struct B，B里有char, int, double等类型的成员变量，那B应该从8的整数倍开始存储。

\end{itemize}

\item[{内存对齐的作用：}] \leavevmode\begin{itemize}
\item {} 
平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

\item {} 
性能原因：经过内存对齐后，CPU的内存访问速度大大提升。

\end{itemize}

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Data}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{d}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Data) = 1 + (3) + 4 + 1 + (3) = 12，括号内表示补齐的字节数。}
\PYG{c+c1}{// a 相对于起始位置的偏移量必须是 4 的整数倍，因此 c 后面需要补齐 3 个字节。}

\PYG{k}{class} \PYG{n+nc}{Data}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{d}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Data) = 1 + 1 + (2) + 4 = 8}

\PYG{k}{class} \PYG{n+nc}{BigData}
\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{char} \PYG{n}{array}\PYG{p}{[}\PYG{l+m+mi}{33}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BigData) = 33}

\PYG{k}{class} \PYG{n+nc}{Data}
\PYG{p}{\PYGZob{}}
      \PYG{n}{BigData} \PYG{n}{bd}\PYG{p}{;}
      \PYG{c+c1}{//int integer; // 不管有没有注释这一行，sizeof(Data)结果一样}
      \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{;} \PYG{c+c1}{// d的起始偏移量必须为8的倍数，且大于33，则其偏移量为40}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(Data) = 48}
\end{sphinxVerbatim}


\subsection{位域}
\label{\detokenize{cpp/04_classSize:id12}}
C/C++中以一定区域内的位(bit)为单位来表示的数据成为位域，位域必须指明具体的数目。
位域的作用主要是节省内存资源，使数据结构更紧凑。
\begin{enumerate}
\item {} 
一个位域必须存储在同一个字节中，不能跨两个字节，故位域的长度不能大于一个字节的长度

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{BitField}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int}  \PYG{o}{:}\PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{//空位域，自动置0，此时占满 1 个int存储单元，即 4 字节}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位，从第二个字节存储单元开始存放}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{d}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{;}  \PYG{c+c1}{//占用5个二进制位，剩余的3个bit不够存储4个bit的数据，从下一个存储单元开始存放}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int}  \PYG{o}{:}\PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{//空位域，自动置0，此时占满 2 个int存储单元，即 8 字节}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nl}{e}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}  \PYG{c+c1}{//占用4个二进制位，从第三个int存储单元开始存放}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BitField) = 3 * 4 = 12}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
取地址操作符\&不能应用在位域字段上

\item {} 
位域字段不能是类的静态成员

\item {} 
位域字段在内存中的位置是按照从低位向高位的顺序放置的

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{BitField}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}  \PYG{c+c1}{//最低位;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}  \PYG{c+c1}{//最高位;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
位域的对齐

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{BFA}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BFA) = 1}

\PYG{k}{struct} \PYG{n}{BFB}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{char} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int}  \PYG{n+nl}{d}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// sizeof(BFA) = 1 + (3) + 4 = 8}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
一个例子

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{num}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n+nl}{a}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n+nl}{b}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n+nl}{c}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{struct} \PYG{n}{num} \PYG{n}{n} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{.}\PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{.}\PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{.}\PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\(8 = (00001000)_2\) ， \(8\) 在计算机中的补码也是 \sphinxcode{\sphinxupquote{00001000}} ， \(a\) 用3位表示，取低位为 \sphinxcode{\sphinxupquote{000}} ( \sphinxcode{\sphinxupquote{00000000}} )，原码也是 \sphinxcode{\sphinxupquote{00000000}} ，则 \(a = 0\) 。

\item {} 
\(-6 = (10000110)_2\) ， \(-6\) 在计算机中的补码是 \sphinxcode{\sphinxupquote{11111010}} ， \(b\) 用2位表示，取低位为 \sphinxcode{\sphinxupquote{10}} ( \sphinxcode{\sphinxupquote{11111110}} )，原码是 \sphinxcode{\sphinxupquote{10000010}} ，则 \(b = -2\) 。

\item {} 
\(5 = (00000101)_2\) ， \(5\) 在计算机中的补码也是 \sphinxcode{\sphinxupquote{00000101}} ， \(c\) 用1位表示，取低位为 \sphinxcode{\sphinxupquote{1}} ( \sphinxcode{\sphinxupquote{11111111}} )，原码是 \sphinxcode{\sphinxupquote{10000001}} ，则 \(c = -1\) 。

\end{itemize}
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
C++标准库提供了一个 \sphinxstylestrong{bitset} 类模板，它可以辅助操纵位的集合。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/04_classSize:id13}}\begin{enumerate}
\item {} 
c++ 类大小问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/sz-leez/p/7119232.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
c++类的大小计算

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/fengxinlinux/article/details/72836199}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
虚继承

\end{enumerate}
\begin{quote}

《C++ Primer 第5版 中文版》 Page 717-718。
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
C++中虚继承的作用及底层实现原理

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/bxw1992/article/details/77726390}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
c++中的内存对齐

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/suntp/p/MemAlignment.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
C/C++ 内存对齐原则及作用

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/chy19911123/article/details/48894579}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
C/C++位域知识小结

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/pure/archive/2013/04/22/3034818.html}
\end{quote}


\section{交换函数}
\label{\detokenize{cpp/05_swap::doc}}\label{\detokenize{cpp/05_swap:id1}}
\sphinxstylestrong{1}. 库函数，包含在头文件 \sphinxcode{\sphinxupquote{\textless{}utility\textgreater{}}} 中。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}utility\PYGZgt{}}
\PYG{k}{using} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{swap}\PYG{p}{;}
\PYG{n}{swap}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// swap algorithm example (C++11)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}     // std::cout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}utility\PYGZgt{}      // std::swap}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{;}                  \PYG{c+c1}{// x:10 y:20}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{swap}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}                  \PYG{c+c1}{// x:20 y:10}

  \PYG{k+kt}{int} \PYG{n}{foo}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}                      \PYG{c+c1}{// foo: ?  ?  ?  ?}
  \PYG{k+kt}{int} \PYG{n}{bar}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{\PYGZcb{}}\PYG{p}{;}       \PYG{c+c1}{// foo: ?  ?  ?  ?    bar: 10 20 30 40}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{swap}\PYG{p}{(}\PYG{n}{foo}\PYG{p}{,}\PYG{n}{bar}\PYG{p}{)}\PYG{p}{;}              \PYG{c+c1}{// foo: 10 20 30 40   bar: ?  ?  ?  ?}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{foo contains:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n+nl}{i}\PYG{p}{:} \PYG{n}{foo}\PYG{p}{)} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{2}. 指针。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{Swap}\PYG{p}{(}\PYG{n}{T} \PYG{o}{*}\PYG{n}{x}\PYG{p}{,} \PYG{n}{T} \PYG{o}{*}\PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{T} \PYG{n}{tmp} \PYG{o}{=} \PYG{o}{*}\PYG{n}{x}\PYG{p}{;}
    \PYG{o}{*}\PYG{n}{x} \PYG{o}{=} \PYG{o}{*}\PYG{n}{y}\PYG{p}{;}
    \PYG{o}{*}\PYG{n}{y} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{3}. 引用。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{Swap}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{T} \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{4}. 异或。适用于整型/字符/枚举类型，浮点型不适用。 \sphinxcode{\sphinxupquote{SWAP(a, a)}} 和 \sphinxcode{\sphinxupquote{Swap(a, a)}} 会导致 \sphinxcode{\sphinxupquote{a=0}} 或 \sphinxcode{\sphinxupquote{a='{'}}} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SWAP(a, b) a\PYGZca{}=b\PYGZca{}=a\PYGZca{}=b;}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{Swap}\PYG{p}{(}\PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{a}\PYG{p}{,} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZca{}} \PYG{n}{b}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZca{}} \PYG{n}{b}\PYG{p}{;}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZca{}} \PYG{n}{b}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{4}. 赋值。受编译器影响，先执行 \sphinxcode{\sphinxupquote{a+b}} 还是先执行 \sphinxcode{\sphinxupquote{b=a}} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SWAP(a, b) a=a+b\PYGZhy{}(b=a);}
\end{sphinxVerbatim}

\sphinxstylestrong{5}. 加减。无需申请额外空间。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{Swap}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
如果存在类型特定的 swap 版本（即为某个类定制的swap），其匹配程度会优于 std 中定义的版本。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{swap}\PYG{p}{;} \PYG{c+c1}{// 声明}

\PYG{k+kt}{void} \PYG{n+nf}{swap}\PYG{p}{(}\PYG{n}{Foo}\PYG{o}{\PYGZam{}} \PYG{n}{a}\PYG{p}{,} \PYG{n}{Foo}\PYG{o}{\PYGZam{}}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 声明}

\PYG{n}{Foo} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{;}

\PYG{n}{swap}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 此处匹配的是定制版本的 swap}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/05_swap:id2}}\begin{enumerate}
\item {} 
C++ reference

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cplusplus.com/reference/utility/swap}
\end{quote}


\section{数组形参}
\label{\detokenize{cpp/06_arrayArg::doc}}\label{\detokenize{cpp/06_arrayArg:id1}}

\subsection{非引用}
\label{\detokenize{cpp/06_arrayArg:id2}}
当数组以 \sphinxstylestrong{非引用} 类型传递，数组会悄悄退化为指针，形参复制的是这个指针的值（指向数组第一个元素）。通过该形参做的任何改变都是在修改数组元素本身。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 指针的大小为4（32位编译器）}
    \PYG{c+cm}{/*}
\PYG{c+cm}{        function body}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{func2}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 指针的大小为4（32位编译器）}
    \PYG{c+cm}{/*}
\PYG{c+cm}{        function body}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{func2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{引用}
\label{\detokenize{cpp/06_arrayArg:id3}}
如果形参是数组的 \sphinxstylestrong{引用} ，编译器不会将数组实参转化为指针，而是传递数组的引用本身。编译器会检查数组实参的大小与形参是否匹配。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 大小为4*10=40（32位编译器）}
    \PYG{c+cm}{/*}
\PYG{c+cm}{        function body}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{func2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{指针与引用}
\label{\detokenize{cpp/07_pointerReference::doc}}\label{\detokenize{cpp/07_pointerReference:id1}}
\sphinxstylestrong{1}. 指针是一个对象，有存储的 \sphinxstylestrong{值} 和 \sphinxstylestrong{地址} ，存储的数据类型是数据的地址；非常量指针可以被重新赋值，指向另一个对象。引用是对象的别名，必须初始化并总是指向（代表）最初绑定的那个对象，对对象及其引用进行取地址操作得到的结果相同。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{pk} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{k}\PYG{p}{;}
  \PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{rk} \PYG{o}{=} \PYG{n}{k}\PYG{p}{;}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZam{}k:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZam{}}\PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}   \PYG{c+c1}{// 0029FC44}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{k:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}     \PYG{c+c1}{// 1}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZam{}pk:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZam{}}\PYG{n}{pk} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 0029FC68}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pk:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pk} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}   \PYG{c+c1}{// 0029FC44 (pk = \PYGZam{}k)}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{*pk}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{pk} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}  \PYG{c+c1}{// 1}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZam{}rk:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZam{}}\PYG{n}{rk} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 0029FC44 (\PYGZam{}rk = \PYGZam{}k)}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rk:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rk} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}   \PYG{c+c1}{// 1}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{2}. 指针可以有多级，但是引用只能是一级（不存在 \sphinxstyleemphasis{引用的引用} ）。

\sphinxstylestrong{3}. 有 \sphinxcode{\sphinxupquote{null pointer}} ，没有 \sphinxcode{\sphinxupquote{null reference}} ，故使用前无需检查是非为空。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{rValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{pValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{p} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{4}. 例子。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{string} \PYG{n+nf}{s1}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nancy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{s2}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{candy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{rs} \PYG{o}{=} \PYG{n}{s1}\PYG{p}{;}
\PYG{n}{string}\PYG{o}{*} \PYG{n}{ps} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{s2}\PYG{p}{;}
\PYG{n}{rs} \PYG{o}{=} \PYG{n}{s2}\PYG{p}{;} \PYG{c+c1}{// rs仍指向s1，但是s1值变为\PYGZdq{}candy\PYGZdq{}。}
\PYG{n}{ps} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{s2}\PYG{p}{;} \PYG{c+c1}{// ps指向s2，s1无变化}
\end{sphinxVerbatim}


\section{重载、覆盖、隐藏}
\label{\detokenize{cpp/08_overload::doc}}\label{\detokenize{cpp/08_overload:id1}}

\subsection{重载（Overloading）}
\label{\detokenize{cpp/08_overload:overloading}}
同一可访问区内被声明的几个具有不同参数列表（参数个数，参数类型，参数顺序）的同名函数。不关心函数返回类型。


\subsection{覆盖（Overriding）}
\label{\detokenize{cpp/08_overload:overriding}}
基类中被重写的函数，用 \sphinxcode{\sphinxupquote{virtual}} 修饰。派生类重写的函数与被重写的函数保持同样的 \sphinxstylestrong{函数名、参数列表、返回类型} 。

使用 \sphinxcode{\sphinxupquote{virtual}} 的同时，配合使用 \sphinxcode{\sphinxupquote{override}} 关键字来说明派生类中的虚函数。这么做的好处是使得程序员的意图更加清晰（即：希望覆盖基类中的虚函数），同时让编译器发现错误。
因为只有虚函数才能被覆盖。编译器会检查两个对应函数的声明是否匹配。

通过把某个函数指定为 \sphinxcode{\sphinxupquote{final}} ，拒绝对该函数进行覆盖。也在类名后面接 \sphinxcode{\sphinxupquote{final}} ，以禁止该类被继承。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Base}
\PYG{p}{\PYGZob{}}
  \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{f}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{k}{const} \PYG{k}{final}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{void} \PYG{n+nf}{f3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Derived}\PYG{o}{:} \PYG{n}{Base}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{void} \PYG{n}{f}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;} \PYG{c+c1}{// 错误：f 禁止覆盖}
  \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{k}{const} \PYG{k}{override}\PYG{p}{;} \PYG{c+c1}{// 正确}
  \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;} \PYG{c+c1}{// 错误：基类中没有形如 f2(int) 的函数}
  \PYG{k+kt}{void} \PYG{n+nf}{f3}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;} \PYG{c+c1}{// 错误：f3 不是虚函数}
  \PYG{k+kt}{void} \PYG{n+nf}{f4}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;} \PYG{c+c1}{// 错误：基类中没有名为 f4 的函数}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{NoDerived} \PYG{k}{final} \PYG{p}{\PYGZob{}} \PYG{c+cm}{/* */} \PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// NoDerived 不能作为基类}
\end{sphinxVerbatim}
\begin{description}
\item[{多态性}] \leavevmode
我们把具有继承关系的多个类型成为多态类型，因为我们能够使用这些类型的“多种形式”而无须在意它们的差异。引用或指针的静态类型与动态类型
不同，这正是C++支持多态性的根本所在。

对非虚函数的调用在 \sphinxstylestrong{编译时} 进行绑定。类似地，通过 \sphinxstylestrong{对象} 本身进行的函数（虚函数或非虚函数）调用也在 \sphinxstylestrong{编译时} 绑定。
因为 \sphinxstylestrong{对象} 的类型是确定不变的，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本。

当且仅当通过 \sphinxstylestrong{指针或引用} 调用虚函数时，才在 \sphinxstylestrong{运行时} 解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同（ \sphinxstylestrong{动态绑定} ）。

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Base}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{f}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{base}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Derived} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Base} \PYG{c+c1}{// 注意：这里必须为 public 继承}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{void} \PYG{n}{f}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{derived}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Derived} \PYG{n}{d} \PYG{o}{=} \PYG{n}{Derived}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 派生类对象}
  \PYG{n}{Base}\PYG{o}{*} \PYG{n}{pb} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{d}\PYG{p}{;} \PYG{c+c1}{// 基类指针}
  \PYG{n}{pb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{f}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// derived}

  \PYG{n}{Base} \PYG{n}{b} \PYG{o}{=} \PYG{n}{Base}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 基类对象}
  \PYG{n}{Base}\PYG{o}{\PYGZam{}} \PYG{n}{rb} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{// 基类引用}
  \PYG{n}{rb}\PYG{p}{.}\PYG{n}{f}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// base}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{description}
\item[{抽象基类与纯虚函数}] \leavevmode\begin{itemize}
\item {} 
纯虚函数无须定义（非要定义的话，必须发生在类外部），在该函数的声明语句中（分号之前）加入 \sphinxcode{\sphinxupquote{= 0}} 就可以将一个虚函数声明为纯虚函数。

\item {} 
含有纯虚函数的类是抽象基类。抽象基类负责声明接口，派生类负责覆盖该接口。如果派生类不给出对应基类中纯虚函数的定义，该派生类也是一个抽象基类。

\item {} 
不能直接创建抽象基类的对象。

\end{itemize}

\end{description}

\begin{sphinxadmonition}{note}{Note:}
基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。

我们可以将 \sphinxstylestrong{基类的指针或引用} 绑定到派生类的对象上。因此，当我们使用基类指针或引用时，实际上并不清楚该指针或引用所绑定的对象的真实类型。
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
构造函数 \sphinxstylestrong{不能声明} 为虚函数：一方面，创建一个对象时总要明确指定对象的类型。另一方面，虚函数对应一个指向虚函数表的指针（vptr），在创建对象之前，
vptr不存在，不可能完成动态绑定。

析构函数 \sphinxstylestrong{可以声明} 为虚函数：当基类指针指向派生类，使用基类指针删除对象时，如果析构函数不定义成虚函数，派生类中派生的部分无法完成析构。

构造函数 \sphinxstylestrong{不要调用} 虚函数。在基类构造的时候，虚函数是非虚，不会走到派生类中，即采用的静态绑定。显然，当我们构造一个子类的对象时，先调用基类的构造函数去构造子类中基类部分，此时子类部分还没有构造、初始化。
如果在构造中调用虚函数，可能会调用一个还没有被初始化的对象，这是很危险的。

析构函数 \sphinxstylestrong{不要调用} 虚函数。析构的时候，首先调用子类的析构函数，析构掉对象的子类部分，然后调用基类的析构函数析构基类部分。
如果在基类的析构函数里面调用虚函数，会导致其调用已经析构了的子类对象里面的函数，这是非常危险的。

总而言之：在运行构造函数或者析构函数时，对象都是不完整的，这种情况下的虚函数调用不会调用到外层派生类的虚函数。
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
error C2243: ‘type cast’ : conversion from ‘Derived *’ to ‘Base *’ exists, but is inaccessible.

基类的指针和引用不能指向继承方式为 \sphinxcode{\sphinxupquote{protected}} 与 \sphinxcode{\sphinxupquote{private}} 的派生类对象，只能通过 \sphinxcode{\sphinxupquote{public}} 继承。
\end{sphinxadmonition}


\subsection{隐藏（Hiding）}
\label{\detokenize{cpp/08_overload:hiding}}
派生类中的函数屏蔽了基类中的同名函数，不管参数列表是否相同。当参数不同时，无论基类中的函数是否被 \sphinxcode{\sphinxupquote{virtual}} 修饰，基类函数都是被隐藏，而不是被覆盖。


\subsection{例子}
\label{\detokenize{cpp/08_overload:id2}}

\subsubsection{虚析构函数}
\label{\detokenize{cpp/08_overload:id3}}
删除一个指向派生类对象的基类指针时，需要虚析构函数。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{o}{\PYGZti{}}\PYG{n}{A}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// virtual \PYGZti{}A();}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{A}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{A}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{delete A }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{class} \PYG{n+nc}{B} \PYG{o}{:} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{o}{\PYGZti{}}\PYG{n}{B}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{B}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{B}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{delete B }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

基类析构函数未加virtual：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{A} \PYG{o}{*}\PYG{n}{pa} \PYG{o}{=} \PYG{k}{new} \PYG{n}{B}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{delete} \PYG{n}{pa}\PYG{p}{;}
\PYG{c+c1}{// 输出： delete B}

\PYG{n}{B} \PYG{o}{*}\PYG{n}{pb} \PYG{o}{=} \PYG{k}{new} \PYG{n}{B}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{delete} \PYG{n}{pb}\PYG{p}{;}
\PYG{c+c1}{// 输出： delete B delete A}
\end{sphinxVerbatim}

基类析构函数加virtual：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{A} \PYG{o}{*}\PYG{n}{pa} \PYG{o}{=} \PYG{k}{new} \PYG{n}{B}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{delete} \PYG{n}{pa}\PYG{p}{;}
\PYG{c+c1}{// 输出： delete B delete A}

\PYG{n}{B} \PYG{o}{*}\PYG{n}{pb} \PYG{o}{=} \PYG{k}{new} \PYG{n}{B}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{delete} \PYG{n}{pb}\PYG{p}{;}
\PYG{c+c1}{// 输出： delete B delete A}
\end{sphinxVerbatim}


\subsubsection{析构顺序}
\label{\detokenize{cpp/08_overload:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{A}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{create A}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}  \PYG{p}{\PYGZcb{}}

  \PYG{n}{A}\PYG{p}{(}\PYG{n}{A} \PYG{o}{\PYGZam{}}\PYG{n}{obj}\PYG{p}{)} \PYG{p}{\PYGZob{}}  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{copy\PYGZhy{}construct A}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}  \PYG{p}{\PYGZcb{}}

  \PYG{o}{\PYGZti{}}\PYG{n}{A}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZti{}A}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{B}\PYG{o}{:} \PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{B}\PYG{p}{(}\PYG{n}{A} \PYG{o}{\PYGZam{}}\PYG{n}{a}\PYG{p}{)}\PYG{o}{:} \PYG{n}{\PYGZus{}a}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{p}{\PYGZob{}}  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{create B}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}  \PYG{p}{\PYGZcb{}}

  \PYG{o}{\PYGZti{}}\PYG{n}{B}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZti{}B}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}  \PYG{p}{\PYGZcb{}}
\PYG{k}{private}\PYG{o}{:}
  \PYG{n}{A} \PYG{n}{\PYGZus{}a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{A} \PYG{n}{a}\PYG{p}{;}

  \PYG{n}{B} \PYG{n}{b}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

运行结果:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{create} \PYG{n}{A}
\PYG{n}{create} \PYG{n}{A}
\PYG{n}{copy}\PYG{o}{\PYGZhy{}}\PYG{n}{construct} \PYG{n}{A}
\PYG{n}{create} \PYG{n}{B}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{o}{\PYGZti{}}\PYG{n}{B}
\PYG{o}{\PYGZti{}}\PYG{n}{A}
\PYG{o}{\PYGZti{}}\PYG{n}{A}
\PYG{o}{\PYGZti{}}\PYG{n}{A}
\end{sphinxVerbatim}

创建派生类对象时，调用构造函数的顺序如下:
\begin{itemize}
\item {} 
先是父类的构造函数；（create A）

\item {} 
然后如果类成员变量中有某类（可能是父类，也可能不是）的对象，调用其相应的构造函数；（copy-construct A）

\item {} 
最后调用派生类自身的构造函数。（create B）

\end{itemize}

析构函数的调用顺序正好相反。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{A}\PYG{p}{(}\PYG{p}{)}  \PYG{p}{\PYGZob{}}  \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{create A}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}   \PYG{p}{\PYGZcb{}}

  \PYG{n}{A}\PYG{p}{(}\PYG{k}{const} \PYG{n}{A}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{copy A}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{// 拷贝构造函数}

  \PYG{o}{\PYGZti{}}\PYG{n}{A}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}  \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZti{}A}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{C}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{C}\PYG{p}{(}\PYG{p}{)}  \PYG{p}{\PYGZob{}}  \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{create C}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}   \PYG{p}{\PYGZcb{}}

  \PYG{n}{C}\PYG{p}{(}\PYG{k}{const} \PYG{n}{A}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{copy C}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{// 拷贝构造函数}

  \PYG{o}{\PYGZti{}}\PYG{n}{C}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}  \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZti{}C}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{B}\PYG{o}{:}\PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{B}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}  \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{create B}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}  \PYG{p}{\PYGZcb{}}

  \PYG{o}{\PYGZti{}}\PYG{n}{B}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}  \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZti{}B}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}  \PYG{p}{\PYGZcb{}}
\PYG{k}{private}\PYG{o}{:}
  \PYG{n}{C} \PYG{n}{\PYGZus{}c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{B} \PYG{n}{b}\PYG{p}{;}
  \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

运行结果:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{create} \PYG{n}{A}
\PYG{n}{create} \PYG{n}{C}
\PYG{n}{create} \PYG{n}{B}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{o}{\PYGZti{}}\PYG{n}{B}
\PYG{o}{\PYGZti{}}\PYG{n}{C}
\PYG{o}{\PYGZti{}}\PYG{n}{A}
\end{sphinxVerbatim}


\subsubsection{对象数组的析构}
\label{\detokenize{cpp/08_overload:id5}}
数组的多态会导致未定义的行为，不管析构函数是否声明为虚函数。所以在对数组元素执行析构时，还是要用 \sphinxstylestrong{派生类的指针} 来 delete 。

参考：\sphinxurl{https://www.nowcoder.com/profile/3704231/myFollowings/detail/8528425}。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{A}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
  \PYG{o}{\PYGZti{}}\PYG{n}{A}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZti{}A}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{B}\PYG{o}{:}\PYG{k}{public} \PYG{n}{A}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{B}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{B}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
  \PYG{o}{\PYGZti{}}\PYG{n}{B}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZti{}B}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{A} \PYG{n}{arrA} \PYG{o}{=} \PYG{k}{new} \PYG{n}{B}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
  \PYG{k}{delete} \PYG{p}{[}\PYG{p}{]} \PYG{n}{arrA}\PYG{p}{;}
  \PYG{c+c1}{// 输出： A B A B \PYGZti{}A \PYGZti{}A}

  \PYG{n}{B} \PYG{n}{arrB} \PYG{o}{=} \PYG{k}{new} \PYG{n}{B}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
  \PYG{k}{delete} \PYG{p}{[}\PYG{p}{]} \PYG{n}{arrB}\PYG{p}{;}
  \PYG{c+c1}{// 输出： A B A B \PYGZti{}B \PYGZti{}A \PYGZti{}B \PYGZti{}A}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{cpp/08_overload:id6}}\begin{enumerate}
\item {} 
C++中重载、重写（覆盖）和隐藏的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zx3517288/article/details/48976097}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
《C++ Primer 第5版 中文版》 Page 538 \textendash{} 540。

\end{enumerate}


\section{strcpy函数}
\label{\detokenize{cpp/09_strcpy:strcpy}}\label{\detokenize{cpp/09_strcpy::doc}}
函数定义：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{char}\PYG{o}{*} \PYG{n+nf}{strcpy}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{dst}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{src}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cp} \PYG{o}{=} \PYG{n}{dst}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(} \PYG{o}{*}\PYG{n}{cp}\PYG{o}{+}\PYG{o}{+} \PYG{o}{=} \PYG{o}{*}\PYG{n}{src}\PYG{o}{+}\PYG{o}{+} \PYG{p}{)}\PYG{p}{;}  \PYG{c+cm}{/* Copy src over dst */}
    \PYG{k}{return}\PYG{p}{(} \PYG{n}{dst} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{char} \PYG{n}{src}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{dst}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{copy} \PYG{o}{=} \PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{dst}\PYG{p}{,} \PYG{n}{src}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{形参src}
\label{\detokenize{cpp/09_strcpy:src}}
形参 \sphinxcode{\sphinxupquote{src}} 定义为  \sphinxcode{\sphinxupquote{const}} ，防止函数对其进行修改。


\subsection{额外指针cp}
\label{\detokenize{cpp/09_strcpy:cp}}
\sphinxcode{\sphinxupquote{cp++}} 导致复制结束时， \sphinxcode{\sphinxupquote{cp}} 指向的是 \sphinxcode{\sphinxupquote{dst}} 绑定的字符串的尾部，因此不能直接返回 \sphinxcode{\sphinxupquote{cp}} 。


\subsection{返回值}
\label{\detokenize{cpp/09_strcpy:id1}}
为了实现链式操作，将目的地址返回。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{length} \PYG{o}{=} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{strcpy}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello World}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{cpp/09_strcpy:id2}}\begin{enumerate}
\item {} 
标准的strcpy函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/elisha-blogs/p/4125799.html}
\end{quote}


\section{强制类型转换}
\label{\detokenize{cpp/10_cast::doc}}\label{\detokenize{cpp/10_cast:id1}}

\subsection{static\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:static-cast-type-expr}}
\sphinxstylestrong{1}. \sphinxcode{\sphinxupquote{static\_cast}} 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。

\sphinxstylestrong{2}. 用于基本数据类型之间的转换，如把 \sphinxcode{\sphinxupquote{int}} 转换成 \sphinxcode{\sphinxupquote{char}} ，把 \sphinxcode{\sphinxupquote{int}} 转换成 \sphinxcode{\sphinxupquote{enum}} 。这种转换的安全性需要开发者来维护。

\sphinxstylestrong{3}. C++ 的任何的隐式转换都是使用 \sphinxcode{\sphinxupquote{static\_cast}} 来实现。

\sphinxstylestrong{4}. 基类和子类之间转换：其中子类指针转换成父类指针是安全的；但父类指针转换成子类指针是不安全的。（基类和子类之间的动态类型转换建议用 \sphinxcode{\sphinxupquote{dynamic\_cast}} ）

\sphinxstylestrong{5}. 把空指针转换成目标类型的空指针。

\sphinxstylestrong{6}. 把任何类型的表达式转换成 \sphinxcode{\sphinxupquote{void}} 类型。


\subsection{dynamic\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:dynamic-cast-type-expr}}
有条件转换，动态类型转换，运行时类型安全检查（转换失败返回 \sphinxcode{\sphinxupquote{NULL}} ）：

\sphinxstylestrong{1}. 安全的基类和子类之间转换。

\sphinxstylestrong{2}. 必须要有虚函数。

\sphinxstylestrong{3}. 相同基类不同子类之间的交叉转换，结果是 \sphinxcode{\sphinxupquote{NULL}} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// dynamic\PYGZus{}cast}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}exception\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Base} \PYG{p}{\PYGZob{}} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{dummy}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{Derived}\PYG{o}{:} \PYG{k}{public} \PYG{n}{Base} \PYG{p}{\PYGZob{}} \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{try}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{Base} \PYG{o}{*} \PYG{n}{pba} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Derived}\PYG{p}{;}
    \PYG{n}{Base} \PYG{o}{*} \PYG{n}{pbb} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Base}\PYG{p}{;}
    \PYG{n}{Derived} \PYG{o}{*} \PYG{n}{pd}\PYG{p}{;}

    \PYG{n}{pd} \PYG{o}{=} \PYG{k}{dynamic\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{Derived}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{pba}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{pd}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Null pointer on first type\PYGZhy{}cast.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

    \PYG{n}{pd} \PYG{o}{=} \PYG{k}{dynamic\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{Derived}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{pbb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{pd}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Null pointer on second type\PYGZhy{}cast.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

  \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Exception: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// 输出结果：Null pointer on second type\PYGZhy{}cast.}
\end{sphinxVerbatim}


\subsection{const\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:const-cast-type-expr}}
\sphinxstylestrong{1}. 去掉或加上类型的 \sphinxcode{\sphinxupquote{const}}、\sphinxcode{\sphinxupquote{volitale}} 属性;

\sphinxstylestrong{2}. 常量指针被转化成非常量的指针，并且仍然指向原来的对象；

\sphinxstylestrong{3}. 常量引用被转换成非常量的引用，并且仍然指向原来的对象；

\sphinxstylestrong{4}. \sphinxcode{\sphinxupquote{const\_cast}} 一般用于修改指针。如 \sphinxcode{\sphinxupquote{const char *p}} 形式。
如果有一个函数，它的形参是 \sphinxcode{\sphinxupquote{non-const}} 类型变量，而且函数不会对实参的值进行改动，这时我们可以使用类型为 \sphinxcode{\sphinxupquote{const}} 的变量来调用函数，此时 \sphinxcode{\sphinxupquote{const\_cast}} 就派上用场了。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// const\PYGZus{}cast}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{print} \PYG{p}{(}\PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{str}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{str} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample text}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{print} \PYG{p}{(} \PYG{k}{const\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{c}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// 输出结果：sample text}
\end{sphinxVerbatim}


\subsection{reinterpret\_cast\textless{}type\textgreater{} (expr)}
\label{\detokenize{cpp/10_cast:reinterpret-cast-type-expr}}
\sphinxstylestrong{1}. \sphinxcode{\sphinxupquote{reinterpret\_cast}} 是从底层对数据进行重新解释，依赖具体的平台，可移植性差。

\sphinxstylestrong{2}. \sphinxcode{\sphinxupquote{reinterpret\_cast}} 可以将整型转换为指针，也可以把指针转换为数组。

\sphinxstylestrong{3}. \sphinxcode{\sphinxupquote{reinterpret\_cast}} 可以在指针和引用里进行肆无忌惮的转换。


\subsection{使用stringstream转换类型}
\label{\detokenize{cpp/10_cast:stringstream}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{sstream} 头文件定义了三个类型来支持内存IO：istringstream，ostringstream，stringstream。这些类型可以向 \sphinxstylestrong{string} 写入数据，或从 \sphinxstylestrong{string} 读取数据。

\sphinxstylestrong{stringstream} 的一些操作：
\begin{itemize}
\item {} 
stringstream strm; // strm是一个未绑定的stringstream类型

\item {} 
stringstream strm(s); // strm是一个stringstream对象，保存 string s 的一个拷贝

\item {} 
strm.str(); // 返回strm保存的拷贝

\item {} 
strm(s); // 将 string s 拷贝到 strm 中，返回void

\end{itemize}


\subsubsection{强制类型转换}
\label{\detokenize{cpp/10_cast:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{output\PYGZus{}type}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{input\PYGZus{}type}\PYG{o}{\PYGZgt{}}
\PYG{n}{output\PYGZus{}type} \PYG{n}{Convert}\PYG{p}{(}\PYG{k}{const} \PYG{n}{input\PYGZus{}type} \PYG{o}{\PYGZam{}}\PYG{n}{input}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{stringstream} \PYG{n}{strm}\PYG{p}{;}
  \PYG{n}{strm} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{input}\PYG{p}{;}
  \PYG{n}{output\PYGZus{}type} \PYG{n}{result}\PYG{p}{;}
  \PYG{n}{strm} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{result}\PYG{p}{;}
  \PYG{n}{strm}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{int} \PYG{n}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{string} \PYG{n}{strNum} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}22.22}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k+kt}{float} \PYG{n}{f} \PYG{o}{=} \PYG{n}{Convert}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strNum}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// \PYGZhy{}22.22}

  \PYG{k+kt}{float} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mf}{22.22}\PYG{p}{;}
  \PYG{n}{string} \PYG{n}{str} \PYG{o}{=} \PYG{n}{Convert}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{str} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 22.22}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
strm调用 \sphinxstylestrong{成对的} \sphinxcode{\sphinxupquote{\textless{}\textless{}}} 和 \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}}} 之后，状态为 \sphinxcode{\sphinxupquote{end-of-file}} ，必须进行 \sphinxcode{\sphinxupquote{clear}} 才能进行下一次 \sphinxcode{\sphinxupquote{\textless{}\textless{}}} 操作。

\sphinxcode{\sphinxupquote{strm.clear()}} 重置了strm的状态标识，并没有清空数据。如果没有调用 \sphinxcode{\sphinxupquote{\textless{}\textless{}}} 之后没有使用 \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}}} ，可以使用  \sphinxcode{\sphinxupquote{strm.str("")}} 清空数据。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/10_cast:id3}}\begin{enumerate}
\item {} 
C++中四种强制类型转换区别详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/cauchy007/p/4968707.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
c++ 四种强制类型转换介绍

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/ydar95/article/details/69822540}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++中使用stringstream简化类型转换

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/Mr-Zhong/p/5312478.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
c++ reference

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cplusplus.com/reference/sstream/stringstream}

\sphinxurl{http://www.cplusplus.com/doc/tutorial/typecasting/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
C++强制类型转换操作符 const\_cast

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/QG-whz/p/4513136.html}
\end{quote}


\section{堆、栈}
\label{\detokenize{cpp/11_heapStack::doc}}\label{\detokenize{cpp/11_heapStack:id1}}
堆（Heap）与栈（Stack）有两层含义：
（1）程序内存布局场景下，堆与栈表示的是两种内存管理方式；
（2）数据结构场景下，堆与栈表示两种常用的数据结构。

栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。

堆由程序员分配释放， 若程序员不释放，程序结束时由系统回收。


\subsection{管理方式}
\label{\detokenize{cpp/11_heapStack:id2}}
栈由操作系统自动分配释放，无需我们手动控制；

堆的申请和释放工作由程序员控制，容易产生内存泄漏。


\subsection{空间大小}
\label{\detokenize{cpp/11_heapStack:id3}}
每个进程拥有的栈的大小要远远小于堆的大小。
理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小64bits的Windows默认1MB，64bits的Linux默认10MB；


\subsection{分配方式}
\label{\detokenize{cpp/11_heapStack:id4}}
堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。

动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。


\subsection{生长方式}
\label{\detokenize{cpp/11_heapStack:id5}}
堆的生长方向向上，内存地址由低到高。

栈的生长方向向下，内存地址由高到低。


\subsection{分配效率}
\label{\detokenize{cpp/11_heapStack:id6}}
栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。

堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。


\subsection{存放内容}
\label{\detokenize{cpp/11_heapStack:id7}}
栈存放函数返回地址、相关参数、局部变量和寄存器内容等。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。


\subsection{附：内存分区}
\label{\detokenize{cpp/11_heapStack:id8}}
在C++中，内存主要分为堆、栈、全局/静态存储区和常量存储区。
\begin{itemize}
\item {} 
\sphinxstylestrong{栈} ：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。

\item {} 
\sphinxstylestrong{堆} ：就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

\item {} 
\sphinxstylestrong{全局/静态存储区} ：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

\item {} 
\sphinxstylestrong{常量存储区} ：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{cpp/11_heapStack:id9}}\begin{enumerate}
\item {} 
堆与栈的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/K346K346/article/details/80849966}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C/C++——堆栈的讲解

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/lovejay7/article/details/80662390}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++ 自由存储区是否等价于堆？

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/QG-whz/p/5060894.html}
\end{quote}


\section{参数传递}
\label{\detokenize{cpp/12_argPass::doc}}\label{\detokenize{cpp/12_argPass:id1}}
当形参是引用类型时，称对应实参被 \sphinxstylestrong{引用传递} （passed by reference）或者函数被 \sphinxstylestrong{传引用调用} （called by reference）。

当实参的值被 \sphinxstylestrong{拷贝} 给形参时，形参和实参时两个相互独立的对象。这样的实参被 \sphinxstylestrong{值传递} （passed by value)或者函数被 \sphinxstylestrong{传值调用} （called by value）。


\subsection{传值参数}
\label{\detokenize{cpp/12_argPass:id2}}
当初始化一个非引用类型的变量时，初始化被拷贝给变量。此时，对变量的改动 \sphinxstylestrong{不会} 影响初始值。
\begin{description}
\item[{\sphinxstylestrong{指针形参}}] \leavevmode
指针的行为和其他 \sphinxstylestrong{非引用} 类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后， \sphinxstylestrong{两个指针是不同的指针} 。因为指针
使我们可以间接地访问它所指的对象，所以通过指针 \sphinxstylestrong{可以修改它所指的对象的值} 。

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{reset}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针p所指对象的值}
   \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 只改变了p的局部拷贝，实参未被改变}
\PYG{p}{\PYGZcb{}}

\PYG{n}{templtate}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{x}\PYG{p}{,} \PYG{n}{T}\PYG{o}{*} \PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{T}\PYG{o}{*} \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  只交换了拷贝指针的值，实际指针并未改变，因此无法达到交换的目的。}
\end{sphinxVerbatim}

为了改变实参指针的值，可以使用指针的引用或者使用指向指针的指针。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{val} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{val}\PYG{p}{;}

\PYG{c+c1}{// 调用: reset(p)}
\PYG{k+kt}{void} \PYG{n+nf}{reset}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针p所指对象的值}
    \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针p的值}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// 调用: reset(\PYGZam{}p)}
\PYG{k+kt}{void} \PYG{n+nf}{reset}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{o}{*}\PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针*p所指对象的值}
    \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 改变了指针*p的值}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{传引用参数}
\label{\detokenize{cpp/12_argPass:id3}}
通过使用引用形参，允许函数改变实参的值。

使用引用避免拷贝：拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（比如IO类型）根本不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过
引用形参访问该类型的对象。例如，需要比较两个string对象，而这样的对象可能会很长，为了避免拷贝且不改变对象的值，可以将形参声明为常量引用（const \&）。

使用引用形参返回额外信息：通过给函数传入一个额外的引用形参，让其保存需要的值，而不需要作为函数返回值返回（避免函数返回值太多）。


\subsection{参考资料}
\label{\detokenize{cpp/12_argPass:id4}}\begin{enumerate}
\item {} 
《C++ Primer 第5版 中文版》 Page 187 \textendash{} 190。

\end{enumerate}


\section{空类指针}
\label{\detokenize{cpp/13_nullClassPtr::doc}}\label{\detokenize{cpp/13_nullClassPtr:id1}}
类的成员函数并不与特定对象绑定，所有成员函数共用一份成员函数体，当程序编译后，成员函数的地址即已经确定。
那为什么同一个类的不同对象调用对应成员函数可以出现不同的结果呢？答案就是 \sphinxcode{\sphinxupquote{this}} 指针。
共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的 \sphinxcode{\sphinxupquote{this}} 指针，
成员函数中对成员变量的访问都是转化成 \sphinxstylestrong{“this-\textgreater{}数据成员”} 的方式。
因此，从这一角度说，成员函数与普通函数一样，只是多了一个隐式参数，即指向对象的 \sphinxcode{\sphinxupquote{this}} 指针。


\subsection{空类指针调用成员函数}
\label{\detokenize{cpp/13_nullClassPtr:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{TestNullPtr}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{void} \PYG{n}{print}\PYG{p}{(}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{print}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k+kt}{void} \PYG{n}{getA}\PYG{p}{(}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k+kt}{void} \PYG{n}{setA}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{virtual} \PYG{n}{test}\PYG{p}{(}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{k}{private}\PYG{o}{:}
  \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{TestNullPtr}\PYG{o}{*} \PYG{n}{ptr} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{print}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 运行成功}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getA}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 编译成功，运行失败}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setA}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 编译成功，运行失败}
\PYG{n}{ptr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 编译成功，运行失败}
\end{sphinxVerbatim}

上例中， \sphinxcode{\sphinxupquote{ptr-\textgreater{}getA()}} 和 \sphinxcode{\sphinxupquote{ptr-\textgreater{}setA()}} 都试图访问成员变量，然而 \sphinxcode{\sphinxupquote{this}} 指针为空，导致运行失败。
另外，虚函数的特性是动态绑定，运行时根据指针或引用绑定的对象是基类对象还是派生类对象调用相关函数，空指针显然会导致错误。


\subsection{参考资料}
\label{\detokenize{cpp/13_nullClassPtr:id3}}\begin{enumerate}
\item {} 
C++空指针调用成员函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/45cf10150e6b}
\end{quote}


\section{static和extern}
\label{\detokenize{cpp/14_staticExtern:staticextern}}\label{\detokenize{cpp/14_staticExtern::doc}}

\subsection{static: 静态全局变量}
\label{\detokenize{cpp/14_staticExtern:static}}
在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。
特点：
\begin{itemize}
\item {} 
该变量在 \sphinxstylestrong{全局数据区} 分配内存；

\item {} 
未经初始化的静态全局变量会被程序自动初始化为0；（自动变量的值是随机的，除非它被显式初始化）

\item {} 
静态全局变量在声明它的整个文件都是可见的，而在 \sphinxstylestrong{文件之外是不可见的} ，其它文件中可以定义相同名字的变量，不会发生冲突。

\end{itemize}


\subsection{static: 静态函数}
\label{\detokenize{cpp/14_staticExtern:id1}}
在函数的返回类型前加上static关键字，函数即被定义为静态函数。
静态函数与普通函数不同，它 \sphinxstylestrong{只能在声明它的文件当中可见} ，不能被其它文件使用。
其它文件中可以定义相同名字的函数，不会发生冲突。这点与静态全局变量相似。


\subsection{static: 静态局部变量}
\label{\detokenize{cpp/14_staticExtern:id2}}
在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。
特点：
\begin{itemize}
\item {} 
该变量在全局数据区分配内存；

\item {} 
静态局部变量在程序执行到该对象的声明处时被首次初始化，即 \sphinxstylestrong{以后的函数调用不再进行初始化} ；

\item {} 
静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；

\item {} 
它始终驻留在全局数据区，其生命周期一直持续到整个程序执行结束。但其作用域仍为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{func}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// 初次调用func()时才会执行初始化}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{a} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 1}
  \PYG{n}{func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 2}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{static: 静态成员变量}
\label{\detokenize{cpp/14_staticExtern:id3}}
在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。
特点：
\begin{itemize}
\item {} 
对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。在没有产生类的实例时，我们就可以操作它；

\item {} 
静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义；

\item {} 
静态数据成员和普通数据成员一样遵从public，protected，private访问规则；

\item {} 
（类定义体外部）静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
\sphinxcode{\sphinxupquote{＜数据类型＞ ＜类名＞::＜静态数据成员名＞ = ＜值＞}}

\item {} 
类的静态数据成员有两种访问形式：
\sphinxcode{\sphinxupquote{＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞}}

\end{itemize}


\subsection{static: 静态成员函数}
\label{\detokenize{cpp/14_staticExtern:id4}}
普通的成员函数一般都隐含了一个 \sphinxcode{\sphinxupquote{this}} 指针， \sphinxcode{\sphinxupquote{this}} 指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。
通常情况下， \sphinxcode{\sphinxupquote{this}} 是缺省的。如函数 \sphinxcode{\sphinxupquote{fn()}} 实际上是 \sphinxcode{\sphinxupquote{this-\textgreater{}fn()}} 。
但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它 \sphinxstylestrong{不具有this指针} 。
从这个意义上讲，它 \sphinxstylestrong{无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数} 。
非静态成员函数可以任意地访问静态成员函数和静态数据成员。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Myclass}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{,} \PYG{n}{b} \PYG{p}{,} \PYG{n}{c}\PYG{p}{;}
    \PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{sum}\PYG{p}{;}  \PYG{c+c1}{//声明静态数据成员}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Myclass}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{GetSum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{Myclass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}   \PYG{c+c1}{//定义并初始化静态数据成员}

\PYG{n}{Myclass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Myclass}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{c}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{a} \PYG{o}{=} \PYG{n}{a}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{c} \PYG{o}{=} \PYG{n}{c}\PYG{p}{;}
    \PYG{n}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{o}{+}\PYG{n}{c}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n}{Myclass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetSum}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{sum}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{extern: 修饰函数、变量}
\label{\detokenize{cpp/14_staticExtern:extern}}
修饰符 \sphinxcode{\sphinxupquote{extern}} 用在变量或者函数的声明前，用来说明 \sphinxstylestrong{“此变量/函数是在别处定义的，要在此处引用”} 。
在别的文件中如果想调用 \sphinxcode{\sphinxupquote{file1.c}} 中的变量a，只须用 \sphinxcode{\sphinxupquote{extern}} 进行声明即可调用a:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{extern} \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{// file2.c}
\PYG{k}{extern} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}} \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{// file3.cpp}
\end{sphinxVerbatim}

在这里要注意 \sphinxcode{\sphinxupquote{extern}} 声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。
其实要调用其它文件中的函数和变量，只需把该文件用\#include包含进来即可，但是用 \sphinxcode{\sphinxupquote{extern}} 会加速程序的编译过程，这样能节省时间。


\subsection{extern “C” \{\}}
\label{\detokenize{cpp/14_staticExtern:extern-c}}

\subsubsection{例子}
\label{\detokenize{cpp/14_staticExtern:id5}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef HEADER\PYGZus{}INCLUDED }\PYG{c+c1}{// 条件编译，避免重复包含头文件}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define HEADER\PYGZus{}INCLUDED}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}cplusplus }\PYG{c+c1}{// extern \PYGZdq{}C\PYGZdq{} 只用在c++文件中}
\PYG{k}{extern} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}} \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* \PYGZus{}\PYGZus{}cplusplus */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}c.h\PYGZdq{}}

\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{strcpy}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/*.................................}
\PYG{c+cm}{ * do something else}
\PYG{c+cm}{ *.................................}
\PYG{c+cm}{ */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}cplusplus}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* \PYGZus{}\PYGZus{}cplusplus */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* HEADER\PYGZus{}INCLUDED */}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{extern "C"}} 中的 \sphinxcode{\sphinxupquote{C}} ，表示的一种编译和连接规约，表明它按照类C的编译和连接规约来编译和连接，而不是一种语言。
\sphinxcode{\sphinxupquote{C}} 表示 \sphinxstylestrong{符合C语言的编译和连接规约的任何语言} ，如Fortran、assembler等。
\sphinxcode{\sphinxupquote{extern "C"}} 的真实目的是实现 \sphinxstylestrong{类C} 和C++的混合编程。


\subsection{参考资料}
\label{\detokenize{cpp/14_staticExtern:id6}}\begin{enumerate}
\item {} 
C/C++中的static关键字详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/qintangtao/p/3285937.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++项目中的extern “C” \{\}

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
浅谈C/C++中的static和extern关键字

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/dolphin0520/archive/2011/04/20/2022701.html}
\end{quote}


\section{public、protected、private}
\label{\detokenize{cpp/15_classAccess::doc}}\label{\detokenize{cpp/15_classAccess:publicprotectedprivate}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{类成员访问权限（可访问： \(\checkmark\)）}\label{\detokenize{cpp/15_classAccess:id3}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
权限
&\sphinxstyletheadfamily 
类成员
&\sphinxstyletheadfamily 
类对象
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
友元函数
\\
\hline
public
&
\(\checkmark\)
&
\(\checkmark\)
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
private
&
\(\checkmark\)
&
\(\times\)
&
\(\times\)
&
\(\checkmark\)
\\
\hline
protected
&
\(\checkmark\)
&
\(\times\)
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{继承}
\label{\detokenize{cpp/15_classAccess:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{public继承下对基类成员的访问权限}\label{\detokenize{cpp/15_classAccess:id4}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
内部权限
&\sphinxstyletheadfamily 
权限变化(相对于派生类)
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
派生类对象
\\
\hline
public
&
-\textgreater{} public
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
private
&
-\textgreater{} private
&
\(\times\)
&
\(\times\)
\\
\hline
protected
&
-\textgreater{} protected
&
\(\checkmark\)
&
\(\times\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{private继承下对基类成员的访问权限}\label{\detokenize{cpp/15_classAccess:id5}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
内部权限
&\sphinxstyletheadfamily 
权限变化(相对于派生类)
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
派生类对象
\\
\hline
public
&
-\textgreater{} private
&
\(\checkmark\)
&
\(\times\)
\\
\hline
private
&
-\textgreater{} private
&
\(\times\)
&
\(\times\)
\\
\hline
protected
&
-\textgreater{} private
&
\(\checkmark\)
&
\(\times\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{protected继承下对基类成员的访问权限}\label{\detokenize{cpp/15_classAccess:id6}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
内部权限
&\sphinxstyletheadfamily 
权限变化(相对于派生类)
&\sphinxstyletheadfamily 
派生类成员
&\sphinxstyletheadfamily 
派生类对象
\\
\hline
public
&
-\textgreater{} protected
&
\(\checkmark\)
&
\(\times\)
\\
\hline
private
&
-\textgreater{} private
&
\(\times\)
&
\(\times\)
\\
\hline
protected
&
-\textgreater{} protected
&
\(\checkmark\)
&
\(\times\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{class与struct}
\label{\detokenize{cpp/15_classAccess:classstruct}}
class不写权限修饰符，成员默认是 \sphinxcode{\sphinxupquote{private}} ，而struct的成员默认是 \sphinxcode{\sphinxupquote{public}} 。

class的继承默认是 \sphinxcode{\sphinxupquote{private}} 的，而struct默认是 \sphinxcode{\sphinxupquote{public}} 的。


\subsection{参考资料}
\label{\detokenize{cpp/15_classAccess:id2}}\begin{enumerate}
\item {} 
C++中关于public、protect、private的访问权限控制

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/ycf74514/article/details/49053041}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++的关键字public,private和protected

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/943c0d2fe292}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++中public,protected,private访问

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/jiudianren/p/5668438.html}
\end{quote}


\section{类的static const成员}
\label{\detokenize{cpp/16_staticconst:static-const}}\label{\detokenize{cpp/16_staticconst::doc}}

\subsection{const 成员}
\label{\detokenize{cpp/16_staticconst:const}}
const数据成员的初始化只能在类的构造函数的初始化列表中进行。声明const变量时不能初始化。

\begin{sphinxadmonition}{note}{Note:}
必须使用初始化列表的情形
\begin{itemize}
\item {} 
\sphinxstylestrong{常量成员} ，因为常量只能初始化不能赋值，所以必须放在初始化列表里面。

\item {} 
\sphinxstylestrong{引用类型} ，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面。

\item {} 
没有默认构造函数的 \sphinxstylestrong{类类型} ，因为使用初始化列表不调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
成员是按照他们在类中 \sphinxstylestrong{声明} 的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的。
\end{sphinxadmonition}


\subsection{static 成员}
\label{\detokenize{cpp/16_staticconst:static}}
不能在定义对象时对静态变量进行 \sphinxstylestrong{定义和初始化} ，即不能用构造函数进行初始化。
初始化在类体外进行，前面不加static修饰符。


\subsection{static const 成员}
\label{\detokenize{cpp/16_staticconst:id1}}
静态常量成员，可以直接初始化（static cosnt 和 const static 含义相同）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/* header.h */}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k}{static} \PYG{k+kt}{void} \PYG{n}{print}\PYG{p}{(}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{var} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 100}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{mapping}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// \PYGZsq{}a\PYGZsq{}}
  \PYG{p}{\PYGZcb{}}

\PYG{k}{private}\PYG{o}{:}
  \PYG{k}{static} \PYG{k}{const} \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{mapping}\PYG{p}{;} \PYG{c+c1}{// 常量声明式}
  \PYG{k}{static} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{var} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{c+c1}{// 常量声明式（直接初始化）}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* source.cpp */}
\PYG{k}{const} \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{Solution}\PYG{o}{:}\PYG{o}{:} \PYG{n}{mapping} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{2}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{b}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                                    \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{3}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{d}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{e}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{f}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                                    \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{4}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{g}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{h}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{i}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// mapping 的定义}

\PYG{c+c1}{// 注：const map只能通过迭代器 const\PYGZus{}iterator 访问元素（it\PYGZhy{}\PYGZgt{}first, it\PYGZhy{}\PYGZgt{}second），不能通过下标[]的方式访问。}

\PYG{c+c1}{// 对应类的 static const int/char/bool 成员常量，如果不取他们的地址，则可以直接声明并使用，而无需提供以下的定义式。}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{Solution}\PYG{o}{:}\PYG{o}{:} \PYG{n}{var}\PYG{p}{;} \PYG{c+c1}{// var 的定义。由于 常量var 在类内声明时已经获得了初始值，因此定义时不可以再设初始值。}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{初始化} ：变量还没有值，现在赋予它一个值。

\sphinxstylestrong{赋值} ：变量已经有一个值，现在擦除它之前的值，赋予一个新的值。
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxstylestrong{static} 和 \sphinxstylestrong{const}  不能 \sphinxstylestrong{同时} 修饰成员函数，只能修饰成员变量。
因为常量成员函数（const）拥有一个 \sphinxstylestrong{this} 指针，是一个指向常量类类型的常量指针，而静态成员函数（static）没有 \sphinxstylestrong{this} 指针。
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}\begin{description}
\item[{头文件中应该写什么？}] \leavevmode\begin{itemize}
\item {} 
变量和函数的声明，而不是定义。如：\sphinxcode{\sphinxupquote{extern int a; void f();}} 是允许的，而 \sphinxcode{\sphinxupquote{int a; void f() \{\};}} 是不允许的。

\item {} 
const全局变量可以定义在头文件中，不会因为头文件重复包含而导致变量重复定义的编译错误。
但是在定义指针时要注意， \sphinxcode{\sphinxupquote{const char* p = "name"}} 定义的指针不是const，可能导致错误；而 \sphinxcode{\sphinxupquote{char* const p = "name"}} 不会。

\item {} 
内联函数。

\item {} 
类的定义。成员函数定义在类的定义体内，编译器会视其为内联函数；如果定义在类的头文件内，而没有写进类定义体内，是不合法的，需要定义
在别的源文件（.cpp）文件内。

\item {} 
函数模板和类模板成员函数。

\end{itemize}

\end{description}

把声明在头文件（header.h）中的函数或类成员函数定义在一个源文件（source1.cpp）中，需要包含该头文件（\#include “header.h”），当
另一个源文件（source2.cpp）需要调用上述函数时，只需要包含头文件（\#include “header.h”），而不是包含函数定义的源文件（source1.cpp）。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/16_staticconst:id2}}\begin{enumerate}
\item {} 
C++ static、const和static const类型成员变量声明以及初始化

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/hustfeiji/articles/5168529.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
头文件中定义 const 全局变量应注意的问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/mafuli007/article/details/8499585}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
头文件重复包含和变量重复定义

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/u014557232/article/details/50354127}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
C++ 初始化列表

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
C++的一大误区——深入解释直接初始化与复制初始化的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/ljianhui/article/details/9245661}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
C++构造函数初始化列表与赋值

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/sz-leez/p/7082865.html}

\sphinxurl{http://www.cnblogs.com/BlueTzar/articles/1223169.html}
\end{quote}


\section{枚举类型与共用体}
\label{\detokenize{cpp/17_enumUnion::doc}}\label{\detokenize{cpp/17_enumUnion:id1}}

\subsection{枚举类型}
\label{\detokenize{cpp/17_enumUnion:id2}}
枚举类型（enumeration）使我们可以将一组 \sphinxstylestrong{整型常量} 组织在一起。格式

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{enum} \PYG{o}{\PYGZlt{}}\PYG{n}{类型名}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZob{}}\PYG{o}{\PYGZlt{}}\PYG{n}{枚举成员}\PYG{o}{\PYGZgt{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

枚举成员不能是数值，即不能是类似于\{1,2,3\}。可以定义 \sphinxstylestrong{无类型名} 的枚举类型。


\subsubsection{初始化}
\label{\detokenize{cpp/17_enumUnion:id3}}
默认情况下，每个枚举变量的值就是其序号，从0开始，依次加1。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n}{Week} \PYG{p}{\PYGZob{}}\PYG{n}{Sun}\PYG{p}{,} \PYG{n}{Mon}\PYG{p}{,} \PYG{n}{Tue}\PYG{p}{,} \PYG{n}{Wed}\PYG{p}{,} \PYG{n}{Thu}\PYG{p}{,} \PYG{n}{Fri}\PYG{p}{,} \PYG{n}{Sat}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{//Sun=0, Mon=1, Tue=2, Wed=3, Thu=4, Fri=5, Sat=6}
\end{sphinxVerbatim}

显式提供初始值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n}{Week} \PYG{p}{\PYGZob{}}\PYG{n}{Sun}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Mon}\PYG{p}{,} \PYG{n}{Tue}\PYG{p}{,} \PYG{n}{Wed}\PYG{p}{,} \PYG{n}{Thu}\PYG{p}{,} \PYG{n}{Fri}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{Sat}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{//Sun=1, Mon=2, Tue=3, Wed=4, Thu=5, Fri=100, Sat=101}
\end{sphinxVerbatim}


\subsubsection{枚举变量}
\label{\detokenize{cpp/17_enumUnion:id4}}
定义枚举类型之后，就可以定义该枚举类型的变量，或者与枚举类型同时定义。枚举变量的值只能取枚举常量表中所列的值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{enum} \PYG{n}{Week} \PYG{p}{\PYGZob{}}\PYG{n}{Sun}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Mon}\PYG{p}{,} \PYG{n}{Tue}\PYG{p}{,} \PYG{n}{Wed}\PYG{p}{,} \PYG{n}{Thu}\PYG{p}{,} \PYG{n}{Fri}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{Sat}\PYG{p}{\PYGZcb{}} \PYG{n}{day\PYGZus{}1}\PYG{p}{;}
\PYG{c+c1}{// 全局变量 day\PYGZus{}1 默认初始化为 0。}

\PYG{k+kt}{void} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{num}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{num} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{n}{Week} \PYG{n}{day}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{day}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Week} \PYG{n}{day\PYGZus{}2}\PYG{p}{,} \PYG{n}{day\PYGZus{}3}\PYG{p}{;}

  \PYG{n}{day\PYGZus{}1} \PYG{o}{=} \PYG{n}{Sun}\PYG{p}{;} \PYG{c+c1}{// 或者 day\PYGZus{}1 = Week::Sun （不限定作用域的枚举类型）}
  \PYG{n}{day\PYGZus{}2} \PYG{o}{=} \PYG{n}{day\PYGZus{}1}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{day\PYGZus{}1}\PYG{p}{;} \PYG{c+c1}{// i = 1}
  \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{Mon}\PYG{p}{;} \PYG{c+c1}{// j = 2}

  \PYG{n}{Week} \PYG{n}{day\PYGZus{}4}\PYG{p}{(}\PYG{n}{Week}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// day\PYGZus{}4 = Fri}
  \PYG{k+kt}{bool} \PYG{n}{equal} \PYG{o}{=} \PYG{p}{(}\PYG{n}{day\PYGZus{}4} \PYG{o}{=}\PYG{o}{=} \PYG{n}{Fri}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// true}

  \PYG{n}{Week} \PYG{n}{day\PYGZus{}5}\PYG{p}{(}\PYG{n}{Week}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 越界，但是不报错，day\PYGZus{}5 = \PYGZhy{}1 （VS 2013）}

  \PYG{n}{ff}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 匹配 ff(int)，输出 \PYGZhy{}10}
  \PYG{n}{ff}\PYG{p}{(}\PYG{n}{day\PYGZus{}1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 匹配 ff(Week)，输出 10}
  \PYG{n}{ff}\PYG{p}{(}\PYG{n}{Fri}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 匹配 ff(Week)，输出 1000}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{共用体}
\label{\detokenize{cpp/17_enumUnion:id5}}
共用体（union）及其变量的定义形式与结构体类似。共用体成员访问方式也是使用运算符 \sphinxcode{\sphinxupquote{.}} 或 \sphinxcode{\sphinxupquote{-\textgreater{}}}。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{union} \PYG{n}{ifcd}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
  \PYG{k+kt}{float} \PYG{n}{f}\PYG{p}{;}
  \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{o}{*}\PYG{n}{pu}\PYG{p}{;}
\PYG{c+c1}{// 同结构体一样，分号不能丢}
\end{sphinxVerbatim}

与结构体的异同：
\begin{itemize}
\item {} 
存储分配方式
\begin{itemize}
\item {} 
结构体每个成员各自占有自己的存储单元、各自的地址，结构体占有的内存空间大小是所有成员所占存储单元的总和。

\item {} 
共用体各个成员占用共同的存储单元，具有 \sphinxstylestrong{相同的首地址} ，占用存储单元最多的成员的长度就是共用体的长度。一个共用体
可以包含多个不同类型的成员，但是每一时刻只有 \sphinxstylestrong{一个成员有效} ，即最后一次存放的数据成员起作用。虽然仍然可以访问无效的成员，但是结果是未知的。
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x1}\PYG{p}{.}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{256}\PYG{p}{;}
\PYG{n}{x1}\PYG{p}{.}\PYG{n}{c} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{A}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{x1}\PYG{p}{.}\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.23}\PYG{p}{;}
\PYG{c+c1}{// 三步操作之后，只有 x1.f 有效。}
\end{sphinxVerbatim}
\end{quote}

\end{itemize}

\item {} 
初始化
\begin{itemize}
\item {} 
结构变量或数组可以为所有成员初始化。

\item {} 
共用体变量或数组在初始化时，只能对初始化它的 \sphinxstylestrong{第一个成员} ，对多个成员初始化是不允许的。
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{union} \PYG{n}{ifcd} \PYG{n}{x3} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{256}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{x4}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// 对成员 i 初始化}
\end{sphinxVerbatim}
\end{quote}

\end{itemize}

\item {} 
结构体和共用体可以相互出现在对方的类型定义中。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{cpp/17_enumUnion:id6}}
1.《C++ Primer 第5版 中文版》 Page 736 \textendash{} 739。
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++ 枚举类型详解

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.runoob.com/w3cnote/cpp-enum-intro.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++枚举（enum）的优雅用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/daizhiyan1/article/details/82428023}
\end{quote}


\section{常用函数}
\label{\detokenize{cpp/18_commonFunc::doc}}\label{\detokenize{cpp/18_commonFunc:id1}}
以下函数基于 C++11 标准。


\subsection{lower\_bound，upper\_bound}
\label{\detokenize{cpp/18_commonFunc:lower-bound-upper-bound}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{lower\_bound} 从排好序的数组区间 \sphinxstylestrong{{[}first,last)} 中，采用二分查找，返回 \sphinxstylestrong{大于或等于} val的 \sphinxstylestrong{第一个} 元素位置。
如果所有元素都小于val，则返回last。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{ForwardIterator} \PYG{n}{lower\PYGZus{}bound} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{upper\_bound} 从排好序的数组区间 \sphinxstylestrong{{[}first,last)} 中，采用二分查找，返回 \sphinxstylestrong{大于} val的 \sphinxstylestrong{第一个} 元素位置。
如果所有元素都不大于val，则返回last。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{ForwardIterator} \PYG{n}{upper\PYGZus{}bound} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

求有序数组中val的个数：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{first}\PYG{p}{,} \PYG{n}{last}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{first}\PYG{p}{,} \PYG{n}{last}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 4}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 8}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 用 a 对 v 初始化}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 4}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 8}

  \PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{500}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{ai} \PYG{p}{:} \PYG{n}{a}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ai} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends}\PYG{p}{;} \PYG{c+c1}{// 1 2 3 4 500 5 5 5 6 7 8}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{500}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{vi} \PYG{p}{:} \PYG{n}{v}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends}\PYG{p}{;} \PYG{c+c1}{// 1 2 3 4 500 5 5 5 6 7 8}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{fill，fill\_n，for\_each}
\label{\detokenize{cpp/18_commonFunc:fill-fill-n-for-each}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{fill} 函数将一个区间 \sphinxstylestrong{{[}first,last)} 的每个元素都赋予val值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{fill} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{fill\_n} 函数从 \sphinxstylestrong{first} 开始依次赋予n个元素val值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{OutputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Size}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{fill\PYGZus{}n} \PYG{p}{(}\PYG{n}{OutputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{Size} \PYG{n}{n}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{for\_each} 把函数fn应用于区间 \sphinxstylestrong{{[}first,last)} 的每个元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Function}\PYG{o}{\PYGZgt{}}
\PYG{n}{Function} \PYG{n}{for\PYGZus{}each} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{Function} \PYG{n}{fn}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{print}\PYG{p}{(}\PYG{n}{T} \PYG{n}{elem}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{elem} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{k+kt}{float} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+m+mf}{0.0} \PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}0.0, 0.0, 0.0, 0.0\PYGZcb{}}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}0, 0, 0, 0\PYGZcb{}}

  \PYG{n}{fill}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mf}{3.3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}3.3, 3.3, 3.3, 3.3\PYGZcb{}}
  \PYG{n}{fill\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{6.6}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}6.6, 6.6, 3.3, 3.3\PYGZcb{}}
  \PYG{n}{fill\PYGZus{}n}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZob{}9, 9, 9, 9\PYGZcb{}}

  \PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{print}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//  6.6 6.6 3.3 3.3}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{print}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//  9 9 9 9}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{;}
  \PYG{n}{fill}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// b 所有元素为 2}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

最长上升子序列：

\fvset{hllines={, 11, 12, 13,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/* https://leetcode.com/problems/longest\PYGZhy{}increasing\PYGZhy{}subsequence/ */}
\PYG{c+cm}{/* O(nlogn) in time.*/}

\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{int} \PYG{n}{lengthOfLIS}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{inf} \PYG{o}{=} \PYG{n}{INT\PYGZus{}MAX}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{len} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{dp} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{len}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{fill}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{inf}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{length} \PYG{o}{=} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{inf}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{dp}\PYG{p}{;}
    \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{dp}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{length}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{sort}
\label{\detokenize{cpp/18_commonFunc:sort}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}

\PYG{c+c1}{// default}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{RandomAccessIterator}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{sort} \PYG{p}{(}\PYG{n}{RandomAccessIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{RandomAccessIterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{RandomAccessIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Compare}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{sort} \PYG{p}{(}\PYG{n}{RandomAccessIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{RandomAccessIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{Compare} \PYG{n}{comp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}functional\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{comparator}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{struct} \PYG{n}{myclass}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}} \PYG{n}{myobject}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{71}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{26}\PYG{p}{,} \PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{53}\PYG{p}{,} \PYG{l+m+mi}{33} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}               \PYG{c+c1}{// 32 71 12 45 26 80 53 33}

  \PYG{c+c1}{// using default comparison (operator \PYGZlt{}):}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}           \PYG{c+c1}{//(12 32 45 71)26 80 53 33}

  \PYG{c+c1}{// using comparator as comp}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{comparator}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 12 32 45 71(26 33 53 80)}

  \PYG{c+c1}{// using object as comp}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{myobject}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{//(12 26 32 33 45 53 71 80)}

  \PYG{c+c1}{// using build\PYGZhy{}in comp: greater}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{greater}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// (80 71 53 45 33 32 26 12)}

  \PYG{c+c1}{// using build\PYGZhy{}in comp: less}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{less}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//(12 26 32 33 45 53 71 80)}

  \PYG{c+c1}{// using reverse\PYGZus{}iterator}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{rbegin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{rend}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// (80 71 53 45 33 32 26 12)}

  \PYG{c+c1}{// sort array}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{greater}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// (80 71 53 45 33 32 26 12)}
  \PYG{n}{sort}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}                 \PYG{c+c1}{// (12 26 32 33 45 53 71 80)，可使用 comparator、myobject、less\PYGZlt{}int\PYGZgt{}()}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxstylestrong{string} 类也是可以排序的，如

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n}{str}\PYG{p}{;}
\PYG{n}{sort}\PYG{p}{(}\PYG{n}{str}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{str}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
如果把自定义的 \sphinxcode{\sphinxupquote{comparator}} 函数封装为类的成员函数，应该定义为 \sphinxstylestrong{静态成员函数（static）} 。
\end{sphinxadmonition}


\subsection{reverse}
\label{\detokenize{cpp/18_commonFunc:reverse}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{BidirectionalIterator}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{reverse} \PYG{p}{(}\PYG{n}{BidirectionalIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{BidirectionalIterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

翻转区间 {[}first,last) 内的元素。适用于 vector、string 以及 静态数组、动态数组等。

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}     // std::cout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}    // std::reverse}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}      // std::iota}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}       // std::vector}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{myvector}\PYG{p}{;}

  \PYG{c+c1}{// set some values:}
  \PYG{n}{myvector}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iota}\PYG{p}{(}\PYG{n}{myvector}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{myvector}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// 1 2 3 4 5 6 7 8 9}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{reverse}\PYG{p}{(}\PYG{n}{myvector}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{myvector}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// 9 8 7 6 5 4 3 2 1}

  \PYG{c+c1}{// print out content:}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myvector contains:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{o}{=}\PYG{n}{myvector}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it}\PYG{o}{!}\PYG{o}{=}\PYG{n}{myvector}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{it}\PYG{p}{)}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{min\_element，max\_element，minmax\_element}
\label{\detokenize{cpp/18_commonFunc:min-element-max-element-minmax-element}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{min\_element} ：会返回指向输入序列的最小元素的迭代器；

\item {} 
\sphinxstylestrong{max\_element} ：会返回指向最大元素的迭代器；

\item {} 
\sphinxstylestrong{minmax\_element} ：会以 pair 对象的形式返回这两个迭代器。first 指向最小元素。second 指向最大元素。

\end{itemize}

\sphinxstylestrong{min\_element}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// default}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{o}{\PYGZgt{}}
\PYG{n}{ForwardIterator} \PYG{n}{min\PYGZus{}element} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Compare}\PYG{o}{\PYGZgt{}}
\PYG{n}{ForwardIterator} \PYG{n}{min\PYGZus{}element} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{Compare} \PYG{n}{comp}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// [first,last)}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 0}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{min\PYGZus{}element}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 0}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{max\PYGZus{}element}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 6}

  \PYG{k}{auto} \PYG{n}{p} \PYG{o}{=} \PYG{n}{minmax\PYGZus{}element}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ends} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 0 6}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{accumulate}
\label{\detokenize{cpp/18_commonFunc:accumulate}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}

\PYG{c+c1}{// sum}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{T} \PYG{n}{accumulate} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{T} \PYG{n}{init}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BinaryOperation}\PYG{o}{\PYGZgt{}}
\PYG{n}{T} \PYG{n}{accumulate} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{T} \PYG{n}{init}\PYG{p}{,} \PYG{n}{BinaryOperation} \PYG{n}{binary\PYGZus{}op}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

累加区间 \sphinxstylestrong{{[}first,last)} 的元素，并加上 \sphinxstylestrong{init} 。

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}     // std::cout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}functional\PYGZgt{}   // std::minus}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}      // std::accumulate}

\PYG{k+kt}{int} \PYG{n+nf}{myfunction} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{y}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k}{struct} \PYG{n}{myclass}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{y}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}} \PYG{n}{myobject}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{init} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numbers}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using default accumulate: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{numbers}\PYG{p}{,}\PYG{n}{numbers}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{init}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 + (10 + 20 + 30)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using functional\PYGZsq{}s minus: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{accumulate} \PYG{p}{(}\PYG{n}{numbers}\PYG{p}{,} \PYG{n}{numbers}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{init}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{minus}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 \PYGZhy{} (10 + 20 + 30)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using custom function: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{accumulate} \PYG{p}{(}\PYG{n}{numbers}\PYG{p}{,} \PYG{n}{numbers}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{init}\PYG{p}{,} \PYG{n}{myfunction}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 + 2 * (10 + 20 + 30)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using custom object: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{accumulate} \PYG{p}{(}\PYG{n}{numbers}\PYG{p}{,} \PYG{n}{numbers}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{init}\PYG{p}{,} \PYG{n}{myobject}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 + 3 * (10 + 20 + 30)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{partial\_sum}
\label{\detokenize{cpp/18_commonFunc:partial-sum}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}
\end{sphinxVerbatim}

累加，并把结果存到序列（数组、向量） \sphinxstylestrong{result} 中。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// sum}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{OutputIterator}\PYG{o}{\PYGZgt{}}
\PYG{n}{OutputIterator} \PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{OutputIterator} \PYG{n}{result}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{OutputIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BinaryOperation}\PYG{o}{\PYGZgt{}}
\PYG{n}{OutputIterator} \PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{,}
                            \PYG{n}{OutputIterator} \PYG{n}{result}\PYG{p}{,}
                            \PYG{n}{BinaryOperation} \PYG{n}{binary\PYGZus{}op}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// y0 = x0}
\PYG{c+c1}{// y1 = x0 + x1}
\PYG{c+c1}{// y2 = x0 + x1 + x2}
\PYG{c+c1}{// y3 = x0 + x1 + x2 + x3}
\PYG{c+c1}{// y4 = x0 + x1 + x2 + x3 + x4}
\PYG{c+c1}{// ... ... ...}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}     // std::cout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}functional\PYGZgt{}   // std::multiplies}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}      // std::partial\PYGZus{}sum}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{myop} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{val}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{result}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{val}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using default partial\PYGZus{}sum: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;} \PYG{c+c1}{// 1 3 6 10 15}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{result\PYGZus{}vec}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 0 0 0 0 0 0}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{val}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{result\PYGZus{}vec}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 1 3 6 10 15 0}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{val}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{result}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{multiplies}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 1 2 6 24 120}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using functional operation multiplies: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{partial\PYGZus{}sum} \PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{val}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{result}\PYG{p}{,} \PYG{n}{myop}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 1 4 8 13 19}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using custom function: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{iota}
\label{\detokenize{cpp/18_commonFunc:iota}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{ForwardIterator}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{iota} \PYG{p}{(}\PYG{n}{ForwardIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{ForwardIterator} \PYG{n}{last}\PYG{p}{,} \PYG{n}{T} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

采用递增的形式，将val开始的等差数列赋值给区间 {[}first,last) 的元素。

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}     // std::cout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}      // std::iota}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{float} \PYG{n}{numbers}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iota} \PYG{p}{(}\PYG{n}{numbers}\PYG{p}{,}\PYG{n}{numbers}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mf}{3.5}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{numbers:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{float}\PYG{o}{\PYGZam{}} \PYG{n+nl}{i}\PYG{p}{:}\PYG{n}{numbers}\PYG{p}{)} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{p}{;} \PYG{c+c1}{// 3.5 4.5 5.5 6.5 7.5 8.5 9.5 10.5 11.5 12.5}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{inner\_product}
\label{\detokenize{cpp/18_commonFunc:inner-product}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}

\PYG{c+c1}{// sum/multiply}
\PYG{n}{emplate} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator1}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{InputIterator2}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{T} \PYG{n}{inner\PYGZus{}product} \PYG{p}{(}\PYG{n}{InputIterator1} \PYG{n}{first1}\PYG{p}{,} \PYG{n}{InputIterator1} \PYG{n}{last1}\PYG{p}{,} \PYG{n}{InputIterator2} \PYG{n}{first2}\PYG{p}{,} \PYG{n}{T} \PYG{n}{init}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// custom}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator1}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{InputIterator2}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BinaryOperation1}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{BinaryOperation2}\PYG{o}{\PYGZgt{}}
\PYG{n}{T} \PYG{n}{inner\PYGZus{}product} \PYG{p}{(}\PYG{n}{InputIterator1} \PYG{n}{first1}\PYG{p}{,} \PYG{n}{InputIterator1} \PYG{n}{last1}\PYG{p}{,}
                 \PYG{n}{InputIterator2} \PYG{n}{first2}\PYG{p}{,}
                 \PYG{n}{T} \PYG{n}{init}\PYG{p}{,}
                 \PYG{n}{BinaryOperation1} \PYG{n}{binary\PYGZus{}op1}\PYG{p}{,}
                 \PYG{n}{BinaryOperation2} \PYG{n}{binary\PYGZus{}op2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

内积运算，再与 \sphinxstylestrong{init} 做运算:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{first1}\PYG{o}{!}\PYG{o}{=}\PYG{n}{last1}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{init} \PYG{o}{=} \PYG{n}{init} \PYG{o}{+} \PYG{p}{(}\PYG{o}{*}\PYG{n}{first1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{o}{*}\PYG{n}{first2}\PYG{p}{)}\PYG{p}{;}
  \PYG{c+c1}{// or: init = binary\PYGZus{}op1 (init, binary\PYGZus{}op2(*first1,*first2));}
  \PYG{o}{+}\PYG{o}{+}\PYG{n}{first1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{first2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{return} \PYG{n}{init}\PYG{p}{;}
\end{sphinxVerbatim}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}     // std::cout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}functional\PYGZgt{}   // std::minus, std::divides}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}      // std::inner\PYGZus{}product}

\PYG{k+kt}{int} \PYG{n+nf}{myaccumulator} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{n+nf}{myproduct} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{init} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{series1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{series2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using default inner\PYGZus{}product: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{inner\PYGZus{}product}\PYG{p}{(}\PYG{n}{series1}\PYG{p}{,}\PYG{n}{series1}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{series2}\PYG{p}{,}\PYG{n}{init}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 + (10*1 + 20*2 + 30*3)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using functional operations: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{inner\PYGZus{}product}\PYG{p}{(}\PYG{n}{series1}\PYG{p}{,}\PYG{n}{series1}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{series2}\PYG{p}{,}\PYG{n}{init}\PYG{p}{,}
                                  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{minus}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{divides}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 \PYGZhy{} (10/1 + 20/2 + 30/3)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{using custom functions: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{inner\PYGZus{}product}\PYG{p}{(}\PYG{n}{series1}\PYG{p}{,}\PYG{n}{series1}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{series2}\PYG{p}{,}\PYG{n}{init}\PYG{p}{,}
                                  \PYG{n}{myaccumulator}\PYG{p}{,}\PYG{n}{myproduct}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 100 \PYGZhy{} (10+1 + 20+2 + 30+3)}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{memset}
\label{\detokenize{cpp/18_commonFunc:memset}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}

\PYG{k+kt}{void} \PYG{o}{*} \PYG{n+nf}{memset} \PYG{p}{(} \PYG{k+kt}{void} \PYG{o}{*} \PYG{n}{ptr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{value}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{num} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{memset} 按 \sphinxstylestrong{字节} 赋值， \sphinxstylestrong{fill} 按 \sphinxstylestrong{元素} 赋值。

如果用memset给int型变量赋值，只能是0或-1。

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{char} \PYG{n}{str}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{almost every programmer should know memset!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{memset} \PYG{p}{(}\PYG{n}{str}\PYG{p}{,}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{str} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} every programmer should know memset!}

  \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
  \PYG{n}{memset}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 或者 10*10*sizeof(int)，全部赋值为\PYGZhy{}1}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n+nl}{e}\PYG{p}{:}\PYG{n}{a}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bitset}\PYG{o}{\PYGZlt{}}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 11111111  11111111  11111111  11111111 （补码）}

  \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
  \PYG{n}{memset}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 或者 5*sizeof(int)，全部赋值为 16843009}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n+nl}{e}\PYG{p}{:}\PYG{n}{b}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bitset}\PYG{o}{\PYGZlt{}}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// 00000001 00000001 00000001 00000001 （int型占4字节，每个字节都赋值为1）}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{附：头文件}
\label{\detokenize{cpp/18_commonFunc:id2}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cmath}}
\begin{itemize}
\item {} 
pow()

\item {} 
sqrt()

\item {} 
floor()

\item {} 
ceil()

\item {} 
round()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{cstdlib}}
\begin{itemize}
\item {} 
abs()

\item {} 
fabs()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{limits}}
\begin{itemize}
\item {} 
INT\_MIN: \sphinxcode{\sphinxupquote{(signed int)0x80000000}}

\item {} 
INT\_MAX: \sphinxcode{\sphinxupquote{0x7fffffff}}

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{algorithm}}
\begin{itemize}
\item {} 
min()

\item {} 
max()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{utility}}
\begin{itemize}
\item {} 
pair

\item {} 
move

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{functional}}
\begin{itemize}
\item {} 
less\textless{} \sphinxstyleemphasis{TYPE} \textgreater{}()

\item {} 
greater\textless{} \sphinxstyleemphasis{TYPE} \textgreater{}()

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{cassert}}
\begin{itemize}
\item {} 
assert()

\end{itemize}

\end{itemize}


\subsection{参考资料}
\label{\detokenize{cpp/18_commonFunc:id3}}\begin{enumerate}
\item {} 
C++ reference

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/lower\_bound}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/upper\_bound}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/fill}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/for\_each}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/sort}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/reverse}

\sphinxurl{http://www.cplusplus.com/reference/algorithm/min\_element}

\sphinxurl{http://www.cplusplus.com/reference/numeric/accumulate}

\sphinxurl{http://www.cplusplus.com/reference/numeric/partial\_sum}

\sphinxurl{http://www.cplusplus.com/reference/numeric/iota}

\sphinxurl{http://www.cplusplus.com/reference/numeric/inner\_product}

\sphinxurl{http://www.cplusplus.com/reference/cstring/memset}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C/C++-STL中lower\_bound与upper\_bound的用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/jadeyansir/article/details/77015626}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
c++sort函数的使用总结

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/TX980502/p/8528840.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
C++ sort排序函数用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/w\_linux/article/details/76222112}
\end{quote}


\section{常用STL类及容器}
\label{\detokenize{cpp/19_stl:stl}}\label{\detokenize{cpp/19_stl::doc}}
\sphinxstylestrong{STL: Standard Template Library} ，标准模板库。

以下基于 C++11 标准。
\begin{description}
\item[{顺序容器}] \leavevmode\begin{itemize}
\item {} 
array

\item {} 
vector

\item {} 
list

\item {} 
deque

\item {} 
string

\item {} 
…

\end{itemize}

\item[{关联容器}] \leavevmode\begin{itemize}
\item {} 
set

\item {} 
map

\item {} 
multiset

\item {} 
multimap

\item {} 
…

\end{itemize}

\item[{容器适配器}] \leavevmode\begin{itemize}
\item {} 
stack

\item {} 
queue

\item {} 
priority\_queue

\end{itemize}

\end{description}

一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。默认情况下，stack和queue基于deque实现，priority\_queue基于vector实现。


\subsection{string}
\label{\detokenize{cpp/19_stl:string}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
长度：length()，size()，empty()

\item {} 
访问：{[}pos{]}，at(pos)。at()返回位置pos处元素的引用，越界则抛出 \sphinxcode{\sphinxupquote{out\_of\_range}} 异常。

\item {} 
字典序比较：==，!=，\textless{}，\textless{}=，\textgreater{}，\textgreater{}=

\item {} 
串接：+

\item {} 
c\_str()：返回指向C类型字符串的指针。如果需要使用C的字符串函数如strcmp、strcpy等，需要使用c\_str()。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n+nf}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
子串

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n}{substr}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{pos} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{len} \PYG{o}{=} \PYG{n}{npos}\PYG{p}{)} \PYG{k}{const}
\end{sphinxVerbatim}

\item {} 
插入：支持下标索引插入，在位置pos \sphinxstylestrong{之前} 插入元素。插入元素之后，该元素的位置为 position。（与python中list类的插入功能一致）

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// string (1)}
\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{insert} \PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{str}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// substring (2)}
\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{insert} \PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{str}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{subpos}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{sublen}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// c\PYGZhy{}string (3)}
\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{insert} \PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{pos}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// buffer (4)}
\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{insert} \PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{pos}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{s}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// fill (5)}
\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{insert} \PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{pos}\PYG{p}{,}   \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{n}\PYG{p}{,} \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iterator} \PYG{n+nf}{insert} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{p}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{n}\PYG{p}{,} \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// single character (6)}
\PYG{n}{iterator} \PYG{n+nf}{insert} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{p}\PYG{p}{,} \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// range (7)}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{o}{\PYGZgt{}}
\PYG{n}{iterator} \PYG{n}{insert} \PYG{p}{(}\PYG{n}{iterator} \PYG{n}{p}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// initializer list (8)}
\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{insert} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{p}\PYG{p}{,} \PYG{n}{initializer\PYGZus{}list}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}} \PYG{n}{il}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\subsection{vector}
\label{\detokenize{cpp/19_stl:vector}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{底层实现：顺序表（数组）。}
\begin{itemize}
\item {} 
元素个数：size()，empty()

\item {} 
逐元素比较：==，!=，\textless{}，\textless{}=，\textgreater{}，\textgreater{}=

\item {} 
内存空间：capcity()

\item {} 
访问：{[}pos{]}，at(pos)

\item {} 
头部元素：front()，返回的是引用

\item {} 
尾部元素：back()，返回的是引用

\item {} 
尾部插入：push\_back(x)，emplace\_back(x)

\item {} 
尾部弹出：pop\_back()

\item {} 
迭代器插入：在position \sphinxstylestrong{之前} 插入元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{n+nf}{insert} \PYG{p}{(}\PYG{n}{iterator} \PYG{n}{position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{Args}\PYG{o}{\PYGZgt{}}
\PYG{n}{iterator} \PYG{n}{emplace} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{position}\PYG{p}{,} \PYG{n}{Args}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
尾部删除：pop\_back()

\item {} 
申请空间：至少能容纳n个元素（capcity()为n）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n}{reserve} \PYG{p}{(}\PYG{n}{size\PYGZus{}type} \PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
改变大小：将元素个数变为n。如果指定val且n大于原来的size，则使用val填充新元素，原来的元素不变；如果n小于原来的size，则丢弃尾部元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{resize} \PYG{p}{(}\PYG{n}{size\PYGZus{}type} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{resize} \PYG{p}{(}\PYG{n}{size\PYGZus{}type} \PYG{n}{n}\PYG{p}{,} \PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
赋值
\begin{itemize}
\item {} 
数组或其他向量区间 {[}first,last) 内的值赋给当前向量。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{InputIterator}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{assign} \PYG{p}{(}\PYG{n}{InputIterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{InputIterator} \PYG{n}{last}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
赋予n个val元素给当前向量。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n}{assign} \PYG{p}{(}\PYG{n}{size\PYGZus{}type} \PYG{n}{n}\PYG{p}{,} \PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
删除：删除一个元素之后，此位置之后所有元素往前移动。虽然当前迭代器没有+1，但是由于后续元素的前移，相当于迭代器自动指向了下一个元素。故删除了一个元素之后如果要访问下一个元素，不必执行it++。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{n+nf}{erase} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{position}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iterator} \PYG{n+nf}{erase} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{const\PYGZus{}iterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 区间 [first,last)}
\end{sphinxVerbatim}

\item {} 
清除：
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vector\textless{} value\_type \textgreater{}().swap(myVec)}}

\item {} 
\sphinxcode{\sphinxupquote{myVec.clear()}} 让myVec.size()为0，但是myVec.capcity()不为0，调用 \sphinxcode{\sphinxupquote{myVec.clear()}} 之后再调用 \sphinxcode{\sphinxupquote{myVec.shrink\_to\_fit()}} 。 \sphinxcode{\sphinxupquote{shrink\_to\_fit()}} 的作用是减小capcity()以匹配size()。

\end{itemize}

\end{itemize}


\subsection{list}
\label{\detokenize{cpp/19_stl:list}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}list\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{底层实现：双向链表。}
\begin{itemize}
\item {} 
元素个数：size()，empty()

\item {} 
表首元素：front()

\item {} 
表尾元素：back()

\item {} 
插入：push\_front()，push\_back()，emplace\_front()，emplace\_back()

\item {} 
删除：pop\_front()，pop\_back()

\item {} 
迭代器插入：在position \sphinxstylestrong{之前} 插入元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{n}{insert} \PYG{p}{(}\PYG{n}{iterator} \PYG{n}{position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\subsection{deque}
\label{\detokenize{cpp/19_stl:deque}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}deque\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{底层实现：循环队列。}
\begin{itemize}
\item {} 
元素个数：size()，empty()

\item {} 
队首元素：front()

\item {} 
队尾元素：back()

\item {} 
插入：push\_front(x)，push\_back(x)，emplace\_front(x)，emplace\_back(x)

\item {} 
删除：pop\_front()，pop\_back()

\item {} 
迭代器插入：在position \sphinxstylestrong{之前} 插入元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{n+nf}{insert} \PYG{p}{(}\PYG{n}{iterator} \PYG{n}{position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{Args}\PYG{o}{\PYGZgt{}}
\PYG{n}{iterator} \PYG{n}{emplace} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{position}\PYG{p}{,} \PYG{n}{Args}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
顺序容器构造函数
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{C c;}} // 默认构造函数，空容器

\item {} 
\sphinxcode{\sphinxupquote{C c1(c2);}} // 拷贝构造函数

\item {} 
\sphinxcode{\sphinxupquote{C c(it\_begin, it\_end);}} // 迭代器指定的范围 {[}it\_begin, it\_end) 内的元素赋值给c（array不支持）

\item {} 
\sphinxcode{\sphinxupquote{C c\{a, b, c,...\};}} // 列表初始化

\end{itemize}
\end{sphinxadmonition}


\subsection{pair}
\label{\detokenize{cpp/19_stl:pair}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}utility\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
构造

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T1}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T2}\PYG{o}{\PYGZgt{}}
\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{p}{,}\PYG{n}{T2}\PYG{o}{\PYGZgt{}} \PYG{n}{make\PYGZus{}pair} \PYG{p}{(}\PYG{n}{T1} \PYG{n}{x}\PYG{p}{,} \PYG{n}{T2} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
访问：成员 \sphinxcode{\sphinxupquote{first}} 访问第一个元素，成员 \sphinxcode{\sphinxupquote{second}} 访问第二个元素。

\item {} 
关系运算：支持 ==，!=，\textless{}，\textless{}=，\textgreater{}，\textgreater{}=，从而可以直接排序

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 如果 first 相等，则比较 second}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T1}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T2}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}  \PYG{p}{(}\PYG{k}{const} \PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{p}{,}\PYG{n}{T2}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{lhs}\PYG{p}{,} \PYG{k}{const} \PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{p}{,}\PYG{n}{T2}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{lhs}\PYG{p}{.}\PYG{n}{first}\PYG{o}{\PYGZlt{}}\PYG{n}{rhs}\PYG{p}{.}\PYG{n}{first} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{rhs}\PYG{p}{.}\PYG{n}{first}\PYG{o}{\PYGZlt{}}\PYG{n}{lhs}\PYG{p}{.}\PYG{n}{first}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{lhs}\PYG{p}{.}\PYG{n}{second}\PYG{o}{\PYGZlt{}}\PYG{n}{rhs}\PYG{p}{.}\PYG{n}{second}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T1}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{T2}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}  \PYG{p}{(}\PYG{k}{const} \PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{p}{,}\PYG{n}{T2}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{lhs}\PYG{p}{,} \PYG{k}{const} \PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{p}{,}\PYG{n}{T2}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{rhs}\PYG{o}{\PYGZlt{}}\PYG{n}{lhs}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}


\subsection{map}
\label{\detokenize{cpp/19_stl:map}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}map\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{底层实现：红黑树。}

\sphinxcode{\sphinxupquote{map\textless{}K，T\textgreater{}}} 容器，保存的是 \sphinxcode{\sphinxupquote{pair\textless{}const K，T\textgreater{}}} 类型的元素。

\sphinxcode{\sphinxupquote{map\textless{}K，T\textgreater{}::key\_type}} ：键类型

\sphinxcode{\sphinxupquote{map\textless{}K，T\textgreater{}::mapped\_type}} ：值类型

\sphinxcode{\sphinxupquote{map\textless{}K，T\textgreater{}::value\_type}} ：pair类型， \sphinxcode{\sphinxupquote{\textless{}map\textless{}K，T\textgreater{}::key\_type, map\textless{}K，T\textgreater{}::mapped\_type\textgreater{}}}
\begin{itemize}
\item {} 
访问：{[}key{]}，at(key)
\begin{itemize}
\item {} 
{[}key{]}，key不存在，会创建新的键值对。

\item {} 
at(key)，key不存在，抛出out\_of\_range异常。

\end{itemize}

\item {} 
查找：找不到key则返回 \sphinxcode{\sphinxupquote{map::end}} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{n+nf}{find} \PYG{p}{(}\PYG{k}{const} \PYG{n}{key\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{find} \PYG{p}{(}\PYG{k}{const} \PYG{n}{key\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{k}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
插入：如果key已经存在，则插入无效。map的元素自动按照key升序排序，不能人为对map进行排序。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{iterator}\PYG{p}{,}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}} \PYG{n}{insert} \PYG{p}{(}\PYG{k}{const} \PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
删除：返回删除元素后的下一个元素的迭代器，当前迭代器失效。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iterator}  \PYG{n+nf}{erase} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{position}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{size\PYGZus{}type} \PYG{n+nf}{erase} \PYG{p}{(}\PYG{k}{const} \PYG{n}{key\PYGZus{}type}\PYG{o}{\PYGZam{}} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iterator}  \PYG{n+nf}{erase} \PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{first}\PYG{p}{,} \PYG{n}{const\PYGZus{}iterator} \PYG{n}{last}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{it = myMap.erase(it)}} 等效为 \sphinxcode{\sphinxupquote{myMap.erase(it++)}} 。

\end{itemize}

例子

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}map\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{mymap}\PYG{p}{;}

  \PYG{c+c1}{// first insert function version (single parameter):}
  \PYG{n}{mymap}\PYG{p}{.}\PYG{n}{insert} \PYG{p}{(} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
  \PYG{n}{mymap}\PYG{p}{.}\PYG{n}{insert} \PYG{p}{(} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{value\PYGZus{}type}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{z}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}

  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator}\PYG{p}{,}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}} \PYG{n}{ret}\PYG{p}{;}
  \PYG{n}{ret} \PYG{o}{=} \PYG{n}{mymap}\PYG{p}{.}\PYG{n}{insert} \PYG{p}{(} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{z}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{500}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{ret}\PYG{p}{.}\PYG{n}{second}\PYG{o}{=}\PYG{o}{=}\PYG{n+nb}{false}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{element \PYGZsq{}z\PYGZsq{} already existed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ with a value of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ret}\PYG{p}{.}\PYG{n}{first}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{stack}
\label{\detokenize{cpp/19_stl:stack}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}stack\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
大小：size()，empty()

\item {} 
栈顶元素：top()

\item {} 
入栈：push(x)，emplace(x)

\item {} 
出栈：pop()

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\subsection{queue}
\label{\detokenize{cpp/19_stl:queue}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}queue\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
大小：size()，empty()

\item {} 
队首元素：front()

\item {} 
队尾元素：back()

\item {} 
入队：push(x)，emplace(x)

\item {} 
出队：pop()

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\subsection{priority\_queue}
\label{\detokenize{cpp/19_stl:priority-queue}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}queue\PYGZgt{}}
\end{sphinxVerbatim}

实现 priority\_queue 的底层容器默认是 vector，同时默认功能是大顶堆（值越大，优先级越高；队首元素值最大）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{Container} \PYG{o}{=} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
\PYG{k}{class} \PYG{n+nc}{Compare} \PYG{o}{=} \PYG{n}{less}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{Container}\PYG{o}{:}\PYG{o}{:}\PYG{n}{value\PYGZus{}type}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{k}{class} \PYG{n+nc}{priority\PYGZus{}queue}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
大小：size()，empty()

\item {} 
最高优先级元素：top()

\item {} 
入队：push(x)，emplace(x)

\item {} 
最高优先级元素出队：pop()

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}queue\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{comparator}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}           \PYG{c+c1}{// 必须是 public}
  \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{T} \PYG{n}{a}\PYG{p}{,} \PYG{n}{T} \PYG{n}{b}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{// 相当于 greater\PYGZlt{}T\PYGZgt{}，小顶堆}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{priority\PYGZus{}queue}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{comparator}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{mypq}\PYG{p}{;}

  \PYG{n}{mypq}\PYG{p}{.}\PYG{n}{emplace}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{orange}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{mypq}\PYG{p}{.}\PYG{n}{emplace}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{strawberry}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{mypq}\PYG{p}{.}\PYG{n}{emplace}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{apple}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{mypq}\PYG{p}{.}\PYG{n}{emplace}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pear}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Popping out elements...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{k}{while} \PYG{p}{(}\PYG{o}{!}\PYG{n}{mypq}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{mypq}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{mypq}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// 输出结果}
\PYG{c+c1}{// Popping out elements... apple orange pear strawberry}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
C++11标准引入了 \sphinxstylestrong{emplace\_front} ，\sphinxstylestrong{emplace} ，\sphinxstylestrong{emplace\_back} 这些操作构造而不是拷贝元素，分别对应 \sphinxstylestrong{push\_front} ，\sphinxstylestrong{insert/push} ，\sphinxstylestrong{push\_back} 。

调用 push 或 insert 时，先创建一个元素类型的 \sphinxstylestrong{临时对象} ，这个对象被 \sphinxstylestrong{拷贝} 到容器中。

调用 emplace 时，将 \sphinxstylestrong{参数} 传递给元素类型的 \sphinxstylestrong{构造函数} ，在容器管理的内存空间中使用这些参数直接构造元素。传递给 emplace 的参数必须与构造函数匹配。
\end{sphinxadmonition}


\subsection{to\_string函数}
\label{\detokenize{cpp/19_stl:to-string}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\end{sphinxVerbatim}

把val转化为字符串。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n+nf}{to\PYGZus{}string} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{to\PYGZus{}string} \PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{to\PYGZus{}string} \PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{to\PYGZus{}string} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{to\PYGZus{}string} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{to\PYGZus{}string} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{to\PYGZus{}string} \PYG{p}{(}\PYG{k+kt}{float} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{to\PYGZus{}string} \PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{to\PYGZus{}string} \PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{atoi，atof，atol}
\label{\detokenize{cpp/19_stl:atoi-atof-atol}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdlib\PYGZgt{}}
\end{sphinxVerbatim}

把C类型的字符串转换为数字（C++的string需要使用 \sphinxcode{\sphinxupquote{c\_str()}} 转换）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{atoi} \PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{str}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{double} \PYG{n+nf}{atof} \PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{str}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n+nf}{atol} \PYG{p}{(} \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{str} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{size\_t和size\_type}
\label{\detokenize{cpp/19_stl:size-tsize-type}}

\subsubsection{size\_t}
\label{\detokenize{cpp/19_stl:size-t}}
size\_t 提供了一种可移植（不同平台下）的方法声明与系统可寻址的内存区域一致的长度。
size\_t 是通过typedef定义的一些 \sphinxstylestrong{无符号整型} 的别名，通常是 unsigned int，unsigned long 甚至是unsigned long long。

常用于循环计数器、数组索引，或指针的算术运算。

VS 32位编译器：sizeof(size\_t) = 32；VS 64位编译器：sizeof(size\_t) = 64。
\begin{description}
\item[{头文件}] \leavevmode\begin{itemize}
\item {} 
\textless{}cstddef\textgreater{}

\item {} 
\textless{}cstdio\textgreater{}

\item {} 
\textless{}cstring\textgreater{}

\item {} 
\textless{}ctime\textgreater{}

\item {} 
\textless{}cstdlib\textgreater{}

\item {} 
\textless{}cwchar\textgreater{}

\end{itemize}

\end{description}


\subsubsection{size\_type}
\label{\detokenize{cpp/19_stl:size-type}}
size\_type 是STL定义的类型属性，足够保持对应容器最大可能的容器大小。也是 \sphinxstylestrong{无符号整型} 。

size() 的返回类型就是size\_type。把 size() 赋值给一个 int 变量，会有 warning。
\begin{description}
\item[{VS 32位编译器}] \leavevmode\begin{itemize}
\item {} 
sizeof(string::size\_type) = 32

\item {} 
sizeof(vector\textless{}int\textgreater{}::size\_type) = 32

\item {} 
…

\end{itemize}

\item[{VS 64位编译器}] \leavevmode\begin{itemize}
\item {} 
sizeof(string::size\_type) = 64

\item {} 
sizeof(vector\textless{}int\textgreater{}::size\_type) = 64

\item {} 
…

\end{itemize}

\end{description}

\begin{sphinxadmonition}{warning}{Warning:}\begin{quote}

\sphinxstylestrong{无符号整型} 尤其是要注意下标为 0 时的边界情况。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{vec}\PYG{p}{;} \PYG{c+c1}{// vec = \PYGZob{}\PYGZcb{}}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{c+c1}{// 判断改为: k + 1 \PYGZlt{} vec.size()}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

上例中，本意是只有当 vec 至少包含2个元素时，才输出。但是，当 vec.size() = 0，vec.size() - 1 = 2\textasciicircum{}32 - 1 或2\textasciicircum{}64 - 1，
而不是预想的 -1，陷入死循环。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/19_stl:id1}}\begin{enumerate}
\item {} 
C++ reference

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cplusplus.com/reference/string/string}

\sphinxurl{http://www.cplusplus.com/reference/string/to\_string}

\sphinxurl{http://www.cplusplus.com/reference/vector/vector}

\sphinxurl{http://www.cplusplus.com/reference/list/list}

\sphinxurl{http://www.cplusplus.com/reference/deque/deque}

\sphinxurl{http://www.cplusplus.com/reference/utility/pair/operators}

\sphinxurl{http://www.cplusplus.com/reference/map/map}

\sphinxurl{http://www.cplusplus.com/reference/stack/stack}

\sphinxurl{http://www.cplusplus.com/reference/queue/queue}

\sphinxurl{http://www.cplusplus.com/reference/queue/priority\_queue}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++ STL快速入门

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/skyfsm/p/6934246.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
STL教程：C++ STL快速入门（非常详细）

\end{enumerate}
\begin{quote}

\sphinxurl{http://c.biancheng.net/stl/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
标准C++中的string类的用法总结（转）

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/aminxu/p/4686320.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
std::size\_t

\end{enumerate}
\begin{quote}

\sphinxurl{https://zh.cppreference.com/w/cpp/types/size\_t}
\end{quote}


\section{\#define}
\label{\detokenize{cpp/20_define::doc}}\label{\detokenize{cpp/20_define:define}}\begin{description}
\item[{\sphinxstylestrong{原则}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{对于单纯常量，最好以 const 对象或 enum 替换 \#define。}

\item {} 
\sphinxstylestrong{对于形似函数的宏（macros），最好改用 inline 函数替换 \#define。}

\end{itemize}

\end{description}


\subsection{const}
\label{\detokenize{cpp/20_define:const}}
“宁可以编译器替换 \sphinxstylestrong{预编译器} ”。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ASPECT\PYGZus{}RATIO 1.653}

\PYG{k}{const} \PYG{k+kt}{double} \PYG{n}{AspectRation} \PYG{o}{=} \PYG{l+m+mf}{1.653}\PYG{p}{;}
\end{sphinxVerbatim}

也许名称 \sphinxcode{\sphinxupquote{ASPECT\_RATIO}} 从未被编译器看见，也许在编译器开始处理源码之前它已经被预处理器移走了。于是，记号名称 \sphinxcode{\sphinxupquote{ASPECT\_RATIO}}
可能没有进入记号表（symbol table）内。当运用此常量获得编译错误时，这个错误也许会提到  \sphinxcode{\sphinxupquote{1.653}} 而不是 \sphinxcode{\sphinxupquote{ASPECT\_RATIO}} ，导致对其追踪
变得困难。

作为一个语言常量， \sphinxcode{\sphinxupquote{AspectRation}} 一定会被编译器看到并记入记号表。

此外，对浮点常量而言，使用常量可能比使用 \#define 导致较小的代码量，因为预处理器将宏名称 \sphinxcode{\sphinxupquote{ASPECT\_RATIO}} 替换为  \sphinxcode{\sphinxupquote{1.653}} ，可能导致
目标码（object code）出现多份 \sphinxcode{\sphinxupquote{1.653}} ，使用常量则不会。

还可以在类内声明 static const 成员。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Player}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
  \PYG{k}{static} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{NumTurns} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{// 常量声明（不是定义）}
  \PYG{k+kt}{int} \PYG{n}{scores}\PYG{p}{[}\PYG{n}{NumTurns}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 使用该常量}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{enum}
\label{\detokenize{cpp/20_define:enum}}
如果编译器不允许static成员在声明式上获得初始值，一方面，可以在头文件定义类，在源文件中初始化它；另一方面，如果该类在编译期间
必须使用一个常量值，例如上例中数组 scores 的大小必须在编译期间知道，此时可以使用 enum。一个属于枚举类型的数值可以权当int被使用。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Player}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
  \PYG{k}{enum} \PYG{p}{\PYGZob{}}\PYG{n}{NumTurns} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// NumTurns 成为数值 5 的一个记号。}
  \PYG{k+kt}{int} \PYG{n}{scores}\PYG{p}{[}\PYG{n}{NumTurns}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 使用该常量}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
enum的行为类似于\#define，取一个enum的地址或\#define的地址通常不合法，而取一个const的地址是合法的。
\end{sphinxadmonition}


\subsection{inline}
\label{\detokenize{cpp/20_define:inline}}
使用宏（macros）不会有函数调用带来的额外开销。宏中的所有实参必须添加括号，但是仍然可能出现问题。

此时，可以定义内联函数（inline），它与普通函数一样遵守作用域（scope）和访问规则。内联函数的特点：
\begin{itemize}
\item {} 
在调用处直接展开该函数的内容

\item {} 
运行速度快，但占用更多内存

\item {} 
适用于规模小、流程直接（无递归和众多判断）、频繁调用的函数

\end{itemize}
\begin{description}
\item[{普通函数的调用：}] \leavevmode\begin{enumerate}
\item {} 
执行到函数调用指令时，程序将立即存储该指令的内存地址，并将函数参数复制到栈（为此保留的内存块）；

\item {} 
跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入寄存器中）；

\item {} 
然后跳回到地址被保存的指令处。

\end{enumerate}

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define CALL\PYGZus{}WITH\PYGZus{}MAX(a, b) f((a)\PYGZgt{}(b)? (a):(b))}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define MAX\PYGZus{}COMP\PYGZus{}1(a, b) (a)\PYGZgt{}(b)? (a):(b)}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define MAX\PYGZus{}COMP\PYGZus{}2(a, b) ((a)\PYGZgt{}(b)? (a):(b)) }\PYG{c+c1}{// 有外层括号}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{f}\PYG{p}{(}\PYG{n}{T} \PYG{n}{elem}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max out: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{n}{elem} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{CallWithMax}\PYG{p}{(}\PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{a}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)} \PYG{c+c1}{// 形参使用常量引用，因为不知道 T 的具体类型，比较安全}
\PYG{p}{\PYGZob{}}
  \PYG{n}{f}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{b} \PYG{o}{?} \PYG{n+nl}{a} \PYG{p}{:} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{n}{CALL\PYGZus{}WITH\PYGZus{}MAX}\PYG{p}{(}\PYG{o}{+}\PYG{o}{+}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// a 自增2次，变为7（++a \PYGZgt{} b =\PYGZgt{} ++a）}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{n}{CALL\PYGZus{}WITH\PYGZus{}MAX}\PYG{p}{(}\PYG{o}{+}\PYG{o}{+}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// a 自增1次，变为8（++a \PYGZlt{} b+10 =\PYGZgt{} b）}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

  \PYG{n}{f}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{MAX\PYGZus{}COMP\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZhy{}10 + a \PYGZgt{} b ? a : b; 结果为 0}
  \PYG{n}{f}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{MAX\PYGZus{}COMP\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// \PYGZhy{}10 + (a \PYGZgt{} b ? a : b); 结果为 \PYGZhy{}10 + 8 = \PYGZhy{}2}

  \PYG{n}{CallWithMax}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 8}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{附：C/C++ 编译过程（简）}
\label{\detokenize{cpp/20_define:c-c}}
编译过程
\begin{quote}

\sphinxstylestrong{1.（分离式）编译} ：每个文件独立编译
\begin{quote}
\begin{enumerate}
\item {} 
预处理：处理伪指令（\#开头）和特殊符号。

\end{enumerate}
\begin{itemize}
\item {} 
宏定义：\#define，\#undef

\item {} 
条件编译：\#ifdef，\#ifndef，\#endif

\item {} 
头文件包含：\#include

\item {} 
特殊符号：\_\_LINE\_\_，\_\_FILE\_\_

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
编译：词法分析、语法分析，确认所有指令符合语法规则，将其翻译成等价的中间代码表示或汇编代码。

\item {} 
汇编：把汇编代码翻译成目标机器指令，得到目标文件（obj）。

\end{enumerate}
\end{quote}

\sphinxstylestrong{2. 链接} ：将相关的目标文件进行连接（头文件包含关系、符号引用等），使这些目标文件能够成为一个被执行的同一整体。
\end{quote}


\subsection{参考资料}
\label{\detokenize{cpp/20_define:id1}}\begin{enumerate}
\item {} 
《Effective C++》条款02。

\item {} 
《C++ Primer 第5版 中文版》 Page 213\textendash{}214。

\item {} 
C++内联函数详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/shijingjing07/p/5523224.html}
\end{quote}


\section{运算符优先级}
\label{\detokenize{cpp/21_operatorPrior::doc}}\label{\detokenize{cpp/21_operatorPrior:id1}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{|*{3}{\X{1}{3}|}}
\caption{运算符的优先级\strut}\label{\detokenize{cpp/21_operatorPrior:id3}}\\*[\sphinxlongtablecapskipadjust]
\hline
\sphinxstyletheadfamily 
priority
&\sphinxstyletheadfamily 
operator
&\sphinxstyletheadfamily 
meaning
\\
\hline
\endfirsthead

\multicolumn{3}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstyletheadfamily 
priority
&\sphinxstyletheadfamily 
operator
&\sphinxstyletheadfamily 
meaning
\\
\hline
\endhead

\hline
\multicolumn{3}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot
\sphinxmultirow{6}{4}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
1
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
{[}{]}
&
下标运算
\\
\cline{2-3}\sphinxtablestrut{4}&
()
&
圆括号
\\
\cline{2-3}\sphinxtablestrut{4}&
-\textgreater{}
&
指向运算符
\\
\cline{2-3}\sphinxtablestrut{4}&
.
&
成员运算符
\\
\cline{2-3}\sphinxtablestrut{4}&
++
&
自增（后缀）
\\
\cline{2-3}\sphinxtablestrut{4}&
- -
&
自减（后缀）
\\
\hline\sphinxmultirow{10}{17}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
2
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
!
&
逻辑非
\\
\cline{2-3}\sphinxtablestrut{17}&
\textasciitilde{}
&
按位反
\\
\cline{2-3}\sphinxtablestrut{17}&
++
&
自增（前缀）
\\
\cline{2-3}\sphinxtablestrut{17}&
- -
&
自减（前缀）
\\
\cline{2-3}\sphinxtablestrut{17}&
-
&
负号
\\
\cline{2-3}\sphinxtablestrut{17}&
+
&
正号
\\
\cline{2-3}\sphinxtablestrut{17}&
(类型)
&
类型转换
\\
\cline{2-3}\sphinxtablestrut{17}&
*
&
指针运算符
\\
\cline{2-3}\sphinxtablestrut{17}&
\&
&
取地址
\\
\cline{2-3}\sphinxtablestrut{17}&
sizeof
&
长度运算
\\
\hline\sphinxmultirow{3}{38}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
3
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
*
&
乘法
\\
\cline{2-3}\sphinxtablestrut{38}&
/
&
除法
\\
\cline{2-3}\sphinxtablestrut{38}&
\%
&
求余
\\
\hline\sphinxmultirow{2}{45}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
4
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
+
&
加法
\\
\cline{2-3}\sphinxtablestrut{45}&
-
&
减法
\\
\hline\sphinxmultirow{2}{50}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
5
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\textless{}\textless{}
&
左移位
\\
\cline{2-3}\sphinxtablestrut{50}&
\textgreater{}\textgreater{}
&
右移位
\\
\hline
6
&
\textless{} \textless{}= \textgreater{} \textgreater{}=
&
关系运算符
\\
\hline\sphinxmultirow{2}{58}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
7
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
==
&
等于
\\
\cline{2-3}\sphinxtablestrut{58}&
!=
&
不等于
\\
\hline
8
&
\&
&
按位与
\\
\hline
9
&
\textasciicircum{}
&
按位异或
\\
\hline
10
&
\textbar{}
&
按位或
\\
\hline
11
&
\&\&
&
逻辑与
\\
\hline
12
&
\textbar{}\textbar{}
&
逻辑或
\\
\hline
13
&
? :
&
条件运算符
\\
\hline\sphinxmultirow{3}{81}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
14
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{3}{82}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
=   +=  -=  *=

/=  \%=  \&=  \textbar{}=

\textasciicircum{}=  \textless{}\textless{}=  \textgreater{}\textgreater{}=
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{3}{83}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
赋值运算符
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
\\
\sphinxtablestrut{81}&\sphinxtablestrut{82}&\sphinxtablestrut{83}\\
\sphinxtablestrut{81}&\sphinxtablestrut{82}&\sphinxtablestrut{83}\\
\hline
15
&
,
&
逗号运算符
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
位运算的优先级是：\sphinxcode{\sphinxupquote{\textasciitilde{}}} \textgreater{} \sphinxcode{\sphinxupquote{\&}} \textgreater{} \sphinxcode{\sphinxupquote{\textasciicircum{}}} \textgreater{} \sphinxcode{\sphinxupquote{\textbar{}}} 。

逻辑运算的优先级是：\sphinxcode{\sphinxupquote{!}} \textgreater{} \sphinxcode{\sphinxupquote{\&\&}} \textgreater{} \sphinxcode{\sphinxupquote{\textbar{}\textbar{}}} 。

不能重载的运算符：\sphinxcode{\sphinxupquote{.}} ，\sphinxcode{\sphinxupquote{? :}} ，\sphinxcode{\sphinxupquote{sizeof}} ，\sphinxcode{\sphinxupquote{.*}} ， \sphinxcode{\sphinxupquote{::}}。

逻辑与：\sphinxcode{\sphinxupquote{exp1 \&\& exp2}} ，如果 \sphinxcode{\sphinxupquote{exp1}} 值为 0，则不对 \sphinxcode{\sphinxupquote{exp2}} 求值。

逻辑或：\sphinxcode{\sphinxupquote{exp1 \textbar{}\textbar{} exp2}} ，如果 \sphinxcode{\sphinxupquote{exp1}} 值为 1，则不对 \sphinxcode{\sphinxupquote{exp2}} 求值。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/21_operatorPrior:id2}}\begin{enumerate}
\item {} 
Operator Overloading

\end{enumerate}
\begin{quote}

\sphinxurl{https://isocpp.org/wiki/faq/operator-overloading}
\end{quote}


\section{const}
\label{\detokenize{cpp/22_const:const}}\label{\detokenize{cpp/22_const::doc}}

\subsection{顶层const与底层const}
\label{\detokenize{cpp/22_const:constconst}}
由于指针本身是一个对象，它有可以指向另一个对象，因此，指针本身是不是常量以及指针所指对象是不是常量就是两个相互独立的问题。

\sphinxstylestrong{顶层const} （top-level const）表示 \sphinxstylestrong{对象本身} 是常量，\sphinxstylestrong{底层const} （low-level const）与指针或引用等复合类型的 \sphinxstylestrong{基本类型} 部分有关。
对指针而言，既可以是顶层const，也可以是底层const。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{o}{*}\PYG{k}{const} \PYG{n}{p1} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{i}\PYG{p}{;} \PYG{c+c1}{// 顶层const，不能改变 p1 的值}

\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{ci} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{;} \PYG{c+c1}{// 顶层const，不能改变 ci 的值}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{p2} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{ci}\PYG{p}{;}  \PYG{c+c1}{// 底层const，可以改变 p2 的值，但不能通过 p2 改变 ci 的值。}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{*}\PYG{k}{const} \PYG{n}{p3} \PYG{o}{=} \PYG{n}{p2}\PYG{p}{;}  \PYG{c+c1}{// 顶层const + 底层const}

\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{r} \PYG{o}{=} \PYG{n}{ci}\PYG{p}{;} \PYG{c+c1}{// 用于声明引用的const都是底层const，r 不能改变 i}
\end{sphinxVerbatim}

执行拷贝操作，被拷贝对象的顶层const属性不受影响。而对于底层const，要求拷入和拷出的对象具有相同的底层const属性，或在两个对象的数据类型能够转换。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 承接上例的定义}

\PYG{n}{i} \PYG{o}{=} \PYG{n}{ci}\PYG{p}{;} \PYG{c+c1}{// 正确}
\PYG{n}{p2} \PYG{o}{=} \PYG{n}{p3}\PYG{p}{;} \PYG{c+c1}{// 正确}

\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{n}{p3}\PYG{p}{;} \PYG{c+c1}{// 错误，p 没有底层const，防止通过 p 间接改变 p3 所指对象。}
\PYG{n}{p2} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{i}\PYG{p}{;} \PYG{c+c1}{// 正确，int* 能转换为 const int*}

\PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{r1} \PYG{o}{=} \PYG{n}{ci}\PYG{p}{;} \PYG{c+c1}{// 错误，r1 没有底层const}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{r2} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;} \PYG{c+c1}{// 正确，const int\PYGZam{} 可以绑定到普通 int}
\end{sphinxVerbatim}

总结：可以使用 \sphinxstylestrong{非常量对象} 初始化一个 \sphinxstylestrong{底层const对象} ，但是不能使用 \sphinxstylestrong{底层const对象} 初始化一个 \sphinxstylestrong{非常量对象} 。同时，一个普通的引用
必须使用同类型的对象初始化。同样的初始化规则可以应用到函数的 \sphinxstylestrong{参数传递} 上。


\subsection{const形参和实参}
\label{\detokenize{cpp/22_const:id1}}
使用实参初始化形参时，会 \sphinxstylestrong{忽略掉顶层const} ，换句话说，形参的顶层const被忽略了。因此，当形参有顶层const时，传给它常量对象或非常量对象都是可以的 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{fcn}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{c+cm}{/* */}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n+nf}{fcn}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{c+cm}{/* */}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{// 重复定义了 fcn}
\end{sphinxVerbatim}

上例中其实重复定义了fcn，而不是重载。调用fcn时，既可以传入const int对象，也可以传入int对象。
反之，如果参数类型是int，也可传入const int对象（传值调用，函数拷贝了实参）。


\subsection{const成员函数}
\label{\detokenize{cpp/22_const:id2}}
默认情况下，\sphinxcode{\sphinxupquote{this}} 指针的类型是指向 \sphinxstylestrong{类类型非常量版本的常量指针} ，即 \sphinxcode{\sphinxupquote{ClassName *const}} 。尽管 this 是隐式的，但它仍然需要遵守初始化规则。
意味着在默认情况下，我们不能把 this 绑定到一个常量对象上。这一情况也使得我们不能在一个常量对象上调用普通的成员函数。通过把关键字 const 放在成员函数参数列表后面，
定义该成员函数为 \sphinxstylestrong{常量成员函数} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Sale}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{double} \PYG{n}{avg\PYGZus{}price}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

此时，this 成为指向常量的指针，所以常量成员函数 \sphinxstylestrong{不能改变调用它的对象的内容} 。

\begin{sphinxadmonition}{note}{Note:}
常量对象、常量对象的引用和指针都只能调用常量成员函数。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/22_const:id3}}
1.《C++ Primer 第5版 中文版》 Page 57 \textendash{} 58， Page 190 \textendash{} 191，Page 231 \textendash{} 232。


\section{拷贝控制}
\label{\detokenize{cpp/23_copyControl::doc}}\label{\detokenize{cpp/23_copyControl:id1}}\begin{description}
\item[{拷贝控制（copy control）}] \leavevmode\begin{itemize}
\item {} 
拷贝构造函数（copy constructor）

\item {} 
拷贝赋值运算符（copy-assignment operator）

\item {} 
移动构造函数（move constructor）

\item {} 
移动赋值运算符（move-assignment operator）

\item {} 
析构函数（destructor）

\end{itemize}

\end{description}


\subsection{拷贝构造函数}
\label{\detokenize{cpp/23_copyControl:id2}}
\sphinxstylestrong{拷贝构造函数的第一个参数必须是引用类型} 。

在函数调用中，具有非引用类型的参数要进行拷贝初始化。类似地，当一个函数具有非引用类型的返回类型时，返回值会被用来初始化调用方的结果。

拷贝构造函数被用来初始化 \sphinxstylestrong{非引用类类型} （被初始化的是类的非引用对象）参数，如果拷贝构造函数的参数不是引用类型，为了调用拷贝构造函数，
我们必须拷贝它的实参，然而拷贝实参又需要调用拷贝构造函数，如此无限循环。

如果我们没有为类定义拷贝控制函数，编译器会为我们定义一个。与合成默认构造函数不同（如果定义了其他构造函数，则需要我们再显式定义默认构造函数），
即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。


\subsection{default 和 delete}
\label{\detokenize{cpp/23_copyControl:default-delete}}\begin{description}
\item[{使用 \sphinxcode{\sphinxupquote{=default}}}] \leavevmode
将拷贝控制成员定义为 \sphinxcode{\sphinxupquote{=default}} ，显式要求编译器生成合成的版本。
\begin{itemize}
\item {} 
类内使用 \sphinxcode{\sphinxupquote{=default}} 修饰成员的声明，则合成的函数隐式地声明为内联函数（注：定义在类内的函数自动为内联函数）。

\item {} 
类外使用 \sphinxcode{\sphinxupquote{=default}} 修饰成员的定义，则合成的成员不是内联函数。

\item {} 
只能对默认构造函数或拷贝控制成员使用 \sphinxcode{\sphinxupquote{=default}} 。

\end{itemize}

\item[{使用 \sphinxcode{\sphinxupquote{=delete}}}] \leavevmode
在函数参数列表之后加上 \sphinxcode{\sphinxupquote{=delete}} 定义为 \sphinxstylestrong{删除的函数} ：虽然有声明，但是不能以任何形式使用它们。

将拷贝构造函数和拷贝赋值运算符定义为删除的函数，从而阻止拷贝操作。

\end{description}


\subsection{直接初始化和拷贝初始化}
\label{\detokenize{cpp/23_copyControl:id3}}
直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n}{dots}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}         \PYG{o}{/}\PYG{o}{/} \PYG{n}{直接初始化}
\PYG{n}{string} \PYG{n}{s}\PYG{p}{(}\PYG{n}{dots}\PYG{p}{)}\PYG{p}{;}               \PYG{o}{/}\PYG{o}{/} \PYG{n}{直接初始化}

\PYG{n}{string} \PYG{n}{s2} \PYG{o}{=} \PYG{n}{dots}\PYG{p}{;}             \PYG{o}{/}\PYG{o}{/} \PYG{n}{拷贝初始化}
\PYG{n}{string} \PYG{n}{s3} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{999\PYGZhy{}9999}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}       \PYG{o}{/}\PYG{o}{/} \PYG{n}{拷贝初始化}
\PYG{n}{string} \PYG{n}{s4} \PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{拷贝初始化}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{ClassTest}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{ClassTest}\PYG{p}{(}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ClassTest()}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{ClassTest}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ClassTest} \PYG{o}{\PYGZam{}}\PYG{n}{ct}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{ct}\PYG{p}{.}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ClassTest\PYGZam{} operator=(const ClassTest \PYGZam{}ct)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{ClassTest}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{pc}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{pc}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ClassTest (const char *pc)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// private:}
  \PYG{n}{ClassTest}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ClassTest}\PYG{o}{\PYGZam{}} \PYG{n}{ct}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{ct}\PYG{p}{.}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ClassTest(const ClassTest\PYGZam{} ct)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{k}{private}\PYG{o}{:}
  \PYG{k+kt}{char} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{256}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

调用:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
ClassTest ct1(\PYGZdq{}ab\PYGZdq{});          // 直接初始化
// 输出： ClassTest (const char *pc)

ClassTest ct2 = \PYGZdq{}ab\PYGZdq{};         // 拷贝初始化
// 输出： ClassTest (const char *pc)
// 首先调用构造函数 ClassTest(const char *pc) 函数创建一个临时对象；然后调用拷贝构造函数，把这个临时对象作为参数，构造对象ct2
// 然而结果并没有输出 ClassTest(const ClassTest\PYGZam{} ct)。有说法是编译器优化之后，直接匹配了 ClassTest(const char *pc)，不再调用拷贝构造函数

//ClassTest ct3 = ct1;        // 拷贝初始化
// 输出： ClassTest(const ClassTest\PYGZam{} ct)
// ct1 已经存在，直接调用拷贝构造函数

//ClassTest ct4(ct1);         // 直接初始化
// 输出： ClassTest(const ClassTest\PYGZam{} ct)
// ct1 已经存在，直接调用拷贝构造函数

//ClassTest ct5 = ClassTest();// 拷贝初始化
// 输出： ClassTest()
// 首先调用默认构造函数产生一个临时对象；然后调用拷贝构造函数，把这个临时对象作为参数，构造对象ct5

//ct3 = ct2;                  // 赋值
// 输出： ClassTest\PYGZam{} operator=(const ClassTest \PYGZam{}ct)
\end{sphinxVerbatim}

当把拷贝构造函数设置为 \sphinxcode{\sphinxupquote{private}} ，ct3、ct4、ct5的初始化都无法完成。


\subsection{push 和 emplace}
\label{\detokenize{cpp/23_copyControl:push-emplace}}
在18章提到了 push 和 emplace 的区别，这里用一个例子解释。

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}utility\PYGZgt{}  // std::move}

\PYG{k}{class} \PYG{n+nc}{Foo}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{Foo}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{str}\PYG{p}{)} \PYG{o}{:} \PYG{n}{name}\PYG{p}{(}\PYG{n}{str}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{constructor}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{Foo}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Foo}\PYG{o}{\PYGZam{}} \PYG{n}{f}\PYG{p}{)} \PYG{o}{:} \PYG{n}{name}\PYG{p}{(}\PYG{n}{f}\PYG{p}{.}\PYG{n}{name}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{copy constructor}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{Foo}\PYG{p}{(}\PYG{n}{Foo}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{f}\PYG{p}{)} \PYG{o}{:} \PYG{n}{name}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{f}\PYG{p}{.}\PYG{n}{name}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{move constructor}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{k}{private}\PYG{o}{:}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{name}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Foo}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{10000000}\PYG{p}{;}
  \PYG{n}{v}\PYG{p}{.}\PYG{n}{reserve}\PYG{p}{(}\PYG{n}{count}\PYG{p}{)}\PYG{p}{;}

  \PYG{p}{\PYGZob{}}
    \PYG{n}{Foo} \PYG{n}{temp}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// constructor}
    \PYG{n}{v}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// push\PYGZus{}back(const T\PYGZam{})，参数是左值引用}
    \PYG{c+c1}{// copy constructor}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{v}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{Foo} \PYG{n}{temp}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// constructor}
    \PYG{n}{v}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// push\PYGZus{}back(T \PYGZam{}\PYGZam{}), 参数是右值引用}
    \PYG{c+c1}{// move constructor}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{v}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{v}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{Foo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// push\PYGZus{}back(T \PYGZam{}\PYGZam{}), 参数是右值引用}
    \PYG{c+c1}{// constructor}
    \PYG{c+c1}{// move constructor}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{v}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{temp} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{v}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// push\PYGZus{}back(T \PYGZam{}\PYGZam{}), 参数是右值引用}
    \PYG{c+c1}{// constructor}
    \PYG{c+c1}{// move constructor}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{v}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{temp} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{v}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// 只有一次构造函数，不调用拷贝构造函数，速度最快}
    \PYG{c+c1}{// constructor}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\begin{sphinxadmonition}{note}{Note:}
我们可以销毁一个移动之后的源对象（moved-from），也可以赋予它新值，但是不能使用一个移后源对象的值。

如：上例中的 temp 被移动后，就不能再取它的值来使用。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{cpp/23_copyControl:id4}}
1.《C++ Primer 第5版 中文版》 Page 440 \textendash{} 442，449，470 \textendash{} 475。
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++的一大误区——深入解释直接初始化与复制初始化的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/ljianhui/article/details/9245661}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
C++11使用emplace\_back代替push\_back

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/yockie/article/details/52674366}
\end{quote}


\chapter{Python}
\label{\detokenize{python/index:python}}\label{\detokenize{python/index::doc}}

\section{in-place 运算}
\label{\detokenize{python/01_inplace:in-place}}\label{\detokenize{python/01_inplace::doc}}

\subsection{+= 运算}
\label{\detokenize{python/01_inplace:id1}}
\sphinxcode{\sphinxupquote{+=}} 是一个in-place运算符，看如下例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{n}{a} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1,2]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[1,2]}
\end{sphinxVerbatim}

如果改变成如下形式：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

则结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1,2]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{a = a + {[}1,2{]}}} 不是in-place运算，尽管使用了同一个变量名。
\end{sphinxadmonition}


\subsection{add和iadd}
\label{\detokenize{python/01_inplace:addiadd}}
\sphinxcode{\sphinxupquote{operator}} 包中有两个操作：\sphinxcode{\sphinxupquote{add}} 和 \sphinxcode{\sphinxupquote{iadd}} 。\sphinxcode{\sphinxupquote{add}} 是正常加运算， \sphinxcode{\sphinxupquote{iadd}} 是原位加运算。
\begin{quote}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{\_add\_}}}] \leavevmode
does simple addition, takes two arguments, returns the sum and stores it in other variable without modifying any of the argument.
Normal operator’s \sphinxcode{\sphinxupquote{add()}} method, implements \sphinxstylestrong{“a+b”} and stores the result in the mentioned variable.

\item[{\sphinxcode{\sphinxupquote{\_iadd\_}}}] \leavevmode
also takes two arguments, but it makes in-place change in 1st argument passed by storing the sum in it. As object mutation is needed in this process, immutable targets such as numbers, strings and tuples, shouldn’t have \sphinxcode{\sphinxupquote{\_iadd\_}} method.
Inplace operator’s \sphinxcode{\sphinxupquote{iadd()}} method, implements \sphinxstylestrong{“a+=b”} if it exists (i.e in case of immutable targets, it doesn’t exist) and changes the value of passed argument. But if not, \sphinxstylestrong{“a+b”} is implemented.

\end{description}
\end{quote}

分两种情况讨论。


\subsubsection{immutable targets}
\label{\detokenize{python/01_inplace:immutable-targets}}
对于不可变目标（immutable targets），如数字、字符串、元组， \sphinxcode{\sphinxupquote{\_add\_}} 和 \sphinxcode{\sphinxupquote{\_iadd\_}} 结果是一样的，输入实参不会发生改变。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{operator}

\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{6}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{iadd}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{z}
\PYG{g+go}{11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{p}
\PYG{g+go}{11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{x}
\PYG{g+go}{5}
\end{sphinxVerbatim}


\subsubsection{mutable targets}
\label{\detokenize{python/01_inplace:mutable-targets}}
对于可变目标（mutable targets），如列表、字典，输入实参会被重现赋值和更新。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{operator}

\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{operator}\PYG{o}{.}\PYG{n}{iadd}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

结果如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{z}
\PYG{g+go}{[1, 2, 4, 5, 1, 2, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{p}
\PYG{g+go}{[1, 2, 4, 5, 1, 2, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{[1, 2, 4, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{[1, 2, 4, 5, 1, 2, 3]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{不可变目标} （数字、字符串、元组）作为函数参数，相当于 \sphinxstylestrong{值传递} ，函数对实参进行拷贝。

\sphinxstylestrong{可变目标} （列表、字典）作为函数参数，相当于 \sphinxstylestrong{引用传递} ，函数对实参的修改有效。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{python/01_inplace:id2}}\begin{enumerate}
\item {} 
pytorch issue：

\end{enumerate}
\begin{quote}

\sphinxurl{https://github.com/pytorch/pytorch/issues/5687}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
GeeksforGeeks：

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.geeksforgeeks.org/inplace-vs-standard-operators-python/}
\end{quote}


\section{\_\_all\_\_ 的使用}
\label{\detokenize{python/02_all:all}}\label{\detokenize{python/02_all::doc}}

\subsection{从\_\_init\_\_.py谈起}
\label{\detokenize{python/02_all:init-py}}
\sphinxcode{\sphinxupquote{\_\_init\_\_.py}} 的 \sphinxstylestrong{作用一} ：package的标识
\begin{quote}

在每一个package文件夹中都会有一个\_\_init\_\_.py文件。
\end{quote}

\sphinxcode{\sphinxupquote{\_\_init\_\_.py}} 的 \sphinxstylestrong{作用二} ：定义该package的 \sphinxcode{\sphinxupquote{\_\_all\_\_}} ，用以模糊导入
\begin{quote}

python中包(package)和模块(module)有两种导入形式：精确导入和模糊导入。
\begin{description}
\item[{精确导入}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PACK} \PYG{k+kn}{import} \PYG{n}{CLASS1}\PYG{p}{,} \PYG{n}{CLASS2}
\PYG{k+kn}{import} \PYG{n+nn}{PACK.CLASS1}
\end{sphinxVerbatim}

\item[{模糊导入}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PACK} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

\end{description}
\end{quote}

\sphinxcode{\sphinxupquote{\_\_all\_\_}} 是一个字符串列表，用于定义模糊导入中的 \sphinxcode{\sphinxupquote{*}} 中的模块，即暴露接口，也是对于模块公开接口的一种约定。

举个例子，建立如下目录结构的文件夹及文件:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}
\PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n}{test}\PYG{o}{.}\PYG{n}{py}
\PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n}{myPack}
    \PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{n}{func}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

创建了包 \sphinxstylestrong{myPack} ，其中 \sphinxstylestrong{func.py} 中定义了该包的功能，包括变量、类、函数的定义。使用 \sphinxstylestrong{test.py} 来测试这个包的调用。
\sphinxcode{\sphinxupquote{\_\_init\_\_.py}} 中的内容如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{func} \PYG{k+kn}{import} \PYG{n}{x}\PYG{p}{,} \PYG{n}{foo}
\PYG{c+c1}{\PYGZsh{} 假设x是一个变量，foo是一个函数}

\PYG{n}{\PYGZus{}\PYGZus{}all\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{foo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxstylestrong{test.py} 中的内容如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{myPack} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{k}{print} \PYG{n}{x}

\PYG{n}{foo}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/02_all:id1}}\begin{enumerate}
\item {} 
Python中的 \_\_all\_\_

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/ca469f693c31}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Python包中 \_\_init\_\_.py 作用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/AlwinXu/p/5598543.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Python \_\_init\_\_.py 作用详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/Lands-ljk/p/5880483.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Python中 \_\_all\_\_ 的用法

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.codetd.com/article/2136881}
\end{quote}


\section{is和==}
\label{\detokenize{python/03_is:is}}\label{\detokenize{python/03_is::doc}}

\subsection{is和==}
\label{\detokenize{python/03_is:id1}}
\sphinxcode{\sphinxupquote{is}} 的作用是用来检查对象的标示符（object identity）是否一致，也就是比较两个对象在内存中的地址是否一样，而 \sphinxcode{\sphinxupquote{==}} 是用来检查两个对象是否相等。
我们在检查 \sphinxcode{\sphinxupquote{a is b}} 的时候，其实相当于检查 \sphinxcode{\sphinxupquote{id(a) == id(b)}}。而检查 \sphinxcode{\sphinxupquote{a == b}} 的时候，实际是调用了对象a的 \sphinxcode{\sphinxupquote{\_\_eq\_\_()}} 方法，\sphinxcode{\sphinxupquote{a == b}}
相当于 \sphinxcode{\sphinxupquote{a.\_\_eq\_\_(b)}}。
一般情况下，如果 \sphinxcode{\sphinxupquote{a is b}} 返回True的话，即a和b指向同一块内存地址的话，\sphinxcode{\sphinxupquote{a == b}} 也返回True，即a和b的值也相等。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{==}\PYG{n}{b}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o+ow}{is} \PYG{n}{b}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{140568052594368}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{140568052594368}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello world}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello world}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{==}\PYG{n}{b}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o+ow}{is} \PYG{n}{b}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{140568052594752}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{140568052594320}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{==}\PYG{n}{b}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o+ow}{is} \PYG{n}{b}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Python缓存了整数和短字符串，因此每个对象在内存中只存有一份。

Python没有缓存长字符串、列表及其他对象，可以有多个相同的对象。
\end{sphinxadmonition}


\subsection{None}
\label{\detokenize{python/03_is:none}}
与 \sphinxcode{\sphinxupquote{None}} 比较是 \sphinxcode{\sphinxupquote{is None}} 而不是 \sphinxcode{\sphinxupquote{== None}} 。
这是因为 \sphinxcode{\sphinxupquote{None}} 在Python里是个单例对象（singleton）：一个变量如果是 \sphinxcode{\sphinxupquote{None}} ，它一定和 \sphinxcode{\sphinxupquote{None}} 指向同一个内存地址。
而 \sphinxcode{\sphinxupquote{== None}} 背后调用的是 \sphinxcode{\sphinxupquote{\_\_eq\_\_}} ，而 \sphinxcode{\sphinxupquote{\_\_eq\_\_}} 可以被重载，下面是一个 \sphinxcode{\sphinxupquote{is not None}} 但 \sphinxcode{\sphinxupquote{== None}} 的例子。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{class} \PYG{n+nc}{Foo}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}eq\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }       \PYG{k}{return} \PYG{n+nb+bp}{True}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo} \PYG{o}{=} \PYG{n}{Foo}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo} \PYG{o}{==} \PYG{n+nb+bp}{None}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}
\PYG{g+go}{False}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/03_is:id2}}\begin{enumerate}
\item {} 
经典7大Python面试题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qq\_41597912/article/details/81459804}
\end{quote}


\section{装饰器}
\label{\detokenize{python/04_decorator::doc}}\label{\detokenize{python/04_decorator:id1}}

\subsection{作用}
\label{\detokenize{python/04_decorator:id2}}
装饰器本质上是一个Python函数，它可以让其他函数在 \sphinxstylestrong{不需要做任何代码变动} 的前提下 \sphinxstylestrong{增加额外功能} ，装饰器的返回值也是一个函数对象。
它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。
装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。

概括的讲，装饰器的作用就是为已经存在的函数或对象添加额外的功能。


\subsection{使用装饰器计时}
\label{\detokenize{python/04_decorator:id3}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{wraps}
\PYG{k+kn}{import} \PYG{n+nn}{time}

\PYG{k}{def} \PYG{n+nf}{timer}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@wraps}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{function\PYGZus{}timer}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{start\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{result} \PYG{o}{=} \PYG{n}{func}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
        \PYG{n}{end\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{time (s): }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end\PYGZus{}time} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}time}
        \PYG{k}{return} \PYG{n}{result}
    \PYG{k}{return} \PYG{n}{function\PYGZus{}timer}

\PYG{n+nd}{@timer}
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{return} \PYG{l+m+mi}{0}

\PYG{k}{print} \PYG{n}{foo}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}
\PYG{k}{print} \PYG{n}{foo}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}}
\end{sphinxVerbatim}

使用 \sphinxcode{\sphinxupquote{wraps}} 可以保持函数 \sphinxcode{\sphinxupquote{foo()}} 的属性 \sphinxcode{\sphinxupquote{\_\_name\_\_}} 和 \sphinxcode{\sphinxupquote{\_\_doc\_\_}} ，而不变成函数 \sphinxcode{\sphinxupquote{function\_timer}} 的相关属性。


\subsection{参考资料}
\label{\detokenize{python/04_decorator:id4}}\begin{enumerate}
\item {} 
详解Python的装饰器

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/cicaday/p/python-decorator.html}
\end{quote}


\section{迭代器和生成器}
\label{\detokenize{python/05_iterator::doc}}\label{\detokenize{python/05_iterator:id1}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{05_iterator}.png}\hspace*{\fill}}


\subsection{迭代器（iterator）}
\label{\detokenize{python/05_iterator:iterator}}\begin{description}
\item[{特点：}] \leavevmode\begin{itemize}
\item {} 
迭代器是访问集合元素的一种方式，不能随机访问集合中的某个值，只能从头到尾依次访问（ \sphinxcode{\sphinxupquote{next()}} 方法），访问到一半时不能往回退。

\item {} 
不需要事先准备好整个迭代过程中的所有元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。

\item {} 
便于循环比较大的数据集合，节省内存。

\item {} 
不能复制一个迭代器，如果要再次（或者同时）迭代同一个对象，只能去创建另一个迭代器对象。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} enumerate 返回迭代器}
\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 迭代两次enumerate对象}
    \PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{========}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

结果是：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\end{sphinxVerbatim}

可以发现：第二次返回值为空。

\end{description}


\subsubsection{可迭代对象（iterable）}
\label{\detokenize{python/05_iterator:iterable}}
\sphinxstylestrong{可以直接作用于for循环的对象统称为可迭代对象（Iterable）} 。只要定义了可以返回一个迭代器的 \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 方法，或者定义了可以支持下标索引的 \sphinxcode{\sphinxupquote{\_\_getitem\_\_()}} 方法，那么它就是一个可迭代对象。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Iterator\PYGZus{}test}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}

  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}iter\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{return} \PYG{n+nb+bp}{self}

  \PYG{k}{def} \PYG{n+nf}{next}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{:}
          \PYG{k}{raise} \PYG{n+ne}{StopIteration}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
      \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index}\PYG{p}{]}

\PYG{n}{iterator\PYGZus{}winter} \PYG{o}{=} \PYG{n}{Iterator\PYGZus{}test}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcde}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{iterator\PYGZus{}winter}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{item}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 打印 e d c b a}

\PYG{k}{class} \PYG{n+nc}{Iterator\PYGZus{}test2}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{it}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{it}\PYG{p}{]}
\PYG{n}{no\PYGZus{}iter} \PYG{o}{=} \PYG{n}{Iterator\PYGZus{}test2}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcde}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{no\PYGZus{}iter}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{item}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 打印 a b c d e}
\end{sphinxVerbatim}

常见的可迭代对象：
\begin{itemize}
\item {} 
集合数据类型，如list、tuple、dict、set、str等。

\item {} 
generator，包括生成器和带yield的generator function。

\end{itemize}

\sphinxstylestrong{可以被next()函数调用并不断返回下一个值的对象称为迭代器（Iterator）} 。生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。

\sphinxstylestrong{所有的Iterable均可以通过内置函数iter()来转变为Iterator} 。

判断一个对象是否是可迭代对象：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{Iterable}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{Iterable}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} True}

\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 或 a.next()，返回 1}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 返回 2}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 返回 3}
\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 抛出 StopIteration 异常}
\end{sphinxVerbatim}

一个可迭代对象是不能独立进行迭代的，Python中， 迭代是通过 \sphinxcode{\sphinxupquote{for ... in}} 来完成的 。
for循环会不断调用迭代器对象的 \sphinxcode{\sphinxupquote{\_\_next\_\_()}} 方法（python3  \sphinxcode{\sphinxupquote{\_\_next\_\_()}} ；python2  \sphinxcode{\sphinxupquote{next()}} ），每次循环，都返回迭代器对象的下一个值，直到遇到 \sphinxcode{\sphinxupquote{StopIteration}} 异常。

任何实现了 \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 和 \sphinxcode{\sphinxupquote{\_\_next\_\_()}} （python2中实现 \sphinxcode{\sphinxupquote{next()}} ）方法的对象都是迭代器， \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 返回迭代器自身， \sphinxcode{\sphinxupquote{\_\_next\_\_()}} 返回容器中的下一个值 。


\subsection{生成器（generator）}
\label{\detokenize{python/05_iterator:generator}}
生成器其实是一种特殊的迭代器。它不需要再像上面的类一样写 \sphinxcode{\sphinxupquote{\_\_iter\_\_()}} 和 \sphinxcode{\sphinxupquote{\_\_next\_\_()}} 方法了，只需要一个 \sphinxcode{\sphinxupquote{yiled}} 关键字。 \sphinxcode{\sphinxupquote{yield}} 就是return返回的一个值，并且记住这个返回的位置。下一次迭代就从这个位置开始。
生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{generator\PYGZus{}winter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}
  \PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{:}
      \PYG{k}{yield} \PYG{n}{i}
      \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n}{generator\PYGZus{}iter} \PYG{o}{=} \PYG{n}{generator\PYGZus{}winter}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 1}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 2}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 3}
\PYG{k}{print} \PYG{n}{generator\PYGZus{}iter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 抛出 StopIteration 异常}
\end{sphinxVerbatim}

\sphinxstylestrong{生成器表达式} （类似于列表推导式，只是把{[}{]}换成()）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gen} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZlt{}generator object \PYGZlt{}genexpr\PYGZgt{} at 0x0000000012BC4990\PYGZgt{}}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{gen}\PYG{p}{:}
  \PYG{k}{print} \PYG{n}{item}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} fibonacci 数列}
\PYG{k}{def} \PYG{n+nf}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
  \PYG{k}{while} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{n}\PYG{p}{:}
      \PYG{k}{yield} \PYG{n}{b}
      \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{item}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/05_iterator:id2}}\begin{enumerate}
\item {} 
Python迭代器，生成器\textendash{}精华中的精华

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/deeper/p/7565571.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
python 生成器和迭代器有这篇就够了

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/wj-1314/p/8490822.html}
\end{quote}


\section{lambda用法}
\label{\detokenize{python/06_lambda::doc}}\label{\detokenize{python/06_lambda:lambda}}
使用：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{p}{[}\PYG{n}{arg1}\PYG{p}{[}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{argN}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:} \PYG{n}{expression}
\end{sphinxVerbatim}
\begin{description}
\item[{特性：}] \leavevmode\begin{itemize}
\item {} 
匿名函数。函数没有名字。

\item {} 
输入是arg list，输出是根据expression计算得到的值。

\item {} 
功能简单。

\end{itemize}

\end{description}


\subsection{使用场景}
\label{\detokenize{python/06_lambda:id1}}\begin{enumerate}
\item {} 
将lambda函数赋值给一个变量，通过这个变量间接调用该函数。

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{plus} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}
\PYG{k}{print} \PYG{n}{plus}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
将lambda函数赋值给其他函数，从而屏蔽其他函数本来的功能。

\item {} 
将lambda函数作为其他函数的返回值（内部函数）。

\item {} 
将lambda函数作为参数传递给其他函数。

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxstylestrong{map} ：将序列中的元素通过处理函数处理后返回一个新的列表。

\item {} 
\sphinxstylestrong{filter} ：将序列中的元素通过函数过滤后返回一个新的列表。

\item {} 
\sphinxstylestrong{reduce} ：将序列中的元素通过一个二元函数处理返回一个结果。

\item {} 
\sphinxstylestrong{sorted} ：结合lambda对列表进行排序。 \sphinxcode{\sphinxupquote{sorted(iterable, cmp=None, key=None, reverse=False)}}

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 每个元素加1}
\PYG{n}{b} \PYG{o}{=} \PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} [2, 3, 7, 6, 3, \PYGZhy{}7, \PYGZhy{}4, 0, \PYGZhy{}9]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 提取序列中大于0的数}
\PYG{n}{c} \PYG{o}{=} \PYG{n+nb}{filter}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} [1, 2, 6, 5, 2]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 返回所有元素相乘的结果}
\PYG{n}{d} \PYG{o}{=} \PYG{n+nb}{reduce}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{n}{y}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 48000}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 负数排在正数前面，同时绝对值大的排在后面}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 两个key，先按第一个key排序，若第一个key相同则按下一个key排序}
\PYG{n}{e} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} [\PYGZhy{}1, \PYGZhy{}5, \PYGZhy{}8, \PYGZhy{}10, 1, 2, 2, 5, 6]}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/06_lambda:id2}}\begin{enumerate}
\item {} 
关于Python中的lambda，这可能是你见过的最完整的讲解

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zjuxsl/article/details/79437563}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
在Python中使用lambda高效操作列表的教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/mxp-neu/articles/5316557.html}
\end{quote}


\section{*args和**kwargs}
\label{\detokenize{python/07_arg:args-kwargs}}\label{\detokenize{python/07_arg::doc}}

\subsection{*args}
\label{\detokenize{python/07_arg:args}}
\sphinxcode{\sphinxupquote{*args}} 用来将 \sphinxstylestrong{不定数量} 的参数打包成 \sphinxcode{\sphinxupquote{tuple}} 给函数体使用。

例一：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{args[\PYGZob{}\PYGZcb{}]:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{args}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{200k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{args[0]: 100}
\PYG{g+go}{args[1]: 200k}
\PYG{g+go}{args[2]: 300}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{args} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{x: A}
\PYG{g+go}{args[0]: 1}
\PYG{g+go}{args[1]: 2}
\PYG{g+go}{args[2]: abc}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 注：此时把args当做一个参数，参数类型为列表}
\PYG{g+go}{x: A}
\PYG{g+go}{args[0]: [1, 2, \PYGZsq{}abc\PYGZsq{}]}
\end{sphinxVerbatim}

例二：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{var1}\PYG{p}{,} \PYG{n}{var2}\PYG{p}{,} \PYG{n}{var3}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var1:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var1}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var2:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var2}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var3:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var3}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{args} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} list}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{TypeError: foo() takes exactly 4 arguments (2 given)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: 1}
\PYG{g+go}{var2: 2}
\PYG{g+go}{var3: A}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{args} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} tuple}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{TypeError: foo() takes exactly 4 arguments (2 given)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: 1}
\PYG{g+go}{var2: 2}
\PYG{g+go}{var3: A}
\end{sphinxVerbatim}


\subsection{**kwargs}
\label{\detokenize{python/07_arg:kwargs}}
\sphinxcode{\sphinxupquote{**kwargs}} 打包 \sphinxstylestrong{不定数量} 的键值对参数成 \sphinxcode{\sphinxupquote{dict}} 给函数体使用。

例一：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{key}\PYG{p}{,} \PYG{n}{val} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{} : \PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{n}{var1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{var2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{var3}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{var1 : 1}
\PYG{g+go}{var3 : [1, 2, 3]}
\PYG{g+go}{var2 : a}
\end{sphinxVerbatim}

例二：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{var1}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{var2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var1:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var1}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var2:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var2}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dict\PYGZus{}input} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{dict\PYGZus{}input}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: \PYGZob{}\PYGZsq{}var1\PYGZsq{}: 10, \PYGZsq{}var2\PYGZsq{}: \PYGZsq{}A\PYGZsq{}\PYGZcb{}}
\PYG{g+go}{var2: a}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{dict\PYGZus{}input}\PYG{p}{)}
\PYG{g+go}{x: 1}
\PYG{g+go}{var1: 10}
\PYG{g+go}{var2: A}
\end{sphinxVerbatim}


\subsection{arg，*args，**kwargs}
\label{\detokenize{python/07_arg:arg-args-kwargs}}
位置参数、*args、**kwargs三者的顺序必须是（arg，*args，**kwargs）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{arg:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{arg}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{args:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{args}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kwargs:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{kwargs}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{arg: 1}
\PYG{g+go}{args: (2, 3, 4)}
\PYG{g+go}{kwargs: \PYGZob{}\PYGZsq{}y\PYGZsq{}: \PYGZsq{}b\PYGZsq{}, \PYGZsq{}x\PYGZsq{}: 1\PYGZcb{}}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{SyntaxError: non\PYGZhy{}keyword arg after keyword arg}
\end{sphinxVerbatim}

位置参数、默认参数、**kwargs三者的顺序必须是（位置参数，默认参数，**kwargs）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 不能出现 (x=1,y,**kwargs)}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{y}
  \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kwargs:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{kwargs}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{foo}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{var1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{var2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{x: 4}
\PYG{g+go}{y: 1}
\PYG{g+go}{kwargs: \PYGZob{}\PYGZsq{}var1\PYGZsq{}: 1, \PYGZsq{}var2\PYGZsq{}: \PYGZsq{}b\PYGZsq{}\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/07_arg:id1}}\begin{enumerate}
\item {} 
大话Python中*args和**kargs的使用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/shitaotao/p/7609990.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
python函数——形参中的：*args和**kwargs

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/xuyuanyuan123/p/6674645.html}
\end{quote}


\section{基本数据类型}
\label{\detokenize{python/08_basicType::doc}}\label{\detokenize{python/08_basicType:id1}}

\subsection{类型与方法}
\label{\detokenize{python/08_basicType:id2}}\begin{itemize}
\item {} 
\sphinxstylestrong{str}
\begin{itemize}
\item {} 
索引、切片：{[}ind{]}，{[}first:last{]}获取区间 {[}first, last) 内的元素。

\item {} 
长度：len()

\item {} 
查找：若字符/序列不在字符串内，index()报错 ValueError，find()返回-1。

\item {} 
判断字符串内容：字母，isalpha()；数字，isdigit()；数字或字母，isalnum()。

\item {} 
大小写转换：capitalize()、lower()、upper()。

\item {} 
判断以什么开头结尾：startswith()、endswith()。

\item {} 
连接：join()，将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串。

\item {} 
分割：split()、partition()。 \sphinxstylestrong{如果想把字符串分割成独立的字符，用 list(string)。}

\item {} 
替代：replace()

\item {} 
清除空白: strip()、lstrip()、rstrip()

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{abcde}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{a\PYGZhy{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{def}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ghi}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{abc\PYGZus{}def\PYGZus{}ghi}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}
\PYG{g+go}{[\PYGZsq{}abc\PYGZsq{}, \PYGZsq{}def\PYGZsq{}, \PYGZsq{}ghi\PYGZsq{}]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a\PYGZhy{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{partion}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 只能分割为3部分}
\PYG{g+go}{(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZsq{}, \PYGZsq{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e\PYGZsq{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}, \PYGZsq{}e\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}
\PYG{g+go}{\PYGZdq{}a\PYGZhy{}b\PYGZhy{}c\PYGZhy{}d\PYGZhy{}e\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxstylestrong{str} 是不可变对象，其所有方法都 \sphinxstylestrong{不改变对象本身} ，而是返回所创建的新对象。
\end{sphinxadmonition}

\item {} 
\sphinxstylestrong{list}
\begin{itemize}
\item {} 
索引、切片：{[}ind{]}，{[}first:last{]}获取区间 {[}first, last) 内的元素。

\item {} 
统计元素出现的次数：count()

\item {} 
追加：append()

\item {} 
拓展：extend()

\item {} 
插入：insert()

\item {} 
弹出元素：pop()，默认弹出列表末尾的元素

\item {} 
移除/删除元素：remove()，del （del可删除切片）

\item {} 
排序：sort()

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 2, 3, 4]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 2, 3, 4, 10, 20, 30]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 在第一个元素之后插入}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 5, 2, 3, 4, 10, 20, 30]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 5, 3, 4, 10, 20, 30]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 5, 3, 10, 20, 30]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{reverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[30, 20, 10, 5, 3, 1] \PYGZsh{}\PYGZsh{} 直接修改 a，无返回值。使用 sorted 返回排序后的副本。}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a2} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a2}
\PYG{g+go}{10}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[30, 20, 5, 3, 1]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{dict}
\begin{itemize}
\item {} 
获取：keys()，values()，items()。

\item {} 
清除：clear()

\item {} 
访问：get(key)，不存在时返回None。

\item {} 
更新：update(d)，把另一个字典d中的项添加到当前字典。

\item {} 
浅复制：copy()

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info} \PYG{o}{=}\PYG{p}{\PYGZob{}}
\PYG{g+gp}{... }     \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tom}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{g+gp}{... }      \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{,}
\PYG{g+gp}{... }      \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sex}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{man}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{g+gp}{... }     \PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}age\PYGZsq{}, \PYGZsq{}name\PYGZsq{}, \PYGZsq{}sex\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[25, \PYGZsq{}Tom\PYGZsq{}, \PYGZsq{}man\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[(\PYGZsq{}age\PYGZsq{}, 25), (\PYGZsq{}name\PYGZsq{}, \PYGZsq{}Tom\PYGZsq{}), (\PYGZsq{}sex\PYGZsq{}, \PYGZsq{}man\PYGZsq{})]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{age}\PYG{p}{)}
\PYG{g+go}{25}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{new} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{60}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{new}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}
\PYG{g+go}{\PYGZob{}\PYGZsq{}age\PYGZsq{}: 25, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}Tom\PYGZsq{}, \PYGZsq{}weight\PYGZsq{}: 60, \PYGZsq{}sex\PYGZsq{}: \PYGZsq{}man\PYGZsq{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info}
\PYG{g+go}{\PYGZob{}\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{collections.defaultdict} ：defaultdict类使用一种给定数据类型来初始化。当所访问的key不存在的时候，会实例化一个value作为默认值。因此，判断某个key是否存在，可使用get(key)。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{defaultdict}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dd} \PYG{o}{=} \PYG{n}{defaultdict}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 使用 list 作为value type}
\PYG{g+go}{defaultdict(\PYGZlt{}type \PYGZsq{}list\PYGZsq{}\PYGZgt{}, \PYGZob{}\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dd}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{[]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dd}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{defaultdict(\PYGZlt{}type \PYGZsq{}list\PYGZsq{}\PYGZgt{}, \PYGZob{}\PYGZsq{}a\PYGZsq{}: [], \PYGZsq{}b\PYGZsq{}: [\PYGZsq{}hello\PYGZsq{}]\PYGZcb{})}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
如果一个defaultdict必须包含给定的key，则首先要 \sphinxstylestrong{显式} 地对所有的key进行访问和初始化。毕竟defaultdict只会为访问过的key关联一个默认值。
\end{sphinxadmonition}

\item {} 
\sphinxstylestrong{set}
\begin{itemize}
\item {} 
特征：无重复，无须，每个元素为不可变类型

\item {} 
增加元素：单个元素，add()；多个元素，update()

\item {} 
删除：删除元素不存在，remove()报错，discard()无反应。

\item {} 
集合操作：\&，\textbar{}，-，\textasciicircum{}（交差补集，去除交集后剩下元素的并集），issubset() 、isupperset()。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 或者 s1 = set([\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}
\PYG{g+go}{set([\PYGZsq{}a\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}e\PYGZsq{}, \PYGZsq{}d\PYGZsq{}])}
\end{sphinxVerbatim}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
对于 \sphinxcode{\sphinxupquote{切片（slice）}} 操作，下标越界 \sphinxstylestrong{不会} 报错，返回空。

对于 \sphinxcode{\sphinxupquote{索引（index）}} 操作，下标越界 \sphinxstylestrong{会} 报错。
\end{sphinxadmonition}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{j}\PYG{p}{]}

\PYG{n}{The} \PYG{n+nb}{slice} \PYG{n}{of} \PYG{n}{s} \PYG{k+kn}{from} \PYG{n+nn}{i} \PYG{n}{to} \PYG{n}{j} \PYG{o+ow}{is} \PYG{n}{defined} \PYG{k}{as} \PYG{n}{the} \PYG{n}{sequence} \PYG{n}{of} \PYG{n}{items} \PYG{k}{with} \PYG{n}{index} \PYG{n}{k} \PYG{n}{such} \PYG{n}{that} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{o}{.}

\PYG{n}{If} \PYG{n}{i} \PYG{o+ow}{or} \PYG{n}{j} \PYG{o+ow}{is} \PYG{n}{greater} \PYG{n}{than} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{,} \PYG{n}{use} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{If} \PYG{n}{i} \PYG{o+ow}{is} \PYG{n}{omitted} \PYG{o+ow}{or} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{use} \PYG{l+m+mf}{0.}
\PYG{n}{If} \PYG{n}{j} \PYG{o+ow}{is} \PYG{n}{omitted} \PYG{o+ow}{or} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{use} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{If} \PYG{n}{i} \PYG{o+ow}{is} \PYG{n}{greater} \PYG{n}{than} \PYG{o+ow}{or} \PYG{n}{equal} \PYG{n}{to} \PYG{n}{j}\PYG{p}{,} \PYG{n}{the} \PYG{n+nb}{slice} \PYG{o+ow}{is} \PYG{n}{empty}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{深复制和浅复制}
\label{\detokenize{python/08_basicType:id3}}\begin{itemize}
\item {} 
\sphinxstylestrong{直接赋值} ：并没有拷贝对象，而是拷贝了对象的引用，因此原始对象或被赋值对象的改变，都会导致另一个对象被修改。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{alist} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 引用}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{alist}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 复制}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}
\PYG{g+go}{[1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{[1, 2, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{[1, 2, 3]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{浅复制} ：只会复制父对象，而不会复制对象的内部的子对象。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{copy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} [\PYGZsq{}a\PYGZsq{},\PYGZsq{}b\PYGZsq{}] 是列表，是一个子对象}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy} \PYG{o}{=} \PYG{n}{copy}\PYG{p}{(}\PYG{n}{alist}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} dict类有copy()方法，e.g.，d.copy()}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 非子对象的修改}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}], 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}], 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}]]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 子对象的修改}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}], 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}], 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[\PYGZhy{}1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}]]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{深复制} ：复制对象及其子对象，原始对象的改变不会造成深复制里任何子元素的改变。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{deepcopy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} [\PYGZsq{}a\PYGZsq{},\PYGZsq{}b\PYGZsq{}] 是列表，是一个子对象}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{alist}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 子对象的修改}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alist}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a\PYGZus{}copy}
\PYG{g+go}{[1, 2, 3, [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}d\PYGZsq{}]]}
\end{sphinxVerbatim}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
对于可变对象 \sphinxstylestrong{dict} 和 \sphinxstylestrong{list} ，需要暂存临时对象或者作为函数参数传递时，如果不希望对象被更改，都需要使用深复制。
\end{sphinxadmonition}


\subsection{再谈可变对象与不可变对象}
\label{\detokenize{python/08_basicType:id4}}
第一章曾提到过可变对象与不可变对象。

\sphinxstylestrong{dict} 和 \sphinxstylestrong{set} 的底层实现都是 \sphinxstylestrong{哈希表} 。哈希要求key唯一，因此 \sphinxstylestrong{dict} 和 \sphinxstylestrong{set} 的key都要求是 \sphinxstylestrong{不可变对象} 。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcd}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{313010056L}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcd}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{g+go}{313010056L}
\PYG{g+go}{\PYGZsh{}\PYGZsh{} x 和 y 都是 str 对象的引用，值相同，占用同一块内存。}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{314009096L}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} b = a[:]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{314011080L}
\PYG{g+go}{\PYGZsh{}\PYGZsh{} a 和 b 的 id 不同，尽管值相同}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}
\PYG{g+go}{[5, 3, 4, 3, 1]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{314011080L}
\PYG{g+go}{\PYGZsh{}\PYGZsh{} 改变 b，仍然是同一个对象，因此是可变对象}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/08_basicType:id5}}\begin{enumerate}
\item {} 
Python基本数据类型

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/littlefivebolg/p/8982889.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
切片python字符串时 为何不会引起下标越界?

\end{enumerate}
\begin{quote}

\sphinxurl{https://segmentfault.com/q/1010000011412371}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
python中defaultdict方法的使用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/dancesir/p/8142775.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
python的复制，深拷贝和浅拷贝的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/xueli/p/4952063.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Python学习日记之字典深复制与浅复制

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/mokero/p/6662202.html}
\end{quote}


\section{random}
\label{\detokenize{python/09_random:random}}\label{\detokenize{python/09_random::doc}}

\subsection{random}
\label{\detokenize{python/09_random:id1}}
python自带的random库。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{random.random()}
\begin{itemize}
\item {} 
生成0\textasciitilde{}1的随机浮点数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.uniform(a,b)}
\begin{itemize}
\item {} 
生成指定范围{[}a, b{]}内的随机浮点数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.randint(a,b)}
\begin{itemize}
\item {} 
生成指定范围{[}a, b{]}内的随机整数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.randrange(start,stop,step)}
\begin{itemize}
\item {} 
指定范围内，按step递增的集合中的随机数。

\end{itemize}

\item {} 
\sphinxstylestrong{random.choice(lst)}
\begin{itemize}
\item {} 
给定的集合中选择一个元素。

\end{itemize}

\item {} 
\sphinxstylestrong{random.shuffle(lst)}
\begin{itemize}
\item {} 
对一个序列或者元组随机打乱。

\end{itemize}

\end{itemize}


\subsection{numpy.random}
\label{\detokenize{python/09_random:numpy-random}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{numpy.random.random({[}} \(d_0, d_1, ... ,d_n\) \sphinxstylestrong{{]})}
\begin{itemize}
\item {} 
生成0\textasciitilde{}1的随机浮点数，维度为 \(d_0 \times d_1 \times ... \times d_n\) （缺省为1）。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.rand(} \(d_0, d_1, ... ,d_n\) \sphinxstylestrong{)}
\begin{itemize}
\item {} 
生成0\textasciitilde{}1的随机浮点数，维度为 \(d_0 \times d_1 \times ... \times d_n\) （缺省为1）。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.randn(} \(d_0, d_1, ... ,d_n\) \sphinxstylestrong{)}
\begin{itemize}
\item {} 
标准正态分布。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.randint(low, high=None, size=None, dtype=’l’)}
\begin{itemize}
\item {} 
返回随机的整数，位于半开区间 {[}low, high)。如果high=None，区间为{[}0, low)。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.choice(arr, size=None, replace=True, p=None)}
\begin{itemize}
\item {} 
从一个给定的一维数组，按概率p抽样一定数量的元素，replace=True表示允许重复元素。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.shuffle(arr)}
\begin{itemize}
\item {} 
随机打乱arr。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.permutation(arr)}
\begin{itemize}
\item {} 
返回一个随机排列。

\end{itemize}

\item {} 
\sphinxstylestrong{numpy.random.seed(n)}
\begin{itemize}
\item {} 
改变随机数生成器的种子。设置相同的seed，每次生成的随机数相同；如果不设置seed，则每次会生成不同的随机数。

\end{itemize}

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 注：生成的数组都是 numpy array 类型}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{2.5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{3}
\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.52410303}  \PYG{l+m+mf}{1.68461615} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.04895917}  \PYG{l+m+mf}{2.81907944}\PYG{p}{]}
 \PYG{p}{[} \PYG{l+m+mf}{6.89754303}  \PYG{l+m+mf}{2.95949232}  \PYG{l+m+mf}{1.85296809}  \PYG{l+m+mf}{1.56361545}\PYG{p}{]}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{]}
 \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 从 np.arange(4) 选取 3 个元素}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{9} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{3}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{shuffle}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{k}{print} \PYG{n}{arr}
\PYG{p}{[}\PYG{l+m+mi}{6} \PYG{l+m+mi}{9} \PYG{l+m+mi}{0} \PYG{l+m+mi}{8} \PYG{l+m+mi}{1} \PYG{l+m+mi}{7} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{5} \PYG{l+m+mi}{8} \PYG{l+m+mi}{9} \PYG{l+m+mi}{7} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{6} \PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{[} \PYG{l+m+mi}{9}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{4} \PYG{l+m+mi}{12} \PYG{l+m+mi}{15}\PYG{p}{]}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}
\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5}\PYG{p}{]}
 \PYG{p}{[}\PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{l+m+mi}{8}\PYG{p}{]}
 \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}

\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{0.417022004702574}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{0.417022004702574}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{0.7203244934421581}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/09_random:id2}}\begin{enumerate}
\item {} 
random与numpy.random

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/36a4bbb5536e}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
numpy的random模块详细解析

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/zuoshoushizi/p/8727773.html}
\end{quote}


\section{归一化}
\label{\detokenize{python/10_normalize::doc}}\label{\detokenize{python/10_normalize:id1}}

\subsection{numpy.linalg.norm}
\label{\detokenize{python/10_normalize:numpy-linalg-norm}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n+nb}{ord}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{sklearn.preprocessing.normalize}
\label{\detokenize{python/10_normalize:sklearn-preprocessing-normalize}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sklearn.preprocessing.normalize(X, norm=’l2’, axis=1, copy=True, return\PYGZus{}norm=False)
\end{sphinxVerbatim}


\subsection{torch.nn.functional.normalize}
\label{\detokenize{python/10_normalize:torch-nn-functional-normalize}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{torch}\PYG{o}{.}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{functional}\PYG{o}{.}\PYG{n}{normalize}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{dim}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{eps}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}12}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy.linalg} \PYG{k+kn}{as} \PYG{n+nn}{la}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{arr}
\PYG{g+go}{[[ 2.  1.  2.]}
\PYG{g+go}{ [ 2.  1.  1.]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{norm} \PYG{o}{=} \PYG{n}{la}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{norm}
\PYG{g+go}{[[ 2.82842708  1.41421354  2.23606801]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{arr} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tile}\PYG{p}{(}\PYG{n}{norm}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[[ 0.70710677  0.70710677  0.89442718]}
\PYG{g+go}{ [ 0.70710677  0.70710677  0.44721359]]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{n}{preprocessing}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{preprocessing}\PYG{o}{.}\PYG{n}{normalize}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{norm}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[[ 0.70710677  0.70710677  0.89442718]}
\PYG{g+go}{ [ 0.70710677  0.70710677  0.44721359]]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{torch.nn.functional} \PYG{k+kn}{as} \PYG{n+nn}{F}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{F}\PYG{o}{.}\PYG{n}{normalize}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{from\PYGZus{}numpy}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{dim}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{0.7071  0.7071  0.8944}
\PYG{g+go}{0.7071  0.7071  0.4472}
\PYG{g+go}{[torch.FloatTensor of size 2x3]}
\end{sphinxVerbatim}


\subsection{k-means 实现}
\label{\detokenize{python/10_normalize:k-means}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} feature initialization}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{10000}
\PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{K} \PYG{o}{=} \PYG{l+m+mi}{50}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} n x d}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} feature  normalization}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{data} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tile}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} center initialization}
\PYG{n}{center} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{K}\PYG{p}{]}\PYG{p}{]}

\PYG{n}{itr} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} loop}
\PYG{k}{while} \PYG{n}{itr} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{:}
    \PYG{n}{itr} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} quantization}
    \PYG{n}{similarity} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{center}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}
    \PYG{n}{quan\PYGZus{}id} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argsort}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{similarity}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} update center}
    \PYG{n}{new\PYGZus{}error} \PYG{o}{=} \PYG{l+m+mf}{0.0}
    \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{data\PYGZus{}c} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{quan\PYGZus{}id} \PYG{o}{==} \PYG{n}{c}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{data\PYGZus{}c}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
          \PYG{n}{center}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{data\PYGZus{}c}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
          \PYG{n}{new\PYGZus{}error} \PYG{o}{+}\PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{n}{data\PYGZus{}c} \PYG{o}{\PYGZhy{}} \PYG{n}{center}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

    \PYG{k}{if} \PYG{n}{itr} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{o+ow}{and} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{new\PYGZus{}error}\PYG{o}{/}\PYG{n}{old\PYGZus{}error}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{:}
        \PYG{k}{break}
    \PYG{n}{old\PYGZus{}error} \PYG{o}{=} \PYG{n}{new\PYGZus{}error}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/10_normalize:id2}}\begin{enumerate}
\item {} 
numpy.linalg.norm

\end{enumerate}
\begin{quote}

\sphinxurl{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.linalg.norm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
sklearn.preprocessing.normalize

\end{enumerate}
\begin{quote}

\sphinxurl{https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
torch.nn.functional.normalize

\end{enumerate}
\begin{quote}

\sphinxurl{https://pytorch.org/docs/0.3.0/nn.html?highlight=normalize\#torch.nn.functional.normalize}
\end{quote}


\section{常用数据结构}
\label{\detokenize{python/11_dataStruct::doc}}\label{\detokenize{python/11_dataStruct:id1}}

\subsection{栈}
\label{\detokenize{python/11_dataStruct:id2}}
\sphinxstylestrong{list} 的 \sphinxcode{\sphinxupquote{append()}} 和 \sphinxcode{\sphinxupquote{pop()}} 方法使得list类型可以作为简单的栈使用。


\subsection{队列}
\label{\detokenize{python/11_dataStruct:id3}}

\subsubsection{Queue}
\label{\detokenize{python/11_dataStruct:queue}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Queue}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
FIFO

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Queue.Queue(maxsize=0)
先进先出。
maxsize指明了队列中能存放的数据个数的上限。
一旦达到上限，插入会导致阻塞，直到队列中的数据被消费掉。
如果maxsize小于或者等于0，队列大小没有限制。
\end{sphinxVerbatim}

\item {} 
LIFO

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Queue.LifoQueue(maxsize=0)
后进先出，类似于栈。
\end{sphinxVerbatim}

\item {} 
Priority

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Queue.PriorityQueue(maxsize=0)
优先队列。
一般使用tuple（优先级+数据）作为队列元素，优先级为tuple的第一项。
默认sorted(list(entries))[0])，即tuple第一项越小，优先级越高，越先出队列。
\end{sphinxVerbatim}

\end{itemize}

插入元素

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} que is an initialization of Queue}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
\end{sphinxVerbatim}

弹出并返回元素

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{item} \PYG{o}{=} \PYG{n}{que}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

判断是否为空

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{que}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

队列大小

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{que}\PYG{o}{.}\PYG{n}{qsize}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{Queue} \PYG{k+kn}{import} \PYG{n}{PriorityQueue}
\PYG{n}{que} \PYG{o}{=} \PYG{n}{PriorityQueue}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{app}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{que}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{que}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{que}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{que}\PYG{o}{.}\PYG{n}{qsize}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} print result}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} (1, \PYGZsq{}apple\PYGZsq{}) 2}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} (5, \PYGZsq{}banana\PYGZsq{}) 1}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} (10, \PYGZsq{}app\PYGZsq{}) 0}
\end{sphinxVerbatim}


\subsubsection{deque}
\label{\detokenize{python/11_dataStruct:deque}}
double-ended queue，双端队列。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k}{import} \PYG{n}{deque}
\end{sphinxVerbatim}
\begin{description}
\item[{方法：}] \leavevmode\begin{itemize}
\item {} 
append(), appendleft()

\item {} 
pop(), popleft()

\item {} 
extend(), extendleft()

\item {} 
reverse()

\item {} 
rotate()

\item {} 
count()

\item {} 
clear()

\end{itemize}

\end{description}

例子：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([0, 1, 2, 3, 4])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} right\PYGZhy{}shift}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([4, 0, 1, 2, 3])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([1, 2, 3, 4, 0])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} left\PYGZhy{}shift}
\PYG{g+go}{deque([4, 0, 1, 2, 3])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dq}
\PYG{g+go}{deque([3, 2, 1, 0, 4])}
\end{sphinxVerbatim}


\subsection{堆}
\label{\detokenize{python/11_dataStruct:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{heapq}
\end{sphinxVerbatim}

heapq创建的是 \sphinxstylestrong{小顶堆} ，堆顶元素是堆的最小元素。


\subsubsection{创建堆}
\label{\detokenize{python/11_dataStruct:id5}}\begin{itemize}
\item {} 
\sphinxstylestrong{heappush()}

基于空列表{[}{]}，使用 \sphinxcode{\sphinxupquote{heappush()}} 把元素逐个插入堆中。 \sphinxcode{\sphinxupquote{heappop(h)}} 弹出并返回堆顶元素。h{[}0{]}是最小值。

如果插入元素是元组（tuple），则元组的第一项自动成为优先级，值越小，优先级越高。堆顶元素优先级最高，值最小。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{heapsort}\PYG{p}{(}\PYG{n}{iterable}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{iterable}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappush}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{p}{[}\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 不能直接返回 h}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapsort}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{heapify(list\_x)}

把列表转换为堆，in-place，线性时间。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{132}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heapify}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{h}
\PYG{g+go}{[1, 2, 5, 3, 54, 23, 132] \PYGZsh{}\PYGZsh{} h 是堆，但是h不一定是有序的，只能保证 h[0] 是最小值。}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{p}{[}\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{[1, 2, 3, 5, 23, 54, 132]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{merge}

合并多个排序后的序列，返回排序后的序列的迭代器。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{132}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{656}\PYG{p}{,} \PYG{l+m+mi}{324}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h1} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{h1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h2} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{h2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{merge}\PYG{p}{(}\PYG{n}{h1}\PYG{p}{,} \PYG{n}{h2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}type \PYGZsq{}generator\PYGZsq{}\PYGZgt{} [2, 3, 5, 12, 23, 23, 23, 32, 34, 54, 54, 132, 324, 656]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{heapreplace}

删除堆中最小元素，并插入新的元素。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+m+mi}{54}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{132}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heapify}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heapreplace}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{p}{[}\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{[5, 9, 23, 32, 34, 54, 132]}
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{获取最值}
\label{\detokenize{python/11_dataStruct:id6}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nlargest}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{iterable}\PYG{p}{[}\PYG{p}{,} \PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nsmallest}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{iterable}\PYG{p}{[}\PYG{p}{,} \PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

返回一个长度为n的列表，包含数据中的前n个最大/最小的元素。使用key定义排序关键字。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nums} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nlargest}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}
\PYG{g+go}{[5, 4, 3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nsmallest}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}
\PYG{g+go}{[1, 2, 3]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{info} \PYG{o}{=} \PYG{p}{[}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IBM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{91.1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{AAPL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{543.22}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FB}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{21.09}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HPQ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{31.75}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{YHOO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{16.35}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ACME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{115.65}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{... }\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cheap} \PYG{o}{=} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nsmallest}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{info}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{n}{x}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{expensive} \PYG{o}{=} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{nlargest}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{info}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:}\PYG{n}{x}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{cheap}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}price\PYGZsq{}: 16.35, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}YHOO\PYGZsq{}\PYGZcb{}, \PYGZob{}\PYGZsq{}price\PYGZsq{}: 21.09, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}FB\PYGZsq{}\PYGZcb{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{expensive}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}price\PYGZsq{}: 543.22, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}AAPL\PYGZsq{}\PYGZcb{}, \PYGZob{}\PYGZsq{}price\PYGZsq{}: 115.65, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}ACME\PYGZsq{}\PYGZcb{}]}
\end{sphinxVerbatim}


\subsubsection{大顶堆}
\label{\detokenize{python/11_dataStruct:id7}}
heapq默认创建小顶堆，为了创建大顶堆，有以下trick:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappush}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 插入 x}
\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{heapq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 弹出堆顶元素}
\end{sphinxVerbatim}


\subsubsection{数列前K大的数}
\label{\detokenize{python/11_dataStruct:k}}
Hint：建立大小为K的小顶堆，对后续所有数进行遍历：如果大于堆顶元素，则有可能是前K大的数，堆顶元素弹出，插入该数。
时间复杂度 \(\mathcal{O}(NlogK)\)。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{heapq} \PYG{k+kn}{as} \PYG{n+nn}{hq}

\PYG{k}{class} \PYG{n+nc}{TopKHeap}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{k} \PYG{o}{=} \PYG{n}{k}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

  \PYG{k}{def} \PYG{n+nf}{push}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{k}\PYG{p}{:}
      \PYG{n}{hq}\PYG{o}{.}\PYG{n}{heappush}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
      \PYG{n}{min\PYGZus{}number} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
      \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{n}{min\PYGZus{}number}\PYG{p}{:}
        \PYG{n}{hq}\PYG{o}{.}\PYG{n}{heapreplace}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}

  \PYG{k}{def} \PYG{n+nf}{topk}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{reversed}\PYG{p}{(}\PYG{p}{[}\PYG{n}{hq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{nums} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
  \PYG{n}{tkh} \PYG{o}{=} \PYG{n}{TopKHeap}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{nums}\PYG{p}{:}
    \PYG{n}{tkh}\PYG{o}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
  \PYG{k}{print} \PYG{n}{tkh}\PYG{o}{.}\PYG{n}{topk}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} [9, 8, 7]}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
  \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{计数器}
\label{\detokenize{python/11_dataStruct:id8}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k}{import} \PYG{n}{Counter}
\end{sphinxVerbatim}

Counter用于统计频率。属性与字典类似，有keys()，values()，items()等。

\begin{sphinxadmonition}{note}{Note:}
Counter统计之后并不一定是按照频率从高到低排列的。
\end{sphinxadmonition}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 空计数器}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{word} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{cnt}\PYG{p}{[}\PYG{n}{word}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}blue\PYGZsq{}: 3, \PYGZsq{}red\PYGZsq{}: 2, \PYGZsq{}green\PYGZsq{}: 1\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}blue\PYGZsq{}: 3, \PYGZsq{}red\PYGZsq{}: 2, \PYGZsq{}green\PYGZsq{}: 1\PYGZcb{})}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt}\PYG{o}{.}\PYG{n}{most\PYGZus{}common}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 返回出现频率最高的两个元素}
\PYG{g+go}{[(\PYGZsq{}blue\PYGZsq{}, 3), (\PYGZsq{}red\PYGZsq{}, 2)]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gallahad}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}a\PYGZsq{}: 3, \PYGZsq{}l\PYGZsq{}: 2, \PYGZsq{}h\PYGZsq{}: 1, \PYGZsq{}g\PYGZsq{}: 1, \PYGZsq{}d\PYGZsq{}: 1\PYGZcb{})}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{Counter(\PYGZob{}\PYGZsq{}blue\PYGZsq{}: 12, \PYGZsq{}red\PYGZsq{}: 4\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 访问不存在关键字, 可使用 c.get(\PYGZsq{}green\PYGZsq{})}
\PYG{g+go}{0}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/11_dataStruct:id9}}\begin{enumerate}
\item {} 
python中的Queue(队列)详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/wdliu/p/6905396.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Python collections使用

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/f2a429aa5963}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Python标准库模块之heapq

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/801318c77ab5}

\sphinxurl{https://docs.python.org/2/library/heapq.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
python使用heapq实现小顶堆（TopK大）/大顶堆（BtmK小）

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/tanghaiyu777/article/details/55271004}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Counter

\end{enumerate}
\begin{quote}

\sphinxurl{https://docs.python.org/2/library/collections.html?highlight=counter}
\end{quote}


\section{逻辑运算与布尔测试}
\label{\detokenize{python/12_bool::doc}}\label{\detokenize{python/12_bool:id1}}

\subsection{逻辑运算}
\label{\detokenize{python/12_bool:id2}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{逻辑运算}\label{\detokenize{python/12_bool:id6}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
运算符
&\sphinxstyletheadfamily 
描述
\\
\hline
and
&
与，x and y：如果x为False，返回False，否则返回y的 \sphinxstylestrong{计算值}
\\
\hline
or
&
或，x or y：如果x为True，返回True，否则返回y的 \sphinxstylestrong{计算值}
\\
\hline
not
&
非，not x：如果x为True，返回False，否则返回True
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{and} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+go}{c}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{and} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+go}{False}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+go}{c}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+go}{True}
\end{sphinxVerbatim}


\subsection{成员运算}
\label{\detokenize{python/12_bool:id3}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{成员运算}\label{\detokenize{python/12_bool:id7}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
运算符
&\sphinxstyletheadfamily 
描述
\\
\hline
in
&
如果在指定列表/元组/字符串/字典中找到值，返回True，否则返回False
\\
\hline
not in
&
如果未在指定列表/元组/字符串/字典中找到值，返回True，否则返回False
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+go}{True}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cnt} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{cnt}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}} \PYG{o+ow}{in} \PYG{n}{cnt}
\PYG{g+go}{TypeError: unhashable type: \PYGZsq{}dict\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
查找的值必须是可哈希的，也就是不可变类型。
\end{sphinxadmonition}


\subsection{布尔测试}
\label{\detokenize{python/12_bool:id4}}
下面对象的布尔值都是 \sphinxcode{\sphinxupquote{False}} ：
\begin{itemize}
\item {} 
False（布尔类型）

\item {} 
None

\item {} 
“”（空字符串）

\item {} 
{[}{]}（空列表）

\item {} 
\{\}（空字典）

\item {} 
()（空元组）

\item {} 
所有值为零的数
\begin{itemize}
\item {} 
0（整型）

\item {} 
0.0（浮点型）

\item {} 
0L（长整型）

\item {} 
0.0 + 0.0j（复数）

\end{itemize}

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{flag} \PYG{o}{=} \PYG{n+nb+bp}{None}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{flag}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flag is none:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{flag}
    \PYG{k}{print} \PYG{n}{flag}\PYG{o}{==}\PYG{n+nb+bp}{False}

\PYG{n}{flag} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{flag}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flag is empty:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{flag}
    \PYG{k}{print} \PYG{n}{flag} \PYG{o}{==} \PYG{n+nb+bp}{False}
\PYG{n}{flag} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{n}{flag}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flag is not empty:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{flag}

\PYG{n}{flag} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{flag}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flag is empty:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{flag}
    \PYG{k}{print} \PYG{n}{flag} \PYG{o}{==} \PYG{n+nb+bp}{False}
\PYG{n}{flag} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{if} \PYG{n}{flag}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flag is not empty:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{flag}

\PYG{n}{flag} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{flag}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flag is empty:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{flag}
    \PYG{k}{print} \PYG{n}{flag} \PYG{o}{==} \PYG{n+nb+bp}{False}
\PYG{n}{flag} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{if} \PYG{n}{flag}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flag is not empty:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{flag}

\PYG{n}{flag} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{flag}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flag is zero:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{flag}
    \PYG{k}{print} \PYG{n}{flag} \PYG{o}{==} \PYG{n+nb+bp}{False}
\PYG{n}{flag} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{if} \PYG{n}{flag}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flag is not empty:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{flag}
\end{sphinxVerbatim}

输出结果为:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{flag} \PYG{o+ow}{is} \PYG{n}{none}\PYG{p}{:} \PYG{k+kc}{None}
\PYG{k+kc}{False}

\PYG{n}{flag} \PYG{o+ow}{is} \PYG{n}{empty}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k+kc}{False}
\PYG{n}{flag} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{empty}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}

\PYG{n}{flag} \PYG{o+ow}{is} \PYG{n}{empty}\PYG{p}{:} \PYG{p}{[}\PYG{p}{]}
\PYG{k+kc}{False}
\PYG{n}{flag} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{empty}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{n}{flag} \PYG{o+ow}{is} \PYG{n}{empty}\PYG{p}{:}        \PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZdq{}\PYGZdq{}}
\PYG{k+kc}{False}
\PYG{n}{flag} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{empty}\PYG{p}{:} \PYG{n}{a}

\PYG{n}{flag} \PYG{o+ow}{is} \PYG{n}{zero}\PYG{p}{:} \PYG{l+m+mf}{0.0}
\PYG{k+kc}{True}                  \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 只有这一个是True：0.0 == False}
\PYG{n}{flag} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{empty}\PYG{p}{:} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
布尔值是False，不代表等于False。

零的布尔值是False，同时也等于False。
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{python/12_bool:id5}}\begin{enumerate}
\item {} 
Python基本数据类型

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/littlefivebolg/p/8982889.html}
\end{quote}


\section{命名规范}
\label{\detokenize{python/13_name::doc}}\label{\detokenize{python/13_name:id1}}

\subsection{后缀单下划线}
\label{\detokenize{python/13_name:id2}}
避免与关键字冲突。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{class\PYGZus{}} \PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\subsection{前缀单下划线}
\label{\detokenize{python/13_name:id3}}
不能被 \sphinxcode{\sphinxupquote{from module\_name import *}} 导入。

对于类的成员变量和成员函数
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\_var}} ：保护成员（protected），类对象可以在外部访问

\item {} 
\sphinxcode{\sphinxupquote{\_func}} ：保护成员（protected），类对象可以在外部访问

\end{itemize}


\subsection{前缀双下划线}
\label{\detokenize{python/13_name:id4}}
不能被 \sphinxcode{\sphinxupquote{from module\_name import *}} 导入。

对于类的成员变量和成员函数
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\_\_var}} ：私有成员（private），类对象不可以在外部访问

\item {} 
\sphinxcode{\sphinxupquote{\_\_func}} ：私有成员（private），类对象不可以在外部访问

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} ac.py}
\PYG{n}{\PYGZus{}global} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{k}{def} \PYG{n+nf}{\PYGZus{}func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}func}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{:}
  \PYG{n}{var} \PYG{o}{=} \PYG{l+m+mi}{100}        \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 类变量（类对象共有）}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{0}  \PYG{c+c1}{\PYGZsh{}\PYGZsh{} protected}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}b} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} private}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2}

  \PYG{k}{def} \PYG{n+nf}{\PYGZus{}foo}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}foo}\PYG{l+s+s2}{\PYGZdq{}}

  \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}foo}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}foo}\PYG{l+s+s2}{\PYGZdq{}}

  \PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{foo}\PYG{l+s+s2}{\PYGZdq{}}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}b:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}b}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ac} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{obj} \PYG{o}{=} \PYG{n}{A}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{obj}\PYG{o}{.}\PYG{n}{var}
\PYG{g+go}{100}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{obj}\PYG{o}{.}\PYG{n}{c}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{obj}\PYG{o}{.}\PYG{n}{foo}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{foo}
\PYG{g+go}{\PYGZus{}\PYGZus{}b: 1}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{obj}\PYG{o}{.}\PYG{n}{\PYGZus{}a}
\PYG{g+go}{0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{\PYGZus{}foo}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZus{}foo}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{obj}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}b}
\PYG{g+go}{AttributeError: A instance has no attribute \PYGZsq{}\PYGZus{}\PYGZus{}b\PYGZsq{}}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{\PYGZus{}global}
\PYG{g+go}{NameError: name \PYGZsq{}\PYGZus{}global\PYGZsq{} is not defined}
\end{sphinxVerbatim}


\subsection{前后双下划线}
\label{\detokenize{python/13_name:id5}}
内建方法，如:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}}
\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/13_name:id6}}\begin{enumerate}
\item {} 
python 命名规范

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/a793c0d960fe}
\end{quote}


\section{类变量与类方法}
\label{\detokenize{python/14_classFunc::doc}}\label{\detokenize{python/14_classFunc:id1}}

\subsection{类变量}
\label{\detokenize{python/14_classFunc:id2}}
定义在类的开始。
\begin{itemize}
\item {} 
类和实例都可以访问类变量

\item {} 
实例只可以访问，不可以修改

\end{itemize}


\subsection{实例变量}
\label{\detokenize{python/14_classFunc:id3}}
类实例（对象）可使用的变量，以 \sphinxcode{\sphinxupquote{self.}} 开头。


\subsection{实例方法}
\label{\detokenize{python/14_classFunc:id4}}
类实例（对象）可调用的函数，形参包括 \sphinxcode{\sphinxupquote{self}} 。


\subsection{静态方法}
\label{\detokenize{python/14_classFunc:id5}}
使用 \sphinxcode{\sphinxupquote{@staticmethod}} 装饰，是定义在类内的普通函数。
\begin{itemize}
\item {} 
静态方法不能访问类变量、实例变量、实例方法

\item {} 
类和实例都可以访问静态方法

\end{itemize}


\subsection{类方法}
\label{\detokenize{python/14_classFunc:id6}}
使用 \sphinxcode{\sphinxupquote{@classmethod}} 装饰，形参包括 \sphinxcode{\sphinxupquote{cls}} 。
\begin{itemize}
\item {} 
类方法可以访问和修改类变量，不能访问实例变量、实例方法

\item {} 
类和实例都可以访问类方法

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{:}
  \PYG{n}{var} \PYG{o}{=} \PYG{l+m+mi}{100}        \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 类变量}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{0}  \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 实例变量}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}b} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 实例变量}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2}   \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 实例变量}

  \PYG{k}{def} \PYG{n+nf}{\PYGZus{}foo}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}foo}\PYG{l+s+s2}{\PYGZdq{}}

  \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}foo}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}foo}\PYG{l+s+s2}{\PYGZdq{}}

  \PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}foo}\PYG{p}{(}\PYG{p}{)}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}b:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}b}

  \PYG{n+nd}{@staticmethod}
  \PYG{k}{def} \PYG{n+nf}{static\PYGZus{}func}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{static\PYGZus{}method}\PYG{l+s+s2}{\PYGZdq{}}
      \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}

  \PYG{n+nd}{@classmethod}
  \PYG{k}{def} \PYG{n+nf}{class\PYGZus{}func}\PYG{p}{(}\PYG{n+nb+bp}{cls}\PYG{p}{,} \PYG{n}{num}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{class\PYGZus{}method}\PYG{l+s+s2}{\PYGZdq{}}
      \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{var} \PYG{o}{=} \PYG{n}{num}
      \PYG{k}{print} \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{static\PYGZus{}func}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{obj} \PYG{o}{=} \PYG{n}{A}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{obj}\PYG{o}{.}\PYG{n}{static\PYGZus{}func}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{static\PYGZus{}method}
\PYG{g+go}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{A}\PYG{o}{.}\PYG{n}{class\PYGZus{}func}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{g+go}{class\PYGZus{}method}
\PYG{g+go}{static\PYGZus{}method}
\PYG{g+go}{0}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{A}\PYG{o}{.}\PYG{n}{var}
\PYG{g+go}{200}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/14_classFunc:id7}}\begin{enumerate}
\item {} 
Python-类变量，成员变量，静态变量，类方法，静态方法，实例方法，普通函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/20150705-yilushangyouni-Jacksu/p/6238187.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
一张图了解python 类方法与类变量 类变量与实例变量

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/cgqdtc/article/details/80555319}
\end{quote}


\section{内存管理}
\label{\detokenize{python/15_memManage::doc}}\label{\detokenize{python/15_memManage:id1}}

\subsection{变量与对象}
\label{\detokenize{python/15_memManage:id2}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{15_varRef}.png}\hspace*{\fill}}

（图片来源：\sphinxurl{https://www.cnblogs.com/geaozhang/p/7111961.html}）
\begin{description}
\item[{变量}] \leavevmode
通过变量指针引用对象，变量指针指向具体对象的内存空间，取对象的值。

\item[{对象}] \leavevmode
类型已知，每个对象都包含一个头部信息（类型标识符和引用计数器）

\end{description}

变量名没有类型，类型属于对象。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{==}\PYG{n}{b}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o+ow}{is} \PYG{n}{b}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{140568052594368}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{140568052594368}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello world}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello world}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{==}\PYG{n}{b}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o+ow}{is} \PYG{n}{b}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{140568052594752}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{140568052594320}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{==}\PYG{n}{b}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o+ow}{is} \PYG{n}{b}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Python缓存了整数和短字符串，因此每个对象在内存中只存有一份，赋值语句只是创造新的引用，而不是对象。

Python没有缓存长字符串、列表及其他对象，可以有多个相同的对象，赋值语句创建出新的对象。
\end{sphinxadmonition}


\subsubsection{变量的改变}
\label{\detokenize{python/15_memManage:id3}}\begin{description}
\item[{不可变对象}] \leavevmode
赋值、加减乘除这些操作实际上导致变量指向的对象发生了改变（已经不是指向原来的那个对象了），并不是通过这个变量来改变它指向的对象的值。

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{21856416}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{21856440}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{21856224}
\end{sphinxVerbatim}
\begin{description}
\item[{可变对象}] \leavevmode
对于list、dict对象，此时变量的指向没有改变。

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{140568052448936}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{140568052448936}
\end{sphinxVerbatim}


\subsection{引用计数}
\label{\detokenize{python/15_memManage:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sys} \PYG{k}{import} \PYG{n}{getrefcount}
\end{sphinxVerbatim}

使用 \sphinxcode{\sphinxupquote{sys}} 包中的 \sphinxcode{\sphinxupquote{getrefcount()}} ，来查看某个对象的引用计数。
需要注意的是，当使用某个引用作为参数，传递给 \sphinxcode{\sphinxupquote{getrefcount()}} 时，参数实际上创建了一个临时的引用。
因此， \sphinxcode{\sphinxupquote{getrefcount()}} 所得到的结果，会比期望的多 1。


\subsubsection{普通引用}
\label{\detokenize{python/15_memManage:id5}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{b}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{2}


\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{2418}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{2419}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{m} \PYG{o}{=} \PYG{n}{n}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{2420}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{n}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{2419}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{n} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{2420}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{2419}
\end{sphinxVerbatim}


\subsubsection{容器对象}
\label{\detokenize{python/15_memManage:id6}}
Python的容器对象(container)，比如列表、元组、字典等，可以包含多个对象。\sphinxstylestrong{容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{n}{a}\PYG{p}{,} \PYG{n}{a}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{4}
\end{sphinxVerbatim}


\subsubsection{循环引用}
\label{\detokenize{python/15_memManage:id7}}
只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字、字符串这类简单类型不会出现循环引用。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getrefcount}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{9}
\end{sphinxVerbatim}


\subsection{垃圾回收}
\label{\detokenize{python/15_memManage:id8}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{gc}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{gc}\PYG{o}{.}\PYG{n}{get\PYGZus{}threshold}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{(700, 10, 10)}
\PYG{g+go}{\PYGZsh{}\PYGZsh{} 700 是垃圾回收启动的阈值，10 是与分代回收相关的阈值}
\end{sphinxVerbatim}

当Python的某个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。
频繁的垃圾回收（garbage collection），将大大降低Python的工作效率。
如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。

当Python运行时，会记录其中分配对象（object allocation）和取消分配对象（object deallocation）的次数。
当两者的差值高于某个阈值时，垃圾回收才会启动，清除那些引用计数为0的对象。


\subsubsection{垃圾检查}
\label{\detokenize{python/15_memManage:id9}}
\sphinxcode{\sphinxupquote{gc.get\_count()}} 获取一个三元组，如 \sphinxcode{\sphinxupquote{(488, 3, 0)}} 。
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{488}} 是指距离上一次0代垃圾检查，Python分配内存的数目减去释放内存的数目。

\item {} 
\sphinxcode{\sphinxupquote{3}} 是指距离上一次1代垃圾检查，0代垃圾检查的次数。

\item {} 
\sphinxcode{\sphinxupquote{0}} 是指距离上一次2代垃圾检查，1代垃圾检查的次数。

\end{itemize}


\subsubsection{分代回收}
\label{\detokenize{python/15_memManage:id10}}
Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。
垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。
当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。

\sphinxcode{\sphinxupquote{(700, 10, 10)}} 表明：每10次0代垃圾回收，会配合1次1代的垃圾回收；每10次1代的垃圾回收，才会有1次的2代垃圾回收。


\subsubsection{标记-清除}
\label{\detokenize{python/15_memManage:id11}}
Python采用了“标记-清除”(Mark and Sweep)算法，解决容器对象可能产生的循环引用问题。
\begin{itemize}
\item {} 
标记阶段：遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达；

\item {} 
清除阶段：再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{python/15_memManage:id12}}\begin{enumerate}
\item {} 
Python内存管理机制

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/geaozhang/p/7111961.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Python的内存管理

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/vamei/p/3232088.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Python垃圾回收机制详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/Xjng/p/5128269.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
聊聊Python内存管理

\end{enumerate}
\begin{quote}

\sphinxurl{https://andrewpqc.github.io/2018/10/08/python-memory-management/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
{[}Python{]}内存管理

\end{enumerate}
\begin{quote}

\sphinxurl{https://chenrudan.github.io/blog/2016/04/23/pythonmemorycontrol.html}
\end{quote}


\section{\_\_new\_\_ 和 \_\_init\_\_}
\label{\detokenize{python/16_newInit::doc}}\label{\detokenize{python/16_newInit:new-init}}

\subsection{老式类与新式类}
\label{\detokenize{python/16_newInit:id1}}
Python 2.x 中类的定义分为新式定义和老式定义两种。
老式类定义时默认是继承自 \sphinxcode{\sphinxupquote{type}} ，而新式类在定义时显示地继承 \sphinxcode{\sphinxupquote{object}} 类。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 老式类}
  \PYG{k}{pass}

\PYG{k}{class} \PYG{n+nc}{B}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 新式类}
  \PYG{k}{pass}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{A}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}bases\PYGZus{}\PYGZus{}}
\PYG{g+go}{()}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{dir}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}module\PYGZus{}\PYGZus{}\PYGZsq{}]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{B}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}bases\PYGZus{}\PYGZus{}}
\PYG{g+go}{(\PYGZlt{}type \PYGZsq{}object\PYGZsq{}\PYGZgt{},)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{dir}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}\PYGZus{}\PYGZus{}class\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}delattr\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}dict\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}format\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}getattribute\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}hash\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}module\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}reduce\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}reduce\PYGZus{}ex\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}setattr\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}sizeof\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}subclasshook\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}weakref\PYGZus{}\PYGZus{}\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{B}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}class\PYGZus{}\PYGZus{}}
\PYG{g+go}{\PYGZlt{}type \PYGZsq{}type\PYGZsq{}\PYGZgt{}}
\end{sphinxVerbatim}

Python 3.x中没有新式类和老式类之分，它们都继承自 \sphinxcode{\sphinxupquote{object}} 类，因此可以不用显示地指定其基类。


\subsection{老式类}
\label{\detokenize{python/16_newInit:id2}}
老式类中其实并没有 \sphinxcode{\sphinxupquote{\_\_new\_\_}} 方法，因为 \sphinxcode{\sphinxupquote{\_\_init\_\_}} 就是它的构造方法（函数）。即使重写 \sphinxcode{\sphinxupquote{\_\_new\_\_}} 方法，也永远不会执行。

\sphinxcode{\sphinxupquote{\_\_init\_\_}} 只能返回 \sphinxcode{\sphinxupquote{None}}。


\subsection{新式类}
\label{\detokenize{python/16_newInit:id3}}

\subsubsection{功能}
\label{\detokenize{python/16_newInit:id4}}
新式类中，\sphinxcode{\sphinxupquote{\_\_new\_\_}} （构造函数）单独地 \sphinxstylestrong{创建} 一个对象，而 \sphinxcode{\sphinxupquote{\_\_init\_\_}} （初始化函数）负责 \sphinxstylestrong{初始化} 这个对象。
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\_\_new\_\_}} 至少要有一个参数 \sphinxcode{\sphinxupquote{cls}}，代表要实例化的类，此参数在实例化时由Python解释器自动提供。

\item {} 
\sphinxcode{\sphinxupquote{\_\_init\_\_}} 有一个参数 \sphinxcode{\sphinxupquote{self}}，就是 \sphinxcode{\sphinxupquote{\_\_new\_\_}} 返回的实例，\sphinxcode{\sphinxupquote{\_\_init\_\_}} 在 \sphinxcode{\sphinxupquote{\_\_new\_\_}} 的基础上可以完成一些其它初始化的动作，\sphinxcode{\sphinxupquote{\_\_init\_\_}} 不需要返回值（或者说返回 \sphinxcode{\sphinxupquote{None}} ）。

\end{itemize}


\subsubsection{返回值}
\label{\detokenize{python/16_newInit:id5}}
\sphinxcode{\sphinxupquote{\_\_init\_\_}} 只能返回  \sphinxcode{\sphinxupquote{None}}。

\sphinxcode{\sphinxupquote{\_\_new\_\_}} 返回创建的实例对象并传递给 \sphinxcode{\sphinxupquote{\_\_init\_\_}} 的 \sphinxcode{\sphinxupquote{self}} 参数。如果 \sphinxcode{\sphinxupquote{\_\_new\_\_}} 没有返回值，或者没有正确返回 \sphinxstylestrong{当前类} \sphinxcode{\sphinxupquote{cls}} 的实例，则 \sphinxcode{\sphinxupquote{\_\_init\_\_}} 不会被调用。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}

  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{cls}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A.\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{} called}\PYG{l+s+s2}{\PYGZdq{}}
      \PYG{k}{print} \PYG{n+nb+bp}{cls}
      \PYG{k}{return} \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n+nb+bp}{cls}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{cls}\PYG{p}{)}

  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A.\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{} called}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{A}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{A.\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{} called}
\PYG{g+go}{\PYGZlt{}class \PYGZsq{}\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}.A\PYGZsq{}\PYGZgt{} \PYGZsh{}\PYGZsh{} cls}
\PYG{g+go}{A.\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{} called}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}class\PYGZus{}\PYGZus{}}     \PYG{c+c1}{\PYGZsh{}\PYGZsh{} type(a)}
\PYG{g+go}{\PYGZlt{}class \PYGZsq{}\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}.A\PYGZsq{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{A}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}class\PYGZus{}\PYGZus{}}
\PYG{g+go}{\PYGZlt{}type \PYGZsq{}type\PYGZsq{}\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{\_\_new\_\_}} 返回父类的对象：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{pass}

\PYG{k}{class} \PYG{n+nc}{B}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{cls}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B.\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{} called}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{A}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 或者写为： return super(B,cls).\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}(A)}

  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 不会被调用}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B.\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{} called}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{B}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{B.\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{} called}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}class \PYGZsq{}\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}.A\PYGZsq{}\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{\_\_new\_\_ 实现单例}
\label{\detokenize{python/16_newInit:new}}
单例（singleton）：类只有一个对象。\sphinxcode{\sphinxupquote{None}} 就是一个单例，所有的变量只要是 \sphinxcode{\sphinxupquote{None}} ，它一定和 \sphinxcode{\sphinxupquote{None}} 指向同一个内存地址。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Singleton}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{\PYGZus{}instance} \PYG{o}{=} \PYG{n+nb+bp}{None}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{cls}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{if} \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{\PYGZus{}instance} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
          \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{\PYGZus{}instance} \PYG{o}{=} \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{Singleton}\PYG{p}{,} \PYG{n+nb+bp}{cls}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{cls}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}

      \PYG{k}{return} \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{\PYGZus{}instance}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{n}{Singleton}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{s1}\PYG{p}{)}
\PYG{g+go}{317973448}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{Singleton}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{s2}\PYG{p}{)}
\PYG{g+go}{317973448}
\end{sphinxVerbatim}


\subsection{附：\_\_repr\_\_ 和 \_\_str\_\_}
\label{\detokenize{python/16_newInit:repr-str}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Base}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fong}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{name}

\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{(}\PYG{n}{Base}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Class A(}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name}

\PYG{k}{class} \PYG{n+nc}{B}\PYG{p}{(}\PYG{n}{Base}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Class B(}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{A}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{Class A(fong)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{Class A(fong)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{B}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}
\PYG{g+go}{\PYGZlt{}B object at 0x0000000012B7FB70\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{b}
\PYG{g+go}{Class B(fong)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{python/16_newInit:id6}}\begin{enumerate}
\item {} 
深入理解Python中的 \_\_new\_\_ 和 \_\_init\_\_

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/luoweifu/article/details/82732313}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
详解Python中的 \_\_init\_\_ 和 \_\_new\_\_（静态方法）

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/nyist-xsk/p/8286941.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Python面试之理解 \_\_new\_\_ 和 \_\_init\_\_ 的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://juejin.im/post/5add4446f265da0b8d4186af}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Python中\_\_repr\_\_和\_\_str\_\_区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/luckytanggu/article/details/53649156}
\end{quote}


\section{pip}
\label{\detokenize{python/17_pip:pip}}\label{\detokenize{python/17_pip::doc}}
\sphinxcode{\sphinxupquote{pip}} 是 python 的包管理工具。


\subsection{基本指令}
\label{\detokenize{python/17_pip:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Commands}\PYG{p}{:}
\PYG{n}{install}                     \PYG{n}{Install} \PYG{n}{packages}\PYG{o}{.}
\PYG{n}{download}                    \PYG{n}{Download} \PYG{n}{packages}\PYG{o}{.}
\PYG{n}{uninstall}                   \PYG{n}{Uninstall} \PYG{n}{packages}\PYG{o}{.}
\PYG{n}{freeze}                      \PYG{n}{Output} \PYG{n}{installed} \PYG{n}{packages} \PYG{o+ow}{in} \PYG{n}{requirements} \PYG{n+nb}{format}\PYG{o}{.}
\PYG{n+nb}{list}                        \PYG{n}{List} \PYG{n}{installed} \PYG{n}{packages}\PYG{o}{.}
\PYG{n}{show}                        \PYG{n}{Show} \PYG{n}{information} \PYG{n}{about} \PYG{n}{installed} \PYG{n}{packages}\PYG{o}{.}
\PYG{n}{check}                       \PYG{n}{Verify} \PYG{n}{installed} \PYG{n}{packages} \PYG{n}{have} \PYG{n}{compatible} \PYG{n}{dependencies}\PYG{o}{.}
\PYG{n}{search}                      \PYG{n}{Search} \PYG{n}{PyPI} \PYG{k}{for} \PYG{n}{packages}\PYG{o}{.}
\PYG{n}{wheel}                       \PYG{n}{Build} \PYG{n}{wheels} \PYG{k+kn}{from} \PYG{n+nn}{your} \PYG{n}{requirements}\PYG{o}{.}
\PYG{n+nb}{hash}                        \PYG{n}{Compute} \PYG{n}{hashes} \PYG{n}{of} \PYG{n}{package} \PYG{n}{archives}\PYG{o}{.}
\PYG{n}{completion}                  \PYG{n}{A} \PYG{n}{helper} \PYG{n}{command} \PYG{n}{used} \PYG{k}{for} \PYG{n}{command} \PYG{n}{completion}\PYG{o}{.}
\PYG{n}{help}                        \PYG{n}{Show} \PYG{n}{help} \PYG{k}{for} \PYG{n}{commands}\PYG{o}{.}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
安装

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZlt{}}\PYG{n}{包名}\PYG{o}{\PYGZgt{}}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{requirements}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

requirements.txt 使用 \sphinxcode{\sphinxupquote{== \textgreater{}= \textless{}= \textgreater{} \textless{}}} 来指定版本，不写则默认为最新版本，格式如:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{APScheduler}\PYG{o}{==}\PYG{l+m+mf}{2.1}\PYG{o}{.}\PYG{l+m+mi}{2}
\PYG{n}{Django}\PYG{o}{==}\PYG{l+m+mf}{1.5}\PYG{o}{.}\PYG{l+m+mi}{4}
\PYG{n}{MySQL}\PYG{o}{\PYGZhy{}}\PYG{n}{Connector}\PYG{o}{\PYGZhy{}}\PYG{n}{Python}\PYG{o}{==}\PYG{l+m+mf}{2.0}\PYG{o}{.}\PYG{l+m+mi}{1}
\PYG{n}{MySQL}\PYG{o}{\PYGZhy{}}\PYG{n}{python}\PYG{o}{==}\PYG{l+m+mf}{1.2}\PYG{o}{.}\PYG{l+m+mi}{3}
\PYG{n}{PIL}\PYG{o}{==}\PYG{l+m+mf}{1.1}\PYG{o}{.}\PYG{l+m+mi}{7}
\PYG{n}{South}\PYG{o}{==}\PYG{l+m+mf}{1.0}\PYG{o}{.}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\item {} 
卸载

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{uninstall} \PYG{o}{\PYGZlt{}}\PYG{n}{包名}\PYG{o}{\PYGZgt{}}
\PYG{n}{pip} \PYG{n}{uninstall} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{requirements}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

\item {} 
升级包

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{U} \PYG{o}{\PYGZlt{}}\PYG{n}{包名}\PYG{o}{\PYGZgt{}}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZlt{}}\PYG{n}{包名}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{upgrade}
\end{sphinxVerbatim}

\item {} 
升级 pip

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{U} \PYG{n}{pip}
\PYG{n}{python} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{upgrade} \PYG{n}{pip}
\end{sphinxVerbatim}

\item {} 
freeze：查看已经安装的包及版本信息

\item {} 
list：列出已安装的包

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n+nb}{list} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 查询可升级的包}
\end{sphinxVerbatim}

\item {} 
search：在 PyPI 查询包

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{search} \PYG{o}{\PYGZlt{}}\PYG{n}{包名}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
show：显示已安装的包的信息

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{show} \PYG{o}{\PYGZlt{}}\PYG{n}{包名}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
如果不能直接使用 pip 命令，可能是因为安装目录不在系统的 PATH 中，此时可以执行:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{pip} \PYG{o}{\PYGZlt{}}\PYG{n}{pip} \PYG{n}{arguments}\PYG{o}{\PYGZgt{}}
\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{pip} \PYG{o}{\PYGZlt{}}\PYG{n}{pip} \PYG{n}{arguments}\PYG{o}{\PYGZgt{}} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} Windows}
\end{sphinxVerbatim}

使用清华源加速安装:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZlt{}}\PYG{n}{包名}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{pypi}\PYG{o}{.}\PYG{n}{tuna}\PYG{o}{.}\PYG{n}{tsinghua}\PYG{o}{.}\PYG{n}{edu}\PYG{o}{.}\PYG{n}{cn}\PYG{o}{/}\PYG{n}{simple}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{参考资料}
\label{\detokenize{python/17_pip:id2}}\begin{enumerate}
\item {} 
Python pip 常用命令

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/BlueSkyyj/p/8268621.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
User Guide

\end{enumerate}
\begin{quote}

\sphinxurl{https://pip.pypa.io/en/stable/user\_guide/}
\end{quote}


\chapter{Linux/Shell}
\label{\detokenize{linux/index:linux-shell}}\label{\detokenize{linux/index::doc}}

\section{基本命令}
\label{\detokenize{linux/01_basic::doc}}\label{\detokenize{linux/01_basic:id1}}

\subsection{文件和目录}
\label{\detokenize{linux/01_basic:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} ..
\PYG{n+nb}{pwd}
ls \PYGZhy{}a \PYGZhy{}F \PYGZhy{}R \PYGZhy{}l

cp \PYG{o}{[}\PYGZhy{}i\PYG{o}{]} src dst
cp \PYGZhy{}R

mv src des
rm \PYGZhy{}i \PYGZhy{}r \PYGZhy{}f folder

touch new \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 创建新文件或修改文件时间属性}

mkdir new
rmdir new

file my\PYGZus{}file \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 查看文件类型}

cat \PYGZhy{}n log.txt
tail log.txt
head \PYGZhy{}5 log.txt

wc file \PYGZhy{}c \PYGZhy{}w \PYGZhy{}l
\end{sphinxVerbatim}


\subsection{磁盘空间}
\label{\detokenize{linux/01_basic:id3}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
df \PYGZhy{}h
du \PYG{o}{[}\PYGZhy{}s\PYG{o}{]} \PYGZhy{}h
\end{sphinxVerbatim}


\subsection{处理数据文件}
\label{\detokenize{linux/01_basic:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sort \PYG{o}{[}\PYGZhy{}n\PYG{o}{]} log.txt \PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}n : 行号}

grep \PYG{o}{[}\PYGZhy{}n\PYG{o}{]} \PYG{o}{[}\PYGZhy{}c\PYG{o}{]} t file \PYG{c+c1}{\PYGZsh{}\PYGZsh{} find *t* in file}

gzip my*
gunzip myfile.gz

tar \PYGZhy{}cvf test.tar test/
tar \PYGZhy{}xvf test.tar
tar \PYGZhy{}xzvf test.tgz
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{linux/01_basic:id5}}\begin{enumerate}
\item {} 
《Linux命令行与shell脚本编程大全》

\item {} 
每天一个linux命令目录

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/peida/archive/2012/12/05/2803591.html}
\end{quote}


\section{更多指令}
\label{\detokenize{linux/02_more::doc}}\label{\detokenize{linux/02_more:id1}}

\subsection{Debian系PMS}
\label{\detokenize{linux/02_more:debianpms}}
\sphinxstylestrong{PMS} : Package Management System，包管理系统。主要介绍：
\begin{itemize}
\item {} 
\sphinxstylestrong{dpkg}

\item {} 
\sphinxstylestrong{apt-get}

\item {} 
\sphinxstylestrong{apt-cache}

\item {} 
\sphinxstylestrong{aptitude}

\end{itemize}


\subsubsection{dpkg}
\label{\detokenize{linux/02_more:dpkg}}\begin{itemize}
\item {} 
dpkg -L package\_name：列出软件包所安装的所有文件

\item {} 
dpkg -S absolute\_file\_name：查找特定的某个文件属于哪个软件包（使用绝对路径）

\end{itemize}


\subsubsection{apt-get}
\label{\detokenize{linux/02_more:apt-get}}\begin{itemize}
\item {} 
apt-get install package\_name：安装一个新软件包

\item {} 
apt-get remove package\_name：卸载一个已安装的软件包（保留配置文件）

\item {} 
apt-get \textendash{}purge remove package\_name：卸载一个已安装的软件包（删除配置文件）

\item {} 
apt-get clean：删除安装的软件的备份，不过不影响软件的使用。

\item {} 
apt-get update：更新 \sphinxstylestrong{软件包列表}

\item {} 
apt-get upgrade：升级所有已安装的 \sphinxstylestrong{软件包} （upgrade之前先update，确保升级的是最新版本）

\end{itemize}


\subsubsection{apt-cache}
\label{\detokenize{linux/02_more:apt-cache}}\begin{itemize}
\item {} 
apt-cache showpkg package\_name：显示软件包信息

\item {} 
apt-cache policy package\_name：显示软件包是否已经安装、版本号等

\end{itemize}


\subsubsection{aptitude}
\label{\detokenize{linux/02_more:aptitude}}\begin{itemize}
\item {} 
aptitude install package\_name：安装软件包

\item {} 
aptitude remove package\_name：删除软件包

\item {} 
aptitude purge package\_name：删除软件包及其配置文件

\item {} 
aptitude search package\_name：搜索软件包

\item {} 
aptitude show package\_name：显示软件包的详细信息

\item {} 
aptitude clean：删除下载的软件包文件

\item {} 
aptitude autoclean：仅删除过期的软件包文件

\item {} 
aptitude update：更新可用的软件包列表

\item {} 
aptitude upgrade：升级可用的软件包

\end{itemize}


\subsection{tee}
\label{\detokenize{linux/02_more:tee}}
读取标准输入的数据，并将其内容输出成文件。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
tee \PYG{o}{[}\PYGZhy{}ai\PYG{o}{]} \PYG{o}{[}\PYGZhy{}\PYGZhy{}help\PYG{o}{]} \PYG{o}{[}\PYGZhy{}\PYGZhy{}version\PYG{o}{]} \PYG{o}{[}file ...\PYG{o}{]}
\end{sphinxVerbatim}
\begin{description}
\item[{参数}] \leavevmode\begin{itemize}
\item {} 
-a或- -append：追加到既有文件

\item {} 
-i或- -ignore-interrupts：忽略中断信号

\item {} 
- -help：帮助

\item {} 
- -version：版本信息

\end{itemize}

\end{description}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 将用户输入的数据同时保存到 out1 out2}
\PYGZdl{} tee out1 out2
a b c d e f g \PYG{c+c1}{\PYGZsh{} 输入}
a b c d e f g \PYG{c+c1}{\PYGZsh{} 反馈}
\PYGZca{}C            \PYG{c+c1}{\PYGZsh{} 结束输入}
\PYGZdl{} cat out1
a b c d e f g
\PYGZdl{} cat out2
a b c d e f g

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 管道：将屏幕的输出保存到文件}
\PYGZdl{} \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}hello world\PYGZdq{}} \PYG{p}{\textbar{}} tee out
hello world
\PYGZdl{} cat out
hello world

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 把python程序打印到屏幕的内容保存到文件}
\PYGZdl{} python test.py \PYG{p}{\textbar{}} tee out
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{查找}
\label{\detokenize{linux/02_more:id2}}
\sphinxstylestrong{which}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
which \PYG{o}{[}可执行文件...\PYG{o}{]}
\end{sphinxVerbatim}

在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。

\sphinxstylestrong{whereis}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
whereis \PYG{o}{[}\PYGZhy{}bmsu\PYG{o}{]} \PYG{o}{[}\PYGZhy{}BMS \PYGZhy{}f 目录...\PYG{o}{]} \PYG{o}{[}文件...\PYG{o}{]}
\end{sphinxVerbatim}

只能用于程序名的搜索，而且只搜索二进制文件（-b）、帮助说明文件（-m）和源代码文件（-s）。如果省略参数，则返回所有信息。
参数：
\begin{itemize}
\item {} 
-b：定位可执行文件。

\item {} 
-m：定位帮助文件。

\item {} 
-s：定位源代码文件。

\item {} 
-u：搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。

\item {} 
-B：指定搜索可执行文件的路径。

\item {} 
-M：指定搜索帮助文件的路径。

\item {} 
-S：指定搜索源代码文件的路径。

\end{itemize}

\sphinxstylestrong{locate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
locate \PYG{o}{[}\PYGZhy{}d\PYG{o}{]} \PYG{o}{[}\PYGZhy{}\PYGZhy{}help\PYG{o}{]} \PYG{o}{[}\PYGZhy{}\PYGZhy{}version\PYG{o}{]} \PYG{o}{[}范本样式...\PYG{o}{]}
\end{sphinxVerbatim}

配合数据库查找文件位置。参数：
\begin{itemize}
\item {} 
-d：配置locate指令使用的数据库。locate指令预设的数据库位于/var/lib/slocate目录里，文档名为slocate.db。

\end{itemize}

\sphinxstylestrong{find}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
find pathname \PYGZhy{}options \PYG{o}{[}\PYGZhy{}print \PYGZhy{}exec \PYGZhy{}ok ...\PYG{o}{]}
\end{sphinxVerbatim}

find是在硬盘文件树查找。参数：
\begin{itemize}
\item {} 
pathname：查找的目录。例如用 . 来表示当前目录，用 / 来表示系统根目录。

\item {} 
-name：按照文件名查找文件。

\item {} 
-print：将匹配的文件输出到标准输出。也可以使用 \sphinxcode{\sphinxupquote{\textgreater{}}} 或  \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}}} （追加）写到文件。

\item {} 
-exec：对匹配的文件执行该参数所给出的shell命令。相应命令的形式为 \sphinxcode{\sphinxupquote{'command' \{\} \textbackslash{};}} ，注意 \sphinxcode{\sphinxupquote{\{\}}} 和 \sphinxcode{\sphinxupquote{\textbackslash{};}} 之间的空格。

\item {} 
-ok：和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。

\end{itemize}

\(\color{darkgreen}{Example}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} which python
/usr/bin/python

\PYGZdl{} whereis \PYGZhy{}s \PYGZhy{}S /usr/lib \PYGZhy{}f python
python: /usr/lib/python3.5 /usr/lib/python2.7

\PYGZdl{} locate /usr/bin/pytho \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 以 pytho 开头的文件}
/usr/bin/python
/usr/bin/python\PYGZhy{}config
/usr/bin/python2
...

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 查找 /var/log 中扩展名为 .tmp 的文件，并在删除之前询问用户 （y/n）}
\PYGZdl{} find /var/log \PYGZhy{}name \PYG{l+s+s2}{\PYGZdq{}*.tmp\PYGZdq{}} \PYGZhy{}ok rm \PYG{o}{\PYGZob{}}\PYG{o}{\PYGZcb{}} \PYG{l+s+se}{\PYGZbs{};}
\PYGZlt{} rm ... ./t.tmp \PYGZgt{} ? y
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{参考资料}
\label{\detokenize{linux/02_more:id3}}\begin{enumerate}
\item {} 
runoob.com

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.runoob.com/linux/linux-comm-tee.html}

\sphinxurl{https://www.runoob.com/linux/linux-comm-find.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
每天一个linux命令目录

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/peida/archive/2012/12/05/2803591.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
aptitude和apt-get的区别和联系【转，有添加和修改】

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/u010670794/article/details/42520209}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
apt-get update与upgrade的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/42a1850bdcf6}
\end{quote}


\section{权限管理}
\label{\detokenize{linux/03_authority::doc}}\label{\detokenize{linux/03_authority:id1}}

\subsection{文件描述符}
\label{\detokenize{linux/03_authority:id2}}
\sphinxcode{\sphinxupquote{ls -l}} 命令输出的第一个字段就是描述文件和目录权限的编码。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{drwxrwxr}\PYG{o}{\PYGZhy{}}\PYG{n}{x} \PYG{l+m+mi}{13} \PYG{n}{fong} \PYG{n}{fong} \PYG{l+m+mi}{4096} \PYG{l+m+mi}{5}\PYG{n}{月}   \PYG{l+m+mi}{7} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{33} \PYG{n}{source}\PYG{o}{/}
\end{sphinxVerbatim}

该字段的第一个字符代表对象的类型：
\begin{itemize}
\item {} 
-：文件

\item {} 
d：目录

\item {} 
l：链接

\item {} 
c：字符型设备

\item {} 
b：块设备

\item {} 
n：网络设备

\end{itemize}

之后是3组三字符的编码，每一组定义了3种访问权限（若没有某种权限，使用 - 代替）：
\begin{itemize}
\item {} 
r：可读

\item {} 
w：可写

\item {} 
x：可执行

\end{itemize}

\sphinxcode{\sphinxupquote{ls -F}} 能够在可执行文件的文件名后加一个 *，目录后方加 /。

3组权限对应对象的3个安全等级：
\begin{itemize}
\item {} 
对象的属主（登录名fong）

\item {} 
对象的属组（组名fong）

\item {} 
系统其它用户

\end{itemize}


\subsection{默认文件权限}
\label{\detokenize{linux/03_authority:id3}}
\sphinxcode{\sphinxupquote{umask}} 查看默认文件权限，

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} \PYG{n+nb}{umask}
\PYG{l+m}{0002}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 临时修改默认权限 （若要长期生效，把 umask 0022 写进 \PYGZti{}/.bashrc 并 source）}
\PYGZdl{} \PYG{n+nb}{umask} \PYG{l+m}{0022}
\PYGZdl{} \PYG{n+nb}{umask}
\PYG{l+m}{0022}
\end{sphinxVerbatim}

第1位代表粘着位（sticky bit），后3位表示文件或目录对应的umask八进制值（对应3组权限）。


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Linux文件权限码}\label{\detokenize{linux/03_authority:id6}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
权限
&\sphinxstyletheadfamily 
二进制值
&\sphinxstyletheadfamily 
八进制值
\\
\hline
- - -
&
000
&
0
\\
\hline
- - x
&
001
&
1
\\
\hline
- w -
&
010
&
2
\\
\hline
- w x
&
011
&
3
\\
\hline
r - -
&
100
&
4
\\
\hline
r - x
&
101
&
5
\\
\hline
r w -
&
110
&
6
\\
\hline
r w x
&
111
&
7
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

umask值只是 \sphinxstylestrong{掩码} ，屏蔽不想授予的权限，即：真正的权限是用 \sphinxstylestrong{全权限} 值减去umask值。
文件的全权限值是 \sphinxstylestrong{666} ，目录的全权限值是 \sphinxstylestrong{777} 。当umask=0022，文件默认权限是644，目录默认权限是755。


\subsection{改变权限}
\label{\detokenize{linux/03_authority:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chmod} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{cfvR}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{help}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{version}\PYG{p}{]} \PYG{p}{[}\PYG{n}{mode}\PYG{p}{]} \PYG{p}{[}\PYG{n}{file}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
\end{sphinxVerbatim}

参数：
\begin{itemize}
\item {} 
c：若该文件权限确实已经更改，才打印更改动作

\item {} 
f：若该文件权限无法被更改，也不打印错误讯息

\item {} 
v：打印权限变更的详细动作

\item {} 
R：对目前目录下的所有文件与子目录进行相同的权限变更（即以递回的方式逐个变更）

\end{itemize}

mode:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{ugoa}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{p}{]} \PYG{p}{[}\PYG{n}{rwxX}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
u 表示对象的属主，g 表示对象的属组成员，o 表示系统其它用户，a 表示所有用户。

\item {} 
+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。

\item {} 
r 表示可读，w 表示可写，x 表示可执行。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} mkdir \PYG{n+nb}{test}
\PYGZdl{} ls \PYGZhy{}l
drwxr\PYGZhy{}xr\PYGZhy{}x  \PYG{l+m}{2} fong fong \PYG{l+m}{4096} \PYG{l+m}{5}月   \PYG{l+m}{7} \PYG{l+m}{13}:34 test/
\PYGZdl{} chmod \PYGZhy{}v \PYG{l+m}{777} \PYG{n+nb}{test}
mode of \PYG{l+s+s1}{\PYGZsq{}test\PYGZsq{}} changed from \PYG{l+m}{0755} \PYG{o}{(}rwxr\PYGZhy{}xr\PYGZhy{}x\PYG{o}{)} to \PYG{l+m}{0777} \PYG{o}{(}rwxrwxrwx\PYG{o}{)}
\PYGZdl{} chmod \PYGZhy{}v a\PYGZhy{}w \PYG{n+nb}{test}
mode of \PYG{l+s+s1}{\PYGZsq{}test\PYGZsq{}} changed from \PYG{l+m}{0777} \PYG{o}{(}rwxrwxrwx\PYG{o}{)} to \PYG{l+m}{0555} \PYG{o}{(}r\PYGZhy{}xr\PYGZhy{}xr\PYGZhy{}x\PYG{o}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{linux/03_authority:id5}}
1.《Linux命令行与shell脚本编程大全》
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Linux chmod命令

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.runoob.com/linux/linux-comm-chmod.html}
\end{quote}


\chapter{Git}
\label{\detokenize{git/index:git}}\label{\detokenize{git/index::doc}}

\section{本地版本库}
\label{\detokenize{git/01_localRep::doc}}\label{\detokenize{git/01_localRep:id1}}
\sphinxstylestrong{Git} 是目前世界上最先进的分布式版本控制系统。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{01_git-operations}.png}\hspace*{\fill}}

（图片来源：\sphinxurl{http://blog.podrezo.com/git-introduction-for-cvssvntfs-users/}）
\begin{itemize}
\item {} 
\sphinxstylestrong{workspace} ：工作区

\item {} 
\sphinxstylestrong{stage} ：暂存区

\item {} 
\sphinxstylestrong{local repository} ：本地版本库

\item {} 
\sphinxstylestrong{remote repository} ：远程仓库

\end{itemize}


\subsection{本地版本库}
\label{\detokenize{git/01_localRep:id2}}

\subsubsection{创建与修改}
\label{\detokenize{git/01_localRep:id3}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git init}} 把当前目录变为Git可管理的仓库（目录下多了子目录.git/，自动创建的第一个分支master，以及指向master的一个指针叫 \sphinxcode{\sphinxupquote{HEAD}} ）。

\item {} 
\sphinxcode{\sphinxupquote{git add my\_file}} 把文件加入暂存区。

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
git add . ：把工作时的 \sphinxstylestrong{所有变化} 提交到暂存区，包括文件内容 \sphinxstylestrong{修改（modified）} 以及 \sphinxstylestrong{新文件（new）} ，但不包括被删除的文件。

git add -u ：git add - -update，仅监控已经被add的文件（即 \sphinxstylestrong{tracked file} ），他会将被修改的文件提交到暂存区。不会提交新文件（untracked file）。

git add -A ：git add - -all，是上面两个功能的合集。
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git commit -m "add my\_file"}}  提交到本地版本库，并写log。

\item {} 
\sphinxcode{\sphinxupquote{git status}} 查看当前仓库的状态（文件是不是被tracked？修改是不是已经commit？… 等）。

\item {} 
\sphinxcode{\sphinxupquote{git diff}} 查看当前状态和最新的commit之间的不同（修改还没有add），命令可以加具体文件名以查看某个文件的修改。

\item {} 
\sphinxcode{\sphinxupquote{git diff \textless{}版本号，如7ed6b16\textgreater{}}} 查看当前状态和之前某次commit之间的不同。

\item {} 
\sphinxcode{\sphinxupquote{git log}} 查看commit记录。

\item {} 
\sphinxcode{\sphinxupquote{git reflog}} 查看之前每次commit之后的分支状态。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} git reflog
41c873a \PYG{o}{(}HEAD \PYGZhy{}\PYGZgt{} master\PYG{o}{)} HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{0}\PYG{o}{\PYGZcb{}}: commit: update b
3e2b7f2 HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{1}\PYG{o}{\PYGZcb{}}: reset: moving to HEAD
3e2b7f2 HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{2}\PYG{o}{\PYGZcb{}}: commit: update out
7ed6b16 HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{3}\PYG{o}{\PYGZcb{}}: reset: moving to HEAD
7ed6b16 HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{4}\PYG{o}{\PYGZcb{}}: commit: add a
\PYG{l+m}{8337301} HEAD@\PYG{o}{\PYGZob{}}\PYG{l+m}{5}\PYG{o}{\PYGZcb{}}: commit \PYG{o}{(}initial\PYG{o}{)}: add readme
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{版本管理}
\label{\detokenize{git/01_localRep:id4}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{01_head}.jpg}\hspace*{\fill}}

（图片来源：\sphinxurl{https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576}）

\sphinxstylestrong{HEAD 指针指向当前版本的master分支。}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git checkout -{-} my\_file}} 如果修改或删除了已经commit的内容，这条指令可以丢弃该操作，一键还原。

\item {} 
\sphinxcode{\sphinxupquote{git reset -{-}hard}} 撤销修改，回到上一次commit之后的状态。

\item {} 
\sphinxcode{\sphinxupquote{git reset -{-}hard \textless{}版本号，如7ed6b16\textgreater{}}} 回到某一次commit之后的状态，同时会删除该次commit之后的commit log。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{git/01_localRep:id5}}\begin{enumerate}
\item {} 
Git和Github简单教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/schaepher/p/5561193.html\#reset}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Git教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.liaoxuefeng.com/wiki/896043488029600}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Git使用教程

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/tugenhua0707/p/4050072.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Git操作详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/bestzhang/p/6903338.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
git add -A 和 git add . 的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/skura23/p/5859243.html}
\end{quote}


\section{远程仓库}
\label{\detokenize{git/02_remoteRep::doc}}\label{\detokenize{git/02_remoteRep:id1}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{01_git-operations}.png}\hspace*{\fill}}

（图片来源：\sphinxurl{http://blog.podrezo.com/git-introduction-for-cvssvntfs-users/}）
\begin{itemize}
\item {} 
\sphinxstylestrong{workspace} ：工作区

\item {} 
\sphinxstylestrong{stage} ：暂存区

\item {} 
\sphinxstylestrong{local repository} ：本地版本库

\item {} 
\sphinxstylestrong{remote repository} ：远程仓库

\end{itemize}


\subsection{远程仓库}
\label{\detokenize{git/02_remoteRep:id2}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git clone \textless{}版本库的网址\textgreater{}}} 从远程主机克隆一个版本库。

\item {} 
\sphinxcode{\sphinxupquote{git remote}} 管理主机名，使用参数 -v，可以参看远程主机的网址。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} git remote \PYGZhy{}v
origin  git@github.com:******/******.git \PYG{o}{(}fetch\PYG{o}{)}
origin  git@github.com:******/******.git \PYG{o}{(}push\PYG{o}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 结果表明：当前只有一台远程主机，叫做 origin 。}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{git fetch \textless{}远程主机名\textgreater{}}} 将某个远程主机的更新，全部取回本地。默认情况下，git fetch取回所有分支（branch）的更新。

\item {} 
\sphinxcode{\sphinxupquote{git fetch \textless{}远程主机名\textgreater{} \textless{}分支名\textgreater{}}} 如果只想取回特定分支的更新，可以指定分支名，比如master。

\item {} 
\sphinxcode{\sphinxupquote{git branch}} -r：查看远程分支，-a：查看所有分支（包括本地分支）。

\item {} 
\sphinxcode{\sphinxupquote{git merge origin/master}} 在本地分支上合并远程分支（origin/master）。

\item {} 
\sphinxcode{\sphinxupquote{git pull \textless{}远程主机名\textgreater{} \textless{}远程分支名\textgreater{}:\textless{}本地分支名\textgreater{}}} 取回远程主机某个分支的更新，再与本地的指定分支合并。比如，取回origin主机的next分支，与本地的master分支合并，需要写成 \sphinxcode{\sphinxupquote{git pull origin next:master}} 。如果远程分支是与当前分支合并，可直接写为 \sphinxcode{\sphinxupquote{git pull origin next}} 。等效于fetch+merge： \sphinxcode{\sphinxupquote{git fetch origin}} ， \sphinxcode{\sphinxupquote{git merge origin/next}} 。

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Git Pull Failed: Your local changes would be overwritten by merge. Commit, stash or revert them.
\begin{itemize}
\item {} 
保留未push的本地代码，并把git服务器上的代码pull到本地（本地刚才修改的代码将会被暂时封存起来）。
\begin{itemize}
\item {} 
git stash

\item {} 
git pull origin master（其中origin master表示git的主分支）

\item {} 
… （一些别的操作，直到结束了对pull到本地的代码的操作。例如，push之后。）

\item {} 
git stash pop

\end{itemize}

\item {} 
完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pull。
\begin{itemize}
\item {} 
git reset - -hard

\item {} 
git pull origin master

\end{itemize}

\end{itemize}
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git push \textless{}远程主机名\textgreater{} \textless{}本地分支名\textgreater{}:\textless{}远程分支名\textgreater{}}} 将本地分支的更新，推送到远程主机。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{git/02_remoteRep:id3}}\begin{enumerate}
\item {} 
Git和Github简单教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/schaepher/p/5561193.html\#reset}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Git教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.liaoxuefeng.com/wiki/896043488029600}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Git使用教程

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/tugenhua0707/p/4050072.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Git操作详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/bestzhang/p/6903338.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Git Pull Failed

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/gymaisyl/article/details/84899191}
\end{quote}


\section{分支管理}
\label{\detokenize{git/03_branch::doc}}\label{\detokenize{git/03_branch:id1}}

\subsection{分支管理}
\label{\detokenize{git/03_branch:id2}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git checkout -b dev}} 创建分支dev，并切换到dev分支（此时可以正常add，commit等）。相当于下面两条指令：
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git branch dev}} 创建分支

\item {} 
\sphinxcode{\sphinxupquote{git checkout dev}} 切换分支

\end{itemize}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
dev分支的仓库已经包含了master分支的内容，但是在master分支下，无法看到dev分支新增或修改的内容。
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{git branch}} 查看当前分支。

\item {} 
\sphinxcode{\sphinxupquote{git merge dev}} 把dev分支的内容合并到当前分支（如，master分支）。

\item {} 
\sphinxcode{\sphinxupquote{git branch -d dev}} （合并之后）删除dev分支。

\end{itemize}

流程如下（图片来源于 \sphinxhref{https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424}{Git教程 - 廖雪峰的官方网站} ）：

\sphinxstylestrong{1.} 初始状态： \sphinxstylestrong{master} 分支。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{03_master}.png}\hspace*{\fill}}

\sphinxstylestrong{2.} 创建并切换到 \sphinxstylestrong{dev} 分支。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{03_create_branch}.png}\hspace*{\fill}}

\sphinxstylestrong{3.} 更新 \sphinxstylestrong{dev} 分支。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{03_commit_branch}.png}\hspace*{\fill}}

\sphinxstylestrong{4.} 合并 \sphinxstylestrong{dev} 分支到 \sphinxstylestrong{master} 分支。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{03_merge_branch}.png}\hspace*{\fill}}

\sphinxstylestrong{5.} 删除 \sphinxstylestrong{dev} 分支。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{03_delete_branch}.png}\hspace*{\fill}}


\subsection{参考资料}
\label{\detokenize{git/03_branch:id3}}\begin{enumerate}
\item {} 
Git和Github简单教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/schaepher/p/5561193.html\#reset}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Git教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.liaoxuefeng.com/wiki/896043488029600}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Git使用教程

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/tugenhua0707/p/4050072.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Git操作详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/bestzhang/p/6903338.html}
\end{quote}


\chapter{机器学习}
\label{\detokenize{machineLearning/index::doc}}\label{\detokenize{machineLearning/index:id1}}

\section{Logistic Regression}
\label{\detokenize{machineLearning/01_lr:logistic-regression}}\label{\detokenize{machineLearning/01_lr::doc}}
模型：
\begin{equation*}
\begin{split}h_\theta(\mathbf{x}) & = & \  g(\theta^\top \mathbf{x}),\\
g(z) & = & \  \frac{1}{1+e^{-z}},\\
g^\prime(z) & = & \  (1-g(z))g(z) \in (0, 0.25].\end{split}
\end{equation*}
对数损失函数（极大似然）：
\begin{equation*}
\begin{split}\mathcal{l}_\theta = -\frac{1}{m} \sum_{i=1}^m y^{(i)} \log h_\theta(\mathbf{x}^{(i)}) + (1 - y^{(i)}) \log(1 - h_\theta(\mathbf{x}^{(i)}))\end{split}
\end{equation*}
虽然使用了sigmoid函数，但该模型仍然是线性分类器，因为即使不经过sigmoid函数也可以得出分类结果（与0比较），sigmoid将其转化为概率。


\subsection{基本假设}
\label{\detokenize{machineLearning/01_lr:id1}}\begin{enumerate}
\item {} 
数据服从伯努利分布 \(y \sim Bernoulli(\phi)\)

\item {} 
样例为正例的概率为 \(\phi=h_\theta(\mathbf{x})\)

\end{enumerate}


\subsection{求解方法}
\label{\detokenize{machineLearning/01_lr:id2}}\begin{description}
\item[{梯度下降}] \leavevmode\begin{itemize}
\item {} 
批梯度下降：全局最优；每次参数更新需要遍历所有样本，计算量大，效率低。

\item {} 
随机梯度下降（SGD）：以高方差频繁更新，能跳到新的、更好的局部最优解；收敛到局部最优的过程更加复杂。

\item {} 
小批量梯度下降：减少了参数更新次数，达到更稳定的收敛结果。

\end{itemize}

\end{description}


\subsection{优缺点}
\label{\detokenize{machineLearning/01_lr:id3}}\begin{description}
\item[{优点}] \leavevmode\begin{itemize}
\item {} 
模型简单，可解释性好，效果不错

\item {} 
训练速度快，资源占用少

\item {} 
直接输出样本的分类概率，便于做阈值划分

\end{itemize}

\item[{缺点}] \leavevmode\begin{itemize}
\item {} 
准确性不高

\item {} 
很难处理数据不平衡问题

\item {} 
只能处理线性问题

\item {} 
逻辑回归本身无法筛选特征

\end{itemize}

\end{description}


\subsection{解析}
\label{\detokenize{machineLearning/01_lr:id4}}\begin{enumerate}
\item {} 
为什么使用极大似然函数作为损失函数？

\end{enumerate}
\begin{itemize}
\item {} 
极大似然：希望最大化每个样本的分类正确概率，样本服从伯努利分布。

\item {} 
将极大似然取对数后就等同于对数损失函数，在LR模型中，这个损失函数使参数更新速度较快：
\begin{equation*}
\begin{split}\theta_j \leftarrow \theta_j + \alpha \times \frac{1}{m} \sum_{i=1}^m (y^{(i)} - h_\theta(\mathbf{x}^{(i)}))\mathbf{x}_j^{(i)}\end{split}
\end{equation*}
只与 \(y^{(i)},\mathbf{x}^{(i)}\) 有关，与 \(h_\theta\) 的梯度无关。

\item {} 
为什么不用平方损失函数（多用于线性回归）？在线性回归中，前提假设是 \(y\) 服从正态分布，即 \(y \sim \mathcal{N}(\mu, \sigma^2)\) 。
另外，如果使用平方损失函数， \(\theta\) 更新与 \(h_\theta\) 的梯度有关，而sigmoid函数的梯度在定义域内小于0.25，导致参数更新慢。

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
训练中如何有很多特征高度相关或将某个特征重复100遍，影响如何？

\end{enumerate}
\begin{quote}

如果损失函数收敛，不影响分类结果（每个特征对应的权重 \(\theta_j\) 变为原来的百分之一）。将相关特征去除，使模型具有更好的解释性，也能加快训练速度。
\end{quote}


\subsection{参考资料}
\label{\detokenize{machineLearning/01_lr:id5}}\begin{enumerate}
\item {} 
逻辑回归的常见面试点总结

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/ModifyRong/p/7739955.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
LR逻辑斯回归分析（优缺点）

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/touch\_dream/article/details/79371462}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
logistic 回归（内附推导）

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/894bda167422}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
周志华《机器学习》Page 57 \textendash{} 60。

\end{enumerate}


\section{支持向量机}
\label{\detokenize{machineLearning/02_svm::doc}}\label{\detokenize{machineLearning/02_svm:id1}}
样本空间中任意点到超平面的距离（几何间隔，geometric margin）为：
\begin{equation*}
\begin{split}r = \frac{|w^{\top} x + b|}{\| w \|}.\end{split}
\end{equation*}
函数间隔（functional margin）：
\begin{equation*}
\begin{split}y(w^{\top} x + b).\end{split}
\end{equation*}
原始问题：
\begin{equation*}
\begin{split}\underset{w,b}{min} & &\  \frac{1}{2} \left \| w \right \|^2 \\
s.t. & &\  y_i(w^{\top} x_i + b) \geqslant 1, i=1,2,...,m\end{split}
\end{equation*}
拉格朗日函数：
\begin{equation*}
\begin{split}L(w,b,\alpha) = \frac{1}{2}w^{\top}w + \sum_{i=1}^m \alpha_i(1 - y_i(w^{\top} x_i + b))\end{split}
\end{equation*}
目标函数：
\begin{equation*}
\begin{split}\underset{w,b}{min}(\underset{\alpha \geqslant 0}{max}L(w,b,\alpha))\end{split}
\end{equation*}
对偶问题：
\begin{equation*}
\begin{split}\underset{\alpha \geqslant 0}{max}(\underset{w,b}{min}L(w,b,\alpha))\end{split}
\end{equation*}
令 \(L\) 对  \(w\) 和  \(b\) 的偏导为 0 得：
\begin{equation*}
\begin{split}w & = &\ \sum_{i=1}^m \alpha_i y_i x_i,\\
0 & = &\ \sum_{i=1}^m \alpha_i y_i.\end{split}
\end{equation*}
对偶问题变成：
\begin{equation*}
\begin{split}\underset{\alpha \geqslant 0}{max} &  &\  \sum_{i=1}^m\alpha_i - \frac{1}{2} \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j x_i^{\top} x_j,\\
s.t.  &  &\  \sum_{i=1}^m \alpha_i y_i = 0,\\
      &  &\  \alpha \geqslant 0, \ i=1,2,...,m.\end{split}
\end{equation*}
KKT条件：
\begin{equation*}
\begin{split}y_i(w^{\top} x_i + b) \geqslant 1, \\
\sum_{i=1}^m \alpha_i y_i = 0,\\
\alpha_i (1 - y_i(w^{\top} x_i + b)) = 0.\end{split}
\end{equation*}

\subsection{核函数}
\label{\detokenize{machineLearning/02_svm:id2}}
核函数 \(\mathcal{K}\)
\begin{itemize}
\item {} 
对称半正定。( \(\mathcal{K} \geqslant 0: \forall z,\  z^{\top}\mathcal{K}z \geqslant 0.\) )

\item {} 
主要使用线性核，高斯核（RBF）。

\item {} 
当特征维度高且样本少，不宜使用高斯核，容易过拟合。

\item {} 
当特征维度低，且样本够多，考虑使用高斯核。首先需要特征缩放（归一化）。若 \(\sigma\) 过大，导致特征间差异变小，欠拟合。

\end{itemize}


\subsection{多分类}
\label{\detokenize{machineLearning/02_svm:id3}}\begin{enumerate}
\item {} 
一对一（ \(O(N^2)\) ）

\item {} 
一对多（ \(O(N)\) ）

\item {} 
使用多分类loss

\end{enumerate}


\subsection{SVM库}
\label{\detokenize{machineLearning/02_svm:svm}}
sklearn, libsvm


\subsection{优缺点}
\label{\detokenize{machineLearning/02_svm:id4}}\begin{description}
\item[{优点}] \leavevmode\begin{itemize}
\item {} 
基于结构风险最小化，泛化能力强（自带正则化， \(\left \| w \right \|^2\) ）。

\item {} 
它是凸优化问题，可得到全局最优。

\item {} 
SVM在小样本训练集上可得到比其他方法好的结果。

\item {} 
利用核函数，可借助线性可分问题的求解方法，直接求解对应高维空间的问题。

\end{itemize}

\item[{缺点}] \leavevmode\begin{itemize}
\item {} 
SVM对缺失特征敏感。

\item {} 
如何确定核函数？

\item {} 
求解问题的二次规划，耗时耗存储。

\end{itemize}

\end{description}


\subsection{解析}
\label{\detokenize{machineLearning/02_svm:id5}}\begin{enumerate}
\item {} 
为什么要间隔最大化？

\end{enumerate}
\begin{quote}

最优超平面，解唯一，更加鲁棒。
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
为什么转化为对偶问题？

\end{enumerate}
\begin{itemize}
\item {} 
便于求解（交换 \(\alpha\) 和 \((w,b)\) 位置之后，可直接对 \((w,b)\) 求导）。

\item {} 
解的过程可以引入核函数。

\end{itemize}


\subsection{SVM与LR的异同}
\label{\detokenize{machineLearning/02_svm:svmlr}}
相同点：
\begin{itemize}
\item {} 
都是分类算法。

\item {} 
不考虑核函数，分类面都是线性。

\item {} 
都是监督学习算法。

\item {} 
都是判别模型。（判别模型：KNN，SVM，LR；生成模型：HMM，朴素贝叶斯）

\end{itemize}

不同点：
\begin{itemize}
\item {} 
本质不同：loss function不同

\item {} 
SVM只有支持向量影响模型，LR中每个样本都有作用。

\item {} 
SVM针对线性不可分问题有核函数。

\item {} 
SVM依赖样本间的距离测度，样本特征需要归一化，也就是说SVM基于距离，LR基于概率。

\item {} 
SVM是 \sphinxstylestrong{结构风险最小化} 算法（在训练误差和模型复杂度之间的折中，防止过拟合，从而达到真实误差最小化），因为SVM自带正则（ \(\left \| w \right \|^2\) ）。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{machineLearning/02_svm:id6}}\begin{enumerate}
\item {} 
LR与SVM的异同

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/zhizhan/p/5038747.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
核函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/loujiayu/archive/2013/12/19/3481320.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
SVM面试题

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/fa02098bc220}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
SVM的优缺点

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/fengzhizizhizizhizi/article/details/23911699}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
机器学习技法\textendash{}SVM的对偶问题

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/de882f0fc434}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
周志华《机器学习》Page 121 \textendash{} 124。

\end{enumerate}


\section{主成分分析}
\label{\detokenize{machineLearning/03_pca::doc}}\label{\detokenize{machineLearning/03_pca:id1}}
\sphinxstylestrong{PCA} : Principal Component Analysis.

\sphinxstylestrong{最大可分性} ：样本点到超平面的投影能尽可能分开（投影后样本点方差最大化）。


\subsection{优化目标}
\label{\detokenize{machineLearning/03_pca:id2}}\begin{equation*}
\begin{split}\underset{W}{max} & & \ Tr(W^{\top}XX^{\top}W) \\
s.t. & & \ W^{\top}W=I. \\
& &\ X \in \mathbb{R}^{d \times m}, \\
& &\ W \in \mathbb{R}^{d \times d^\prime}, \\
& &\ d^\prime < d.\end{split}
\end{equation*}

\subsection{求解}
\label{\detokenize{machineLearning/03_pca:id3}}\begin{enumerate}
\item {} 
计算样本的协方差矩阵 \(C = XX^{\top}\) ；

\item {} 
对协方差矩阵做特征值分解（EVD）；

\item {} 
取最大的 \(d^\prime\) 个特征值 \((\lambda_1, \lambda_2,...,\lambda_{d^\prime})\) 对应的特征向量：
\begin{quote}
\begin{equation*}
\begin{split}W = (w_1, w_2,...,w_{d^\prime})\end{split}
\end{equation*}\end{quote}

\end{enumerate}


\subsection{PCA-Whitening}
\label{\detokenize{machineLearning/03_pca:pca-whitening}}
白化（Whitening）的目的是降低输入的冗余性：
\begin{itemize}
\item {} 
特征之间相关性降低

\item {} 
所有特征具有相同的方差

\end{itemize}
\begin{equation*}
\begin{split}x_{rot} & = &\  W^{\top} x, \\
x_{pca\ white, i} & = &\  \frac{x_{rot, i}}{\sqrt{\lambda_i}}\end{split}
\end{equation*}

\subsection{SVD分解}
\label{\detokenize{machineLearning/03_pca:svd}}\begin{equation*}
\begin{split}A & = &\ U \Sigma V^{\top},\\
A & \in &\ \mathbb{R}^{m \times n}, \\
r & = &\ rank(A),\\
U & \in &\ \mathbb{R}^{m \times r}, \\
\Sigma & \in &\ \mathbb{R}^{r \times r}, \\
V & \in &\ \mathbb{R}^{n \times r}.\end{split}
\end{equation*}
其中 \(U\) 是 \(AA^{\top}\) 的特征向量矩阵， \(V\) 是 \(A^{\top}A\) 的特征向量矩阵。

当 \(d\) 很大时， \(C=XX^{\top}\) 是很高维的矩阵，计算该矩阵并求特征向量开销大。此时对 \(X\) 做SVD分解，得到 \(U\) 便是
协方差矩阵 \(C\) 的特征向量。


\subsection{参考资料}
\label{\detokenize{machineLearning/03_pca:id4}}\begin{enumerate}
\item {} 
周志华《机器学习》Page 229 \textendash{} 232。

\item {} 
ufldl

\end{enumerate}
\begin{quote}

\sphinxurl{http://ufldl.stanford.edu/wiki/index.php/PCA}
\end{quote}


\section{常用矩阵求导公式}
\label{\detokenize{machineLearning/04_derivative::doc}}\label{\detokenize{machineLearning/04_derivative:id1}}
导数有两种不同的表示形式：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{04_matrix}.jpg}\hspace*{\fill}}

这里使用 \sphinxstylestrong{denominator layout} 。

\(\mathbf{x},\mathbf{a},\mathbf{b}\) 均为 \sphinxstylestrong{列向量} 。


\subsection{一阶}
\label{\detokenize{machineLearning/04_derivative:id2}}\begin{equation*}
\begin{split}\frac{\partial{(\mathbf{x}^{\top} \mathbf{a})}}{\partial{\mathbf{x}}} & = & \  \frac{\partial{(\mathbf{a}^{\top} \mathbf{x})}}{\partial{\mathbf{x}}} = \ \mathbf{a} \\
\frac{\partial{(\mathbf{a}^{\top} \mathbf{X} \mathbf{b})}}{\partial{\mathbf{X}}} & = & \  \mathbf{a} \mathbf{b}^{\top} \\
\frac{\partial{(\mathbf{a}^{\top} \mathbf{X}^{\top} \mathbf{b})}}{\partial{\mathbf{X}}} & = & \  \mathbf{b} \mathbf{a}^{\top} \\
\frac{\partial{(\mathbf{a}^{\top} \mathbf{X} \mathbf{a})}}{\partial{\mathbf{X}}} & = & \  \mathbf{a} \mathbf{a}^{\top} \\\end{split}
\end{equation*}

\subsection{二阶}
\label{\detokenize{machineLearning/04_derivative:id3}}\begin{equation*}
\begin{split}\frac{\partial{(\mathbf{x}^{\top} \mathbf{x})}}{\partial{\mathbf{x}}} & = & \ 2 \mathbf{x} \\
\frac{\partial{(\mathbf{x}^{\top} \mathbf{B} \mathbf{x})}}{\partial{\mathbf{x}}} & = & \ (\mathbf{B} + \mathbf{B}^{\top}) \mathbf{x} \\
\frac{\partial{(\mathbf{a}^{\top} \mathbf{X}^{\top} \mathbf{X} \mathbf{b})}}{\partial{\mathbf{X}}} & = & \  \mathbf{X} (\mathbf{a}\mathbf{b}^{\top} + \mathbf{b}\mathbf{a}^{\top}) \\\end{split}
\end{equation*}

\subsection{迹}
\label{\detokenize{machineLearning/04_derivative:id4}}
\(Tr(\mathbf{A}^{\top}\mathbf{B}) = Tr(\mathbf{B}^{\top}\mathbf{A})\)
\begin{equation*}
\begin{split}\frac{\partial{(Tr(\mathbf{X}))}}{\partial{\mathbf{X}}} & = & \ \mathbf{I} \\
\frac{\partial{(Tr(\mathbf{X} \mathbf{A}))}}{\partial{\mathbf{X}}} & = & \ \mathbf{A}^{\top} \\
\frac{\partial{(Tr(\mathbf{X}^{\top} \mathbf{A}))}}{\partial{\mathbf{X}}} & = & \ \frac{\partial{(Tr(\mathbf{A} \mathbf{X}^{\top}))}}{\partial{\mathbf{X}}} = \  \mathbf{A} \\
\frac{\partial{(Tr(\mathbf{A} \mathbf{X} \mathbf{B}))}}{\partial{\mathbf{X}}} & = & \ \mathbf{A}^{\top}\mathbf{B}^{\top} \\
\frac{\partial{(Tr(\mathbf{A} \mathbf{X}^{\top} \mathbf{B}))}}{\partial{\mathbf{X}}} & = & \ \mathbf{B}\mathbf{A} \\
\frac{\partial{(Tr(\mathbf{X} \mathbf{X}^{\top}))}}{\partial{\mathbf{X}}} & = & \ 2 \mathbf{X} \\
\frac{\partial{(Tr(\mathbf{X}^{2}))}}{\partial{\mathbf{X}}} & = & \ 2 \mathbf{X}^{\top} \\
\frac{\partial{(Tr(\mathbf{X} \mathbf{B} \mathbf{X}^{\top}))}}{\partial{\mathbf{X}}} & = & \ \mathbf{X}\mathbf{B}^{\top} + \mathbf{X}\mathbf{B} \\
\frac{\partial{(Tr(\mathbf{X}^{\top} \mathbf{B} \mathbf{X}))}}{\partial{\mathbf{X}}} & = & \ \mathbf{B}\mathbf{X} + \mathbf{B}^{\top}\mathbf{X} \\\end{split}
\end{equation*}

\subsection{参考资料}
\label{\detokenize{machineLearning/04_derivative:id5}}\begin{enumerate}
\item {} 
The Matrix Cookbook

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Matrix Derivatives

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.comp.nus.edu.sg/~cs5240/lecture/matrix-differentiation.pdf}
\end{quote}


\section{牛顿方法}
\label{\detokenize{machineLearning/05_newton::doc}}\label{\detokenize{machineLearning/05_newton:id1}}
牛顿方法（Newton’s method, Newton-Raphson method）可以有效地近似实值函数的根。


\subsection{一维}
\label{\detokenize{machineLearning/05_newton:id2}}\begin{equation*}
\begin{split}x_{n+1} = \  x_n - \frac{f(x_n)}{f^{\prime}(x_n)}\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=420\sphinxpxdimen]{{05_newton}.gif}\hspace*{\fill}}


\subsection{高维}
\label{\detokenize{machineLearning/05_newton:id3}}\begin{equation*}
\begin{split}x_{n+1} & = & \  x_n - J^{-1} F(x_n). \\
x & \in & \ \mathbb{R}^k,\\
F & : & \ \mathbb{R}^k \rightarrow \mathbb{R}^k, \\
J & \in & \ \mathbb{R}^{k \times k}, [\text{Jacobian matrix}] \\
J_{ij} & = & \ \frac{\partial F_i}{\partial x_j}.  \\\end{split}
\end{equation*}
由于求解 Jacobian matrix 的逆复杂度较高，因此可以通过求解以下等式来节省时间开销：
\begin{equation*}
\begin{split}J \cdot (x_{n+1} - x_n) = -F(x_n).\end{split}
\end{equation*}

\subsection{收敛问题}
\label{\detokenize{machineLearning/05_newton:id4}}\begin{itemize}
\item {} 
初始点问题
\begin{itemize}
\item {} 
导数为0，出现除0操作
\begin{equation*}
\begin{split}f(x) & = &\  1 - x^2,\\
x_0 & = &\  0, \\
f^{\prime}(x_0) & = &\ 0.\end{split}
\end{equation*}
\item {} 
死循环
\begin{equation*}
\begin{split}f(x) & = &\  x^3 - 2x + 2,\\
x_0 & = &\  0, \\
x_1 & = &\  1, x_2 = 0, x_3 = 1, ... .\end{split}
\end{equation*}
\end{itemize}

\item {} 
根的导数不存在或不连续

\item {} 
有时候收敛速度慢

\end{itemize}


\subsection{应用}
\label{\detokenize{machineLearning/05_newton:id5}}\begin{itemize}
\item {} 
最大/最小化问题
\begin{itemize}
\item {} 
一维
\begin{equation*}
\begin{split}x_{n+1} = x_n - \frac{f^{\prime}(x_n)}{f^{\prime\prime}(x_n)}\end{split}
\end{equation*}
\item {} 
高维
\begin{equation*}
\begin{split}x_{n+1} & = &\ x_n - H^{-1} \nabla F(x),\\
H_{ij} & = &\ \frac{\partial^2 F}{\partial x_i \ \partial x_j}. [\text{Hessian matrix}]\end{split}
\end{equation*}
\end{itemize}

\item {} 
求倒数（reciprocal）
\begin{equation*}
\begin{split}f(x) & = &\  a - \frac{1}{x},\\
x_{n+1} & = &\ x_n - \frac{f(x_n)}{f^{\prime}(x_n)} \\
 & = &\ x_n (2 - a x_n).\end{split}
\end{equation*}
\item {} 
开根号（sqrt）
\begin{equation*}
\begin{split}f(x) & = &\  x^2 - a,\\
x_{n+1} & = &\ x_n - \frac{f(x_n)}{f^{\prime}(x_n)} \\
& = &\ x_n - \frac{x^2 - a}{2x}.\end{split}
\end{equation*}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{Sqrt}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{x} \PYG{o}{=} \PYG{n}{a}
  \PYG{k}{while} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{a}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{:}
      \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{a}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{float}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{x}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\end{itemize}


\subsection{参考资料}
\label{\detokenize{machineLearning/05_newton:id6}}\begin{enumerate}
\item {} 
Wikipedia: Newton’s method

\end{enumerate}
\begin{quote}

\sphinxurl{https://en.wikipedia.org/wiki/Newton\%27s\_method}
\end{quote}


\chapter{深度学习}
\label{\detokenize{deepLearning/index::doc}}\label{\detokenize{deepLearning/index:id1}}

\section{pytorch：多GPU模式}
\label{\detokenize{deepLearning/01_dataParallel::doc}}\label{\detokenize{deepLearning/01_dataParallel:pytorch-gpu}}
\sphinxstylestrong{pytorch} 中可以通过 \sphinxcode{\sphinxupquote{torch.nn.DataParallel}} 切换到多GPU(multi-GPU)模式，有两种使用方式：网络外指定、网络内指定。


\subsection{网络外指定}
\label{\detokenize{deepLearning/01_dataParallel:id1}}
使用方法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} 在GPU上运行}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 使用第0、1、2个GPU，注意设定batch\PYGZus{}size大一些，否则数据不足以跑多GPU}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{parallel}\PYG{o}{.}\PYG{n}{DataParallel}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{device\PYGZus{}ids}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{DataParallel} 只对  \sphinxcode{\sphinxupquote{forward()}} 和 \sphinxcode{\sphinxupquote{backward()}} 有效，直接调用model中自定义的  \sphinxcode{\sphinxupquote{attribute}} 如 \sphinxcode{\sphinxupquote{forward\_1()}} 无效。

另外，在 \sphinxstylestrong{DataParallel} 模式下，引用model的  \sphinxcode{\sphinxupquote{attribute}} 必须采用如下格式:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 相比于\PYGZsq{}model.attribute\PYGZsq{}多了\PYGZsq{}module\PYGZsq{}。}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{module}\PYG{o}{.}\PYG{n}{attribute}
\end{sphinxVerbatim}

比如，\sphinxcode{\sphinxupquote{model.module.classifier.parameters()}} 。


\subsection{网络内指定}
\label{\detokenize{deepLearning/01_dataParallel:id2}}
使用方法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} 定义网络结构}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer1} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{227}\PYG{p}{,} \PYG{l+m+mi}{128}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer1} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{DataParallel}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer1}\PYG{p}{,} \PYG{n}{device\PYGZus{}ids}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

在CPU模式下不需要更改代码。


\subsection{参考资料}
\label{\detokenize{deepLearning/01_dataParallel:id3}}\begin{enumerate}
\item {} 
pytorch documentation

\end{enumerate}
\begin{quote}

\sphinxurl{https://pytorch.org/docs/stable/nn.html\#torch.nn.DataParallel}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
网络内指定

\end{enumerate}
\begin{quote}

\sphinxurl{https://ptorch.com/docs/3/parallelism\_tutorial}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
引用attribute

\end{enumerate}
\begin{quote}

\sphinxurl{https://discuss.pytorch.org/t/how-to-reach-model-attributes-wrapped-by-nn-dataparallel/1373}
\end{quote}


\section{激活函数}
\label{\detokenize{deepLearning/02_activationFunction::doc}}\label{\detokenize{deepLearning/02_activationFunction:id1}}
神经网络引入激活函数（Activation Function）主要是为了增强网络的非线性，提升网络的拟合能力和学习能力。激活函数有以下几个性质：
\begin{itemize}
\item {} 
非线性

\item {} 
可微性

\item {} 
单调性：保证单层网络是凸函数

\end{itemize}

下面介绍 \sphinxstylestrong{sigmoid} 、\sphinxstylestrong{tanh} 以及 \sphinxstylestrong{ReLU} 。


\subsection{sigmoid}
\label{\detokenize{deepLearning/02_activationFunction:sigmoid}}
\sphinxstylestrong{sigmoid} 函数的数学表达式如下：
\begin{equation*}
\begin{split}\sigma(z) = \frac{1}{1 + e^{-z}}.\end{split}
\end{equation*}
其导数具有如下性质：
\begin{equation*}
\begin{split}\sigma^\prime(z) = \sigma(z)(1-\sigma(z)).\end{split}
\end{equation*}
\sphinxstylestrong{sigmoid} 函数能够把输入的连续值压缩到 (0, 1) 范围内，其函数曲线如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_sigmoid}.jpeg}\hspace*{\fill}}

优点：
\begin{itemize}
\item {} 
单调连续，输出范围有限，优化稳定

\item {} 
求导容易

\end{itemize}

缺点：
\begin{itemize}
\item {} 
容易饱和。当输入很大/很小时（saturation, 饱和），神经元的梯度接近0，出现“梯度消失”（gradient vanishing），导致无法完成深层网络的训练。

\item {} 
输出不是零均值的（not zero-centered）。假设某个神经元的输入一直是正的，即 \(x>0\) . 对于 \(f(x)=w^Tx+b\) ，则 \(w\) 获得的梯度将是恒正或者恒负
（取决于 \(f\) 得到的梯度的符号），导致 \(w\) 的更新非常“曲折”（zig-zagging）。
当然，如果是按batch训练，最终梯度是各个样本下梯度的和，而每个样本下的梯度可能是符号各异的，因此在一定程度上可以缓解这个问题。

\end{itemize}


\subsection{tanh}
\label{\detokenize{deepLearning/02_activationFunction:tanh}}
\sphinxstylestrong{tanh} 函数的数学表达式如下：
\begin{equation*}
\begin{split}tanh(z) = \frac{e^z-e^{-z}}{e^z+e^{-z}} = 2\sigma(2z)-1.\end{split}
\end{equation*}
其函数曲线如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_tanh}.jpeg}\hspace*{\fill}}

与 \sphinxstylestrong{sigmoid} 一样， \sphinxstylestrong{tanh} 也会产生饱和现象，但是 \sphinxstylestrong{tanh} 的输出是零均值的（zero-centered）。


\subsection{ReLU}
\label{\detokenize{deepLearning/02_activationFunction:relu}}
\sphinxstylestrong{ReLU} 函数的数学表达式如下：
\begin{equation*}
\begin{split}relu(z) = max(0,z).\end{split}
\end{equation*}
其函数曲线如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_relu}.jpeg}\hspace*{\fill}}

优点：
\begin{itemize}
\item {} 
计算简单。 \sphinxstylestrong{sigmoid} 和 \sphinxstylestrong{tanh} 都需要计算指数。

\item {} 
收敛速度快。 \sphinxhref{http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf}{Krizhevsky et al. 论文} 指出 \sphinxstylestrong{ReLU} 收敛速度比 \sphinxstylestrong{tanh} 快6倍。
\begin{quote}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{02_alexplot}.jpeg}\hspace*{\fill}}
\end{quote}

\end{itemize}

缺点:
\begin{itemize}
\item {} 
容易产生死亡节点（dead ReLU）。一个非常大的梯度流过一个 \sphinxstylestrong{ReLU} 神经元，更新过参数之后，这个神经元对很多输入数据都输出0，则梯度一直为0。
当然 \sphinxstylestrong{ReLU} 的输出依靠 \(w\) 和 \(x\) 的共同作用，死亡节点可能会被重新激活。

\end{itemize}

\sphinxstylestrong{LeakyReLU} 可以有效应对上述缺点。


\subsection{参考资料}
\label{\detokenize{deepLearning/02_activationFunction:id2}}\begin{enumerate}
\item {} 
CS231n

\end{enumerate}
\begin{quote}

\sphinxurl{http://cs231n.github.io/neural-networks-1/\#actfun}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
神经网络之激活函数(Activation Function)

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/memray/article/details/51442059}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
What is the “dying ReLU” problem in neural networks?

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.quora.com/What-is-the-dying-ReLU-problem-in-neural-networks}
\end{quote}


\section{Batch Normalization}
\label{\detokenize{deepLearning/03_batchnorm:batch-normalization}}\label{\detokenize{deepLearning/03_batchnorm::doc}}\begin{equation*}
\begin{split}\hat{x}^{(k)} &=&\ \frac{x^{(k)} - E[x^{(k)}]}{\sqrt{Var[x^{{(k)}}] + \epsilon}} \\
y^{(k)} &=&\ \gamma^{(k)} \hat{x}^{(k)} + \beta^{(k)}\end{split}
\end{equation*}

\subsection{加速训练}
\label{\detokenize{deepLearning/03_batchnorm:id1}}\begin{itemize}
\item {} 
\sphinxstylestrong{增大学习率} 。由于网络参数不断更新，导致各层输入的分布不断变化，导致往往需要使用较小的学习率，并精心设计参数初始化。使用BN进行归一化之后，各层输入的分布相同，因此可以使用更大的学习率更快地收敛，并降低网络对初始化的依赖。

\item {} 
\sphinxstylestrong{移除 dropout} 。进行 BN 之后，各样本的 feature map 已经融合了一个 batch 之中其他样本的特性（均值，方差），因此单一样本的影响变小，网络更好学习整体的规律，有效地减小了过拟合的可能性（ BN 提供了正则化的作用）。

\item {} 
\sphinxstylestrong{减小} \(L_2\) \sphinxstylestrong{正则化损失的权重} 。

\item {} 
\sphinxstylestrong{加速学习率衰减} 。

\end{itemize}


\subsection{BN消除}
\label{\detokenize{deepLearning/03_batchnorm:bn}}
如果网络发现这种 normalization 是多余的，可以通过学习使得：
\begin{equation*}
\begin{split}\gamma^{(k)} &=&\ \sqrt{Var[x^{{(k)}}]} \\
\beta^{(k)} &=&\ E[x^{(k)}]\end{split}
\end{equation*}
从而消除 BN 的作用。


\subsection{缺点}
\label{\detokenize{deepLearning/03_batchnorm:id2}}
BN统计均值、方差与batch size有关，batch size太小会导致性能变差。而某些任务受内存限制，batch size难以设置很大，因此BN作用难以显现。
这时候出现了Group Normalization。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{03_groupNorm}.jpg}\hspace*{\fill}}


\subsection{参考资料}
\label{\detokenize{deepLearning/03_batchnorm:id3}}\begin{enumerate}
\item {} 
Batch Normalization

\end{enumerate}
\begin{quote}

\sphinxurl{https://arxiv.org/pdf/1502.03167.pdf}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Group Normalization

\end{enumerate}
\begin{quote}

\sphinxurl{http://openaccess.thecvf.com/content\_ECCV\_2018/papers/Yuxin\_Wu\_Group\_Normalization\_ECCV\_2018\_paper.pdf}
\end{quote}


\section{过拟合}
\label{\detokenize{deepLearning/04_overfit::doc}}\label{\detokenize{deepLearning/04_overfit:id1}}
复杂的模型将训练数据的抽样误差考虑在内，对抽样误差也进行了拟合。过拟合的模型可以看成是完全记忆型模型。


\subsection{表现}
\label{\detokenize{deepLearning/04_overfit:id2}}
训练误差小，测试误差大，泛化能力差。


\subsection{原因}
\label{\detokenize{deepLearning/04_overfit:id3}}\begin{itemize}
\item {} 
训练集大小与模型复杂度不匹配；

\item {} 
样本的噪声太大甚至掩盖了真实样本的分布规律；

\item {} 
训练迭代次数太多（over-training）。

\end{itemize}


\subsection{解决方案}
\label{\detokenize{deepLearning/04_overfit:id4}}
\sphinxstylestrong{1}. 调小模型复杂度。

\sphinxstylestrong{2}. data augmentation.

\sphinxstylestrong{3}. dropout.

\sphinxstylestrong{4}. early stopping. 记录观察validation accuracy，及时停止训练。

\sphinxstylestrong{5}. 集成学习。Bagging：并行化模型生成，减小模型variance。Boosting：串行化模型生成，减小模型bias。

\sphinxstylestrong{6}. 正则化。
\begin{itemize}
\item {} 
L0正则化（非0元素个数），难以优化求解（NP-Hard）。

\item {} 
L1正则化（元素绝对值之和， Lasso regression），是L0范数的最优凸近似，使权值稀疏。权值稀疏的好处：特征选择 \&\& 可解释性。

\item {} 
L2正则化（元素平方和，Ridge regression / weight dacay），使权值分布均匀且值较小。

\end{itemize}


\subsection{附：正则化}
\label{\detokenize{deepLearning/04_overfit:id5}}\begin{equation*}
\begin{split}L_q\text{-norm}: \ \| w \|^q_q = \sum_j | w_j |^q.\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=600\sphinxpxdimen]{{04_norm}.jpg}\hspace*{\fill}}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{04_norm2}.jpg}\hspace*{\fill}}


\section{pytorch：模型保存与读取}
\label{\detokenize{deepLearning/05_modelSave:pytorch}}\label{\detokenize{deepLearning/05_modelSave::doc}}

\subsection{简单}
\label{\detokenize{deepLearning/05_modelSave:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} save}
\PYG{n}{torch}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model.pkl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} load}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model.pkl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

这种方法存储的模型包括了模型框架及模型参数，一般存取的pkl文件较大。


\subsection{详细}
\label{\detokenize{deepLearning/05_modelSave:id2}}
模型除了本身的框架、参数信息，还应包括训练的信息，比如训练迭代次数、优化器参数等。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{shutil}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} save}
\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}checkpoint}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{is\PYGZus{}best}\PYG{p}{,} \PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}
  \PYG{n}{torch}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}
  \PYG{k}{if} \PYG{n}{is\PYGZus{}best}\PYG{p}{:}
    \PYG{n}{bestname} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model\PYGZus{}best.pth.tar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{shutil}\PYG{o}{.}\PYG{n}{copyfile}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{bestname}\PYG{p}{)}

\PYG{n}{save\PYGZus{}checkpoint}\PYG{p}{(}\PYG{p}{\PYGZob{}}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{cur\PYGZus{}epoch}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{model}\PYG{o}{.}\PYG{n}{state\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{best\PYGZus{}prec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{best\PYGZus{}prec}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss\PYGZus{}train}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{loss\PYGZus{}train}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{optimizer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{state\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
      \PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{is\PYGZus{}best}\PYG{p}{,} \PYG{n}{save\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch\PYGZhy{}\PYGZob{}\PYGZcb{}\PYGZus{}checkpoint.pth.tar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{cur\PYGZus{}epoch}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} load}
\PYG{k}{def} \PYG{n+nf}{load\PYGZus{}checkpoint}\PYG{p}{(}\PYG{n}{checkpoint}\PYG{p}{,} \PYG{n}{model}\PYG{p}{,} \PYG{n}{optimizer}\PYG{p}{)}\PYG{p}{:}
  \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} loads state into model and optimizer and returns:}
\PYG{l+s+sd}{      epoch, best\PYGZus{}precision, loss\PYGZus{}train[]}
\PYG{l+s+sd}{      e.g., model = alexnet(pretrained=False)}
\PYG{l+s+sd}{  \PYGZdq{}\PYGZdq{}\PYGZdq{}}
  \PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{isfile}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=\PYGZgt{} loading checkpoint }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}\PYG{p}{)}
      \PYG{n}{checkpoint} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}
      \PYG{n}{epoch} \PYG{o}{=} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{best\PYGZus{}prec} \PYG{o}{=} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{best\PYGZus{}prec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{loss\PYGZus{}train} \PYG{o}{=} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss\PYGZus{}train}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{model}\PYG{o}{.}\PYG{n}{load\PYGZus{}state\PYGZus{}dict}\PYG{p}{(}\PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
      \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{load\PYGZus{}state\PYGZus{}dict}\PYG{p}{(}\PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{optimizer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
      \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=\PYGZgt{} loaded checkpoint }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ (epoch \PYGZob{}\PYGZcb{})}\PYG{l+s+s2}{\PYGZdq{}}
            \PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{epoch}\PYG{p}{,} \PYG{n}{checkpoint}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
      \PYG{k}{return} \PYG{n}{epoch}\PYG{p}{,} \PYG{n}{best\PYGZus{}prec}\PYG{p}{,} \PYG{n}{loss\PYGZus{}train}
  \PYG{k}{else}\PYG{p}{:}
      \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=\PYGZgt{} no checkpoint found at }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{load\PYGZus{}path}\PYG{p}{)}\PYG{p}{)}
      \PYG{c+c1}{\PYGZsh{} epoch, best\PYGZus{}precision, loss\PYGZus{}train}
      \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{load部分参数}
\label{\detokenize{deepLearning/05_modelSave:load}}
当我们只需要从 \sphinxcode{\sphinxupquote{state\_dict()}} load部分模型参数是，可以采用如下方法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} args has the model name, num classes and other irrelevant stuff}
\PYG{n}{pretrained\PYGZus{}state} \PYG{o}{=} \PYG{n}{model\PYGZus{}zoo}\PYG{o}{.}\PYG{n}{load\PYGZus{}url}\PYG{p}{(}\PYG{n}{model\PYGZus{}names}\PYG{p}{[}\PYG{n}{args}\PYG{o}{.}\PYG{n}{arch}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{model\PYGZus{}state} \PYG{o}{=} \PYG{n}{my\PYGZus{}model}\PYG{o}{.}\PYG{n}{state\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{pretrained\PYGZus{}state} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{n}{k}\PYG{p}{:}\PYG{n}{v} \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{pretrained\PYGZus{}state}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{(}\PYG{p}{)} \PYG{k}{if} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{model\PYGZus{}state} \PYG{o+ow}{and} \PYG{n}{v}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{model\PYGZus{}state}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZcb{}}
\PYG{n}{model\PYGZus{}state}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{pretrained\PYGZus{}state}\PYG{p}{)}
\PYG{n}{my\PYGZus{}model}\PYG{o}{.}\PYG{n}{load\PYGZus{}state\PYGZus{}dict}\PYG{p}{(}\PYG{n}{model\PYGZus{}state}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{deepLearning/05_modelSave:id3}}\begin{enumerate}
\item {} 
Saving and loading a model in Pytorch?

\end{enumerate}
\begin{quote}

\sphinxurl{https://discuss.pytorch.org/t/saving-and-loading-a-model-in-pytorch/2610}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
How to load part of pre trained model?

\end{enumerate}
\begin{quote}

\sphinxurl{https://discuss.pytorch.org/t/how-to-load-part-of-pre-trained-model/1113/8}
\end{quote}


\section{pytorch: cuda()}
\label{\detokenize{deepLearning/06_cuda:pytorch-cuda}}\label{\detokenize{deepLearning/06_cuda::doc}}

\subsection{使用指定GPU}
\label{\detokenize{deepLearning/06_cuda:gpu}}\begin{itemize}
\item {} 
\sphinxstylestrong{直接终端中设定}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CUDA\PYGZus{}VISIBLE\PYGZus{}DEVICES}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{python} \PYG{n}{my\PYGZus{}script}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{代码中设定}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{environ}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CUDA\PYGZus{}VISIBLE\PYGZus{}DEVICES}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{使用函数 set\_device}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{n}{torch}\PYG{o}{.}\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{set\PYGZus{}device}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\subsection{cuda()}
\label{\detokenize{deepLearning/06_cuda:cuda}}
对于一个 \sphinxcode{\sphinxupquote{tensor}} 对象，cuda()返回该对象在CUDA内存中的拷贝

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{obj} \PYG{o}{=} \PYG{n}{obj}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

对于一个 \sphinxcode{\sphinxupquote{nn.Module}} 实例，cuda()直接将该模型的参数和buffers转移到GPU。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{deepLearning/06_cuda:id1}}\begin{enumerate}
\item {} 
PyTorch中使用指定的GPU

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/darkknightzh/p/6836568.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
pytorch documentation

\end{enumerate}
\begin{quote}

\sphinxurl{https://pytorch.org/docs/0.3.1/tensors.html?highlight=cuda\#torch.Tensor.cuda}

\sphinxurl{https://pytorch.org/docs/0.3.1/nn.html?highlight=cuda\#torch.nn.Module.cuda}
\end{quote}


\section{反向传播}
\label{\detokenize{deepLearning/07_backprop::doc}}\label{\detokenize{deepLearning/07_backprop:id1}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{07_backprop}.jpg}\hspace*{\fill}}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{符号说明}\label{\detokenize{deepLearning/07_backprop:id5}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
符号
&\sphinxstyletheadfamily 
含义
\\
\hline
\(n\)
&
网络层数
\\
\hline
\(C_l\)
&
第 \(l\) 层神经元个数（不包括偏置）
\\
\hline
\(g(x)\)
&
激活函数
\\
\hline
\(w^{(l)}_{ji}\)
&
第 \(l\) 层第 \(i\) 个神经元与第 \(l+1\) 层第 \(j\) 个神经元的连接权重
\\
\hline
\(b^{(l)}_i\)
&
第 \(l+1\) 层第 \(i\) 个神经元的偏置
\\
\hline
\(z^{(l)}_i\)
&
第 \(l\) 层第 \(i\) 个神经元的输入
\\
\hline
\(a^{(l)}_i\)
&
第 \(l\) 层第 \(i\) 个神经元的激活值
\\
\hline
\(\delta^{(l)}_i\)
&
第 \(l\) 层第 \(i\) 个神经元的误差（error）
\\
\hline
\(y_j\)
&
标签第 \(j\) 维（第 \(j\) 类）
\\
\hline
\(\mathcal{L}_{w,b}(x)\)
&
损失函数，简称 \(\mathcal{L}\)
\\
\hline
\(x\)
&
训练样本
\\
\hline
\(m\)
&
小批量训练样本个数
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{前向传播}
\label{\detokenize{deepLearning/07_backprop:id2}}\begin{equation*}
\begin{split}z^{(l+1)}_i & = & \  b^{(l)}_i + \sum_{j=1}^{C_l}w^{(l)}_{ij}a^{(l)}_j, \\
g(t) & = & \  \frac{1}{1 + e^{-t}}, \\
g^{\prime}(t) & = & \ (1 - g(t))g(t) , \\
a^{(l)}_i & = & \  g(z^{(l)}_i).\end{split}
\end{equation*}
\sphinxstylestrong{误差} 定义为：
\begin{equation*}
\begin{split}\delta^{(l)}_i = \  \frac{\partial{\mathcal{L}}}{\partial{z^{(l)}_i}}\end{split}
\end{equation*}

\subsection{误差反向传播}
\label{\detokenize{deepLearning/07_backprop:id3}}

\subsubsection{\sphinxstylestrong{MSE} （Mean Squared Error）}
\label{\detokenize{deepLearning/07_backprop:mse-mean-squared-error}}
对每一个样本，损失为：
\begin{equation*}
\begin{split}\mathcal{L} = \frac{1}{2} \sum_{j=1}^{C_n}(y_j - a^{(n)}_j)^2.\end{split}
\end{equation*}
最后一层的误差：
\begin{equation*}
\begin{split}\delta^{(n)}_i & = & \  \frac{\partial{\mathcal{L}}}{\partial{z^{(n)}_i}} \\
               & = & \  \frac{1}{2} \frac{\partial{\bigg [ \sum_{j=1}^{C_n}(y_j - a^{(n)}_j)^2 \bigg ]}}{\partial{z^{(n)}_i}} \\
               & = & \  \frac{1}{2} \frac{\partial{\bigg [ (y_i - g(z^{(n)}_i))^2 \bigg ]}}{\partial{z^{(n)}_i}} \\
               & = & \  - (y_i - g(z^{(n)}_i)) g^{\prime}(z^{(n)}_i)\end{split}
\end{equation*}
递推前层误差：
\begin{equation*}
\begin{split}\delta^{(l)}_i & = & \  \frac{\partial{\mathcal{L}}}{\partial{z^{(l)}_i}} \\
                & = & \  \sum_{j=1}^{C_{l+1}} \frac{\partial{\mathcal{L}}}{\partial{z^{(l+1)}_j}} \frac{\partial{z^{(l+1)}_j}}{\partial{a^{(l)}_i}} \frac{\partial{a^{(l)}_i}}{\partial{z^{(l)}_i}} \\
                & = & \  \sum_{j=1}^{C_{l+1}} \frac{\partial{\mathcal{L}}}{\partial{z^{(l+1)}_j}} \frac{\partial{\left ( b^{(l)}_i + \sum_{k=1}^{C_l}w^{(l)}_{jk}a^{(l)}_k \right )}}{\partial{a^{(l)}_i}} \frac{\partial{a^{(l)}_i}}{\partial{z^{(l)}_i}} \\
                & = & \  \sum_{j=1}^{C_{l+1}} \delta^{(l+1)}_j w_{ji}^{(l)} g^{\prime}(z^{(l)}_i) \\
                & = & \  g^{\prime}(z^{(l)}_i) \sum_{j=1}^{C_{l+1}} \delta^{(l+1)}_j w_{ji}^{(l)}\end{split}
\end{equation*}
权重和偏置的梯度：
\begin{equation*}
\begin{split}\frac{\partial{\mathcal{L}}}{\partial{w_{ij}^{(l)}}} & = & \  \frac{\partial{\mathcal{L}}}{\partial{z^{(l+1)}_i}} \frac{\partial{z^{(l+1)}_i}}{\partial{w_{ij}^{(l)}}} \\
                                                   & = & \  \delta^{(l+1)}_i \frac{\partial{z^{(l+1)}_i}}{\partial{w_{ij}^{(l)}}} \\
                                                   & = & \  \delta^{(l+1)}_i \frac{\partial{\left ( b^{(l)}_i + \sum_{k=1}^{C_l}w^{(l)}_{ik}a^{(l)}_k \right )}}{\partial{w_{ij}^{(l)}}} \\
                                                   & = & \  \delta^{(l+1)}_i a^{(l)}_j \\
\frac{\partial{\mathcal{L}}}{\partial{b_i^{(l)}}} & = & \  \delta^{(l+1)}_i\end{split}
\end{equation*}\begin{description}
\item[{梯度下降}] \leavevmode\begin{itemize}
\item {} 
权重更新
\begin{equation*}
\begin{split}w_{ij}^{(l)} \leftarrow w_{ij}^{(l)} - \alpha \times \frac{1}{m} \sum_x \frac{\partial{\mathcal{L}}}{\partial{w_{ij}^{(l)}}} = w_{ij}^{(l)} - \frac{\alpha}{m} \sum_x \delta^{(l+1)}_i a^{(l)}_j\end{split}
\end{equation*}
\item {} 
偏置更新
\begin{equation*}
\begin{split}b_i^{(l)}  \leftarrow b_i^{(l)} - \alpha \times \frac{1}{m} \sum_x \frac{\partial{\mathcal{L}}}{\partial{b_i^{(l)}}} = b_i^{(l)} - \frac{\alpha}{m} \sum_x \delta^{(l+1)}_i\end{split}
\end{equation*}
\end{itemize}

\end{description}


\subsubsection{\sphinxstylestrong{Cross Entropy} （交叉熵）}
\label{\detokenize{deepLearning/07_backprop:cross-entropy}}
损失函数为：
\begin{equation*}
\begin{split}\mathcal{L} = - \sum_{j=1}^{C_n} y_j \ln \hat{y}_j, \\
y_j \in \{ 0,1 \}, \\
\hat{y}_j = softmax(\mathbb{a}^{(n)}, j) = \frac{e^{a^{(n)}_j}}{\sum_{k=1}^{C_n} e^{a^{(n)}_k}}.\end{split}
\end{equation*}
softmax偏导为：
$$
\frac{\partial{\hat{y}_j}}{\partial{a^{(n)}_i}} =
\begin{cases}
   - \hat{y}_j \hat{y}_i & & i \ne j \\
   \hat{y}_i (1 - \hat{y}_i) & &  i = j
\end{cases}
$$
另外，由链式法则（chain rule）：
\begin{equation*}
\begin{split}\frac{\partial{\mathcal{L}}}{\partial{z^{(n)}_i}} & = & \  \frac{\partial{\mathcal{L}}}{\partial{a^{(n)}_i}} \frac{\partial{a^{(n)}_i}}{\partial{z^{(n)}_i}} \\
\frac{\partial{\mathcal{L}}}{\partial{a^{(n)}_i}} & = & \  \sum_{j=1}^{C_n} \frac{\partial{\mathcal{L}}}{\partial{\hat{y}_j}} \frac{\partial{\hat{y}_j}}{\partial{a^{(n)}_i}} \\
\frac{\partial{\mathcal{L}}}{\partial{\hat{y}_j}} & = & \  - \frac{y_j}{\hat{y}_j}\end{split}
\end{equation*}
可推得：
\begin{equation*}
\begin{split}\frac{\partial{\mathcal{L}}}{\partial{a^{(n)}_i}} & = & \  \sum_{j=1}^{C_n} \frac{\partial{\mathcal{L}}}{\partial{\hat{y}_j}} \frac{\partial{\hat{y}_j}}{\partial{a^{(n)}_i}} \\
                                                  & = & \  \frac{\partial{\mathcal{L}}}{\partial{\hat{y}_i}} \frac{\partial{\hat{y}_i}}{\partial{a^{(n)}_i}} + \sum_{j \ne i}^{C_n} \frac{\partial{\mathcal{L}}}{\partial{\hat{y}_j}} \frac{\partial{\hat{y}_j}}{\partial{a^{(n)}_i}} \\
                                                  & = & \  - \frac{y_i}{\hat{y}_i} \times \hat{y}_i (1 - \hat{y}_i) + \sum_{j \ne i}^{C_n} - \frac{y_j}{\hat{y}_j} \times \left ( - \hat{y}_j \hat{y}_i \right) \\
                                                  & = & \  - y_i \times (1 - \hat{y}_i) + \sum_{j \ne i}^{C_n}  y_j \times \hat{y}_i \\
                                                  & = & \  - y_i + \sum_{j=1}^{C_n}  y_j \times \hat{y}_i \\
                                                  & = & \  - y_i + \hat{y}_i\end{split}
\end{equation*}
最后一层的误差：
\begin{equation*}
\begin{split}\delta^{(n)}_i & = & \ \frac{\partial{\mathcal{L}}}{\partial{z^{(n)}_i}} \\
               & = & \ \frac{\partial{\mathcal{L}}}{\partial{a^{(n)}_i}} \frac{\partial{a^{(n)}_i}}{\partial{z^{(n)}_i}} \\
               & = & \ (- y_i + \hat{y}_i) g^{\prime}(z^{(n)}_i)\end{split}
\end{equation*}

\subsection{参考资料}
\label{\detokenize{deepLearning/07_backprop:id4}}\begin{enumerate}
\item {} 
反向传播公式推导

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/nowgood/p/backprop2.html\#\_nav\_0}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
神经网络\textendash{}反向传播详细推导过程

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qq\_29762941/article/details/80343185}
\end{quote}


\section{优化算法}
\label{\detokenize{deepLearning/08_optimizer::doc}}\label{\detokenize{deepLearning/08_optimizer:id1}}

\subsection{可视化}
\label{\detokenize{deepLearning/08_optimizer:id2}}
\sphinxstylestrong{等高线}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{08_contours_evaluation_optimizers}.gif}\hspace*{\fill}}

\sphinxstylestrong{鞍点}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=600\sphinxpxdimen]{{08_saddle_point_evaluation_optimizers}.gif}\hspace*{\fill}}


\subsection{SGD}
\label{\detokenize{deepLearning/08_optimizer:sgd}}
这里 \sphinxstylestrong{SGD} 指小批量梯度下降算法。

小批量损失：\(\mathcal{L}\) ，学习率：\(\eta\) ，Hadamard积：\(\odot\) 。
\begin{equation*}
\begin{split}g & \leftarrow &\ \nabla_{\theta} \mathcal{L} (\theta; x^{(i:i+n)}; y^{(i:i+n)}) &\  [\text{计算梯度}] \\
\theta & \leftarrow &\  \theta - \eta g &\  [\text{参数更新}]\end{split}
\end{equation*}\begin{description}
\item[{特点}] \leavevmode\begin{itemize}
\item {} 
相比于单样本SGD，可以降低参数更新时的方差，收敛更稳定；可以充分地利用深度学习库中高度优化的矩阵操作来进行更有效的梯度计算

\item {} 
不能保证很好的收敛性：如果选择的太小，收敛速度会很慢；如果太大，损失函数就会在极小值处不停地震荡甚至偏离；容易困在鞍点。

\item {} 
选择合适的学习率比较困难：对所有的参数更新使用同样的学习率。对于稀疏数据或者特征，有时我们可能想更快更新对应于不经常出现的特征的参数，对于常出现的特征更新慢一些。

\end{itemize}

\end{description}


\subsection{Momentum}
\label{\detokenize{deepLearning/08_optimizer:momentum}}\begin{equation*}
\begin{split}v & \leftarrow &\  \gamma v - \eta \nabla_{\theta} \mathcal{L}(\theta) &\  [\text{速度更新}] \\
\theta & \leftarrow &\  \theta + v &\ [\text{参数更新}]\end{split}
\end{equation*}
动量（momentum）方法旨在加速学习，特别是处理高曲率、小但一致的梯度，或是带噪声的梯度。动量算法积累了之前梯度指数级衰减的移动平均，并且沿该方向继续移动。
当许多连续的梯度指向相同的方向时，步长最大。
\begin{description}
\item[{特点}] \leavevmode\begin{itemize}
\item {} 
下降初期，使用上一次参数更新；下降方向一致，乘上较大的 \(\gamma\) 能够进行很好的加速。

\item {} 
下降中后期，在局部最小值来回震荡的时候，梯度接近0， \(\gamma\) 能够使得更新幅度增大，跳出陷阱。

\item {} 
梯度改变方向时，能够减少更新。

\end{itemize}

\end{description}


\subsection{Adagrad}
\label{\detokenize{deepLearning/08_optimizer:adagrad}}\begin{equation*}
\begin{split}g & \leftarrow &\ \nabla_{\theta} \mathcal{L}(\theta) &\  [\text{计算梯度}] \\
r & \leftarrow &\ r + g \odot g &\  [\text{累计平方梯度}] \\
\Delta \theta & \leftarrow &\ - \frac{\eta}{\sqrt{r+\epsilon}} \odot g &\  [\text{梯度除以累计平方梯度的平方根}] \\
\theta & \leftarrow &\  \theta + \Delta \theta &\ [\text{参数更新}]\end{split}
\end{equation*}\begin{description}
\item[{特点}] \leavevmode\begin{itemize}
\item {} 
独立地适应所有模型参数的学习率，适合处理稀疏数据。对于梯度 \(g\) 较大的参数（这些参数关联着频繁出现的特征），有一个快速下降的学习率；
对于梯度 \(g\) 较小的参数（这些参数关联着不频繁出现的特征），学习率有相对较小的下降。

\item {} 
从训练开始累积平方梯度，导致有效学习率过早和过量减小，导致训练过早停止。

\end{itemize}

\end{description}


\subsection{Adadelta}
\label{\detokenize{deepLearning/08_optimizer:adadelta}}\begin{equation*}
\begin{split}g & \leftarrow &\ \nabla_{\theta} \mathcal{L}(\theta) &\  [\text{计算梯度}] \\
E[g^2] & \leftarrow &\ \gamma E[g^2] + (1 - \gamma) g \odot g  &\  [\text{累计平方梯度：指数衰减平均}] \\
RMS[g] & \leftarrow &\ \sqrt{E[g^2] + \epsilon} &\  [\text{梯度均方根}] \\
E[\Delta \theta^2] & \leftarrow &\ \gamma E[\Delta \theta^2] + (1 - \gamma) \Delta \theta \odot \Delta \theta  &\  [\text{平方参数增量平滑}] \\
RMS[\Delta \theta] & \leftarrow &\ \sqrt{E[\Delta \theta^2] + \epsilon} &\  [\text{参数增量均方根}] \\
\Delta \theta & \leftarrow &\  - \frac{RMS[\Delta \theta]}{RMS[g]} \odot g  &\ [\text{参数增量}] \\
\theta & \leftarrow &\  \theta + \Delta \theta &\ [\text{参数更新}]\end{split}
\end{equation*}
Adadelta 是 Adagrad 的改进。
\begin{description}
\item[{特点}] \leavevmode\begin{itemize}
\item {} 
使用指数衰减平均值，使得能够在找到凸碗状结构后快速收敛。

\item {} 
不用依赖于全局学习率，然而引入了新的超参：衰减系数 \(\gamma\) 。

\item {} 
训练初中期，加速效果很快。

\end{itemize}

\end{description}


\subsection{RMSprop}
\label{\detokenize{deepLearning/08_optimizer:rmsprop}}\begin{equation*}
\begin{split}g & \leftarrow &\ \mathcal{L}(\theta) &\  [\text{计算梯度}] \\
r & \leftarrow &\ \gamma r + (1 - \gamma) g \odot g &\  [\text{累计平方梯度：指数衰减平均}] \\
\Delta \theta & \leftarrow &\  - \frac{\eta}{\sqrt{r+\epsilon}} \odot g &\ [\text{参数增量}] \\
\theta & \leftarrow &\  \theta + \Delta \theta &\ [\text{参数更新}]\end{split}
\end{equation*}
RMSprop 趋于 Adagrad 和 Adadelta 之间。
\begin{description}
\item[{特点}] \leavevmode\begin{itemize}
\item {} 
使用指数衰减平均值，使得能够在找到凸碗状结构后快速收敛。

\item {} 
仍然依赖于全局学习率。

\end{itemize}

\end{description}


\subsection{Adam}
\label{\detokenize{deepLearning/08_optimizer:adam}}\begin{equation*}
\begin{split}g & \leftarrow &\ \mathcal{L}(\theta) &\  [\text{计算梯度}] \\
t & \leftarrow &\ t + 1 &\  [\text{迭代次数}] \\
m & \leftarrow &\ \beta_1 m + (1 - \beta_1) g &\  [\text{有偏一阶矩}] \\
n & \leftarrow &\ \beta_1 n + (1 - \beta_2) g \odot g &\  [\text{有偏二阶矩}] \\
\hat{m} & \leftarrow &\ \frac{m}{1 - \beta_1^t} &\  [\text{修正一阶矩}] \\
\hat{n} & \leftarrow &\ \frac{n}{1 - \beta_2^t} &\  [\text{修正二阶矩}] \\
\Delta \theta & \leftarrow &\  - \eta \frac{\hat{m}}{\sqrt{\hat{n}+\epsilon}} \odot g &\ [\text{参数增量}] \\
\theta & \leftarrow &\  \theta + \Delta \theta &\ [\text{参数更新}]\end{split}
\end{equation*}
相当于 RMSprop + Momentum。
\begin{description}
\item[{特点}] \leavevmode\begin{itemize}
\item {} 
结合了 Adagrad 善于处理稀疏梯度（不同的参数计算不同的自适应学习率）和 RMSprop 善于处理非平稳目标的优点。

\item {} 
经过矩修正后，每一次迭代的学习率都有确定范围，使得参数更新比较平稳。

\end{itemize}

\end{description}


\subsection{参考资料}
\label{\detokenize{deepLearning/08_optimizer:id3}}\begin{enumerate}
\item {} 
An overview of gradient descent optimization algorithms

\end{enumerate}
\begin{quote}

\sphinxurl{http://ruder.io/optimizing-gradient-descent/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
深度学习——优化器算法Optimizer详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://cloud.tencent.com/developer/article/1118673}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
深度学习——优化器算法Optimizer详解

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/guoyaohua/p/8542554.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
An overview of gradient descent optimization algorithms

\end{enumerate}
\begin{quote}

\sphinxurl{https://arxiv.org/pdf/1609.04747.pdf}
\end{quote}


\section{pytorch：add\_module}
\label{\detokenize{deepLearning/09_addModule:pytorch-add-module}}\label{\detokenize{deepLearning/09_addModule::doc}}

\subsection{add\_module}
\label{\detokenize{deepLearning/09_addModule:add-module}}
如果有一个元素是 \sphinxcode{\sphinxupquote{Module}} 的列表，直接赋值给一个模型的属性（attribute），并不会让给列表内的 Modules 立即成为模型的模块。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{torch.nn} \PYG{k+kn}{as} \PYG{n+nn}{nn}

\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{Module}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList} \PYG{o}{=} \PYG{p}{[}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{bias}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{bias}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{A}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{A(}
\PYG{g+go}{)}
\end{sphinxVerbatim}

简单地，可以使用 \sphinxcode{\sphinxupquote{nn.Sequential(*module\_list)}} 将列表转换成 \sphinxstylestrong{串联} 的模块。一方面，这样会使得模块的名字被默认地用数字命名；
另一方面，如果需要的不是串联结构，这样的做法行不通。

使用 \sphinxcode{\sphinxupquote{add\_module}} 可以自由地将列表的元素变成模型的模块。 \sphinxcode{\sphinxupquote{add\_module}} 建立了对 \sphinxcode{\sphinxupquote{Module}} 的引用，并不是添加了新的对象。
因此，对引用的修改会直接修改列表内的 \sphinxcode{\sphinxupquote{Module}} 。

加入之后，可以通过模型的名字来进行访问：\sphinxcode{\sphinxupquote{\_modules{[}name{]}}} 。\sphinxcode{\sphinxupquote{\_modules}} 是一个顺序字典（OrderedDict）。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{torch.nn} \PYG{k+kn}{as} \PYG{n+nn}{nn}

\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{Module}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList} \PYG{o}{=} \PYG{p}{[}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{bias}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{bias}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}module}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{layer\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}module}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{layer\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

        \PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}
        \PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}modules}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{layer\PYGZus{}0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}modules}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{layer\PYGZus{}0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}modules}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{layer\PYGZus{}0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}\PYG{o}{.}\PYG{n}{data} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{ones\PYGZus{}like}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}modules}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{layer\PYGZus{}0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}
        \PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}modules}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{layer\PYGZus{}0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{A}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} init}
\PYG{g+go}{Parameter containing:}
\PYG{g+go}{ 0.0244 \PYGZhy{}0.0521 \PYGZhy{}0.4013 \PYGZhy{}0.1229  0.0343}
\PYG{g+go}{[torch.FloatTensor of size 1x5]}

\PYG{g+go}{Parameter containing:}
\PYG{g+go}{ 0.0244 \PYGZhy{}0.0521 \PYGZhy{}0.4013 \PYGZhy{}0.1229  0.0343}
\PYG{g+go}{[torch.FloatTensor of size 1x5]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{a}
\PYG{g+go}{A(}
\PYG{g+go}{  (layer\PYGZus{}0): Linear(in\PYGZus{}features=5, out\PYGZus{}features=1, bias=False)}
\PYG{g+go}{  (layer\PYGZus{}1): Linear(in\PYGZus{}features=2, out\PYGZus{}features=1, bias=False)}
\PYG{g+go}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} forward}
\PYG{g+go}{Parameter containing:}
\PYG{g+go}{ 2.0244  1.9479  1.5987  1.8771  2.0343}
\PYG{g+go}{[torch.FloatTensor of size 1x5]}

\PYG{g+go}{Parameter containing:}
\PYG{g+go}{ 2.0244  1.9479  1.5987  1.8771  2.0343}
\PYG{g+go}{[torch.FloatTensor of size 1x5]}
\PYG{g+go}{\PYGZsh{}\PYGZsh{} 可以看到，上面的参数是同步更新的}
\end{sphinxVerbatim}


\subsection{attribute 索引}
\label{\detokenize{deepLearning/09_addModule:attribute}}
除了使用 \sphinxcode{\sphinxupquote{\_modules{[}name{]}}} 访问模块，还可以将 name 转换成属性（attribute）的索引，通过下标的形式访问。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{torch.nn} \PYG{k+kn}{as} \PYG{n+nn}{nn}

\PYG{k}{class} \PYG{n+nc}{AttrProxy}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Translates index lookups into attribute lookups.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{module}\PYG{p}{,} \PYG{n}{prefix}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{module} \PYG{o}{=} \PYG{n}{module}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{prefix} \PYG{o}{=} \PYG{n}{prefix}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{index}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{module}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{prefix} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{index}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{Module}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList} \PYG{o}{=} \PYG{p}{[}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{bias}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{bias}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}module}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{layer\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}module}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{layer\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer} \PYG{o}{=} \PYG{n}{AttrProxy}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{layer\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}
        \PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}\PYG{o}{.}\PYG{n}{data} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{ones\PYGZus{}like}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layerList}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}
        \PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}
        \PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layer}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{weight}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{A}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} init}
\PYG{g+go}{Parameter containing:}
\PYG{g+go}{\PYGZhy{}0.2655  0.1539 \PYGZhy{}0.2107  0.0740  0.1922}
\PYG{g+go}{[torch.FloatTensor of size 1x5]}

\PYG{g+go}{Parameter containing:}
\PYG{g+go}{\PYGZhy{}0.2655  0.1539 \PYGZhy{}0.2107  0.0740  0.1922}
\PYG{g+go}{[torch.FloatTensor of size 1x5]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} forward}
\PYG{g+go}{Parameter containing:}
\PYG{g+go}{ 1.7345  2.1539  1.7893  2.0740  2.1922}
\PYG{g+go}{[torch.FloatTensor of size 1x5]}

\PYG{g+go}{Parameter containing:}
\PYG{g+go}{ 1.7345  2.1539  1.7893  2.0740  2.1922}
\PYG{g+go}{[torch.FloatTensor of size 1x5]}

\PYG{g+go}{Parameter containing:}
\PYG{g+go}{ 0.0068 \PYGZhy{}0.1787}
\PYG{g+go}{[torch.FloatTensor of size 1x2]}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{deepLearning/09_addModule:id1}}\begin{enumerate}
\item {} 
pytorch documentation

\end{enumerate}
\begin{quote}

\sphinxurl{https://pytorch.org/docs/0.3.1/nn.html?highlight=add\_module\#torch.nn.Module.add\_module}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
List of nn.Module in a nn.Module

\end{enumerate}
\begin{quote}

\sphinxurl{https://discuss.pytorch.org/t/list-of-nn-module-in-a-nn-module/219}
\end{quote}


\chapter{数理与算法}
\label{\detokenize{mathematicsAlgorithm/index::doc}}\label{\detokenize{mathematicsAlgorithm/index:id1}}

\section{算法复杂度与主定理}
\label{\detokenize{mathematicsAlgorithm/01_complexity::doc}}\label{\detokenize{mathematicsAlgorithm/01_complexity:id1}}
递归算法的复杂性分析方法：代入法、递归树、主定理。这里只讨论主定理方法。

主定理方法应用于如下的递归形式：
\begin{equation*}
\begin{split}T(n) = aT(\frac{n}{b}) + f(n).\end{split}
\end{equation*}
其中，\(a \geqslant 1,\ b\geqslant 1\) ，\(f\) 是渐进正的。


\subsection{渐进分析}
\label{\detokenize{mathematicsAlgorithm/01_complexity:id2}}
假设对于所有 \(n\) ，满足 \(f(n) \geqslant 0,\ g(n) \geqslant 0\) 。
\begin{itemize}
\item {} 
渐进上界 \(\mathcal{O}\)
\begin{equation*}
\begin{split}\mathcal{O}(g(n)) = \{ f(n) | \text{存在正常数} c \text{和} n_0 \text{使得对所有} n \geqslant n_0 \text{有：} 0 \leqslant f(n) \leqslant cg(n) \}\end{split}
\end{equation*}
\item {} 
渐进下界 \(\Omega\)
\begin{equation*}
\begin{split}\Omega(g(n)) = \{ f(n) | \text{存在正常数} c \text{和} n_0 \text{使得对所有} n \geqslant n_0 \text{有：} 0 \leqslant cg(n) \leqslant f(n) \}\end{split}
\end{equation*}
\item {} 
渐进近界 \(\Theta\)
\begin{equation*}
\begin{split}\Theta(g(n)) = \{ f(n) | \text{存在正常数} c_1,\ c_2 \text{和} n_0 \text{使得对所有} n \geqslant n_0 \text{有：} c_1g(n) \leqslant f(n) \leqslant c_2g(n) \}\end{split}
\end{equation*}
\end{itemize}

定理：
\begin{equation*}
\begin{split}\Theta(g(n)) = \mathcal{O}(g(n)) \cap \Omega(g(n))\end{split}
\end{equation*}

\subsection{主定理}
\label{\detokenize{mathematicsAlgorithm/01_complexity:id3}}
需要比较 \(f(n)\) 和 \(n^{\log_b a}\) 。
\begin{itemize}
\item {} 
\(f(n) = \mathcal{O}(n^{\log_b a - \epsilon})\) ： \(f(n)\) 的增长速度比 \(n^{\log_b a}\) 慢一个 \(n^{\epsilon}\) 因子。
\begin{equation*}
\begin{split}T(n) = \Theta (n^{\log_b a})\end{split}
\end{equation*}
\item {} 
\(f(n) = \Theta (n^{\log_b a} \log^k n)\) ： \(f(n)\) 与 \(n^{\log_b a} \log^k n\) 具有相似的增长速度。
\begin{equation*}
\begin{split}T(n) = \Theta (n^{\log_b a} \log^{k+1} n)\end{split}
\end{equation*}
\item {} 
\(f(n) = \Omega (n^{\log_b a + \epsilon})\) ： \(f(n)\) 的增长速度比 \(n^{\log_b a}\) 快一个 \(n^{\epsilon}\) 因子，且满足 \(af(\frac{n}{b}) \leqslant cf(n),\ 0 < c < 1\) 。
\begin{equation*}
\begin{split}T(n) = \Theta (f(n))\end{split}
\end{equation*}
\end{itemize}

例子：
\begin{equation*}
\begin{split}T(n) = 4T(\frac{n}{2}) + n & \rightarrow &\ \epsilon = 1,\ T(n) = \Theta (n^2) \\
T(n) = 4T(\frac{n}{2}) + n^2 & \rightarrow &\ k=0,\ T(n) = \Theta (n^2 \log n) \\
T(n) = 4T(\frac{n}{2}) + n^3 & \rightarrow &\ \epsilon = 1,\ c=\frac{1}{2},\ T(n) = \Theta (n^3)\end{split}
\end{equation*}

\section{红黑树}
\label{\detokenize{mathematicsAlgorithm/02_redblackTree::doc}}\label{\detokenize{mathematicsAlgorithm/02_redblackTree:id1}}
R-B Tree，全称是 Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。
红黑树的每个节点上都有存储位表示节点的颜色，可以是红（Red）或黑（Black）。
\begin{description}
\item[{红黑树的特性}] \leavevmode\begin{itemize}
\item {} 
每个节点或者是黑色，或者是红色。

\item {} 
根节点是黑色。

\item {} 
每个叶子节点（NIL）是黑色。 {[}注意：这里的叶子节点是指为空(NIL或NULL)的叶子节点！{]}

\item {} 
如果一个节点是红色的，则它的子节点必须是黑色的。

\item {} 
从一个节点到该节点的子孙叶子节点的所有路径上包含相同数目的黑节点（black-height）。

\end{itemize}

\end{description}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{02_rbTree}.jpg}\hspace*{\fill}}

红黑树的应用比较广泛，主要是用它来存储有序的数据，查找、插入、删除操作的时间复杂度是 \(\mathcal{O}(\log n)\) ，效率非常之高。C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。

定理：一颗具有 \(n\) 个键值的红黑树，其高度 \(h\) 满足：
\begin{quote}
\begin{equation*}
\begin{split}h \leqslant 2 \log (n+1).\end{split}
\end{equation*}\end{quote}

另外，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是 \(\mathcal{O}(\log n)\) 。


\subsection{参考资料}
\label{\detokenize{mathematicsAlgorithm/02_redblackTree:id2}}\begin{enumerate}
\item {} 
红黑树(一)之 原理和算法详细介绍

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/skywang12345/p/3245399.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
30张图彻底理解红黑树

\end{enumerate}
\begin{quote}

\sphinxurl{http://developer.51cto.com/art/201901/590926.htm}
\end{quote}


\section{最短路径}
\label{\detokenize{mathematicsAlgorithm/03_shortestPath::doc}}\label{\detokenize{mathematicsAlgorithm/03_shortestPath:id1}}

\subsection{Bellman-Ford 算法}
\label{\detokenize{mathematicsAlgorithm/03_shortestPath:bellman-ford}}
时间复杂度 \(\mathcal{O}(VE)\) 其中顶点数 \(V\) ，边数 \(E\) 。如果不存在负圈（一条回路的代价和为负），那么每一条最短路径都不会经过同一个顶点两次，因此 while 循环最多执行 \(V-1\) 次。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{edge} \PYG{p}{\PYGZob{}}\PYG{k+kt}{int} \PYG{n}{from}\PYG{p}{,} \PYG{n}{to}\PYG{p}{,} \PYG{n}{cost}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{edge} \PYG{n}{es}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}E}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{d}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}V}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 最短距离}
\PYG{k+kt}{int} \PYG{n}{V}\PYG{p}{,} \PYG{n}{E}\PYG{p}{;} \PYG{c+c1}{// 顶点数，边数}

\PYG{c+c1}{// 从顶点 s 出发的最短距离（假设不存在负圈）}
\PYG{k+kt}{void} \PYG{n+nf}{shortest\PYGZus{}path}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{fill}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n}{d}\PYG{o}{+}\PYG{n}{V}\PYG{p}{,} \PYG{n}{INF}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{d}\PYG{p}{[}\PYG{n}{s}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{bool} \PYG{n}{update} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{E}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{edge} \PYG{n}{e} \PYG{o}{=} \PYG{n}{es}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{from}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{n}{INF} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{to}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{from}\PYG{p}{]} \PYG{o}{+} \PYG{n}{e}\PYG{p}{.}\PYG{n}{cost}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
        \PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{to}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{from}\PYG{p}{]} \PYG{o}{+} \PYG{n}{e}\PYG{p}{.}\PYG{n}{cost}\PYG{p}{;}
        \PYG{n}{update} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{update}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

检查负圈：如果第 \(V\) 次循环还有更新，则表明存在负圈，返回 true。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n+nf}{find\PYGZus{}negative\PYGZus{}loop}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{fill}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n}{d}\PYG{o}{+}\PYG{n}{V}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 初始化为 0，防止因为是 d[e.from] == INF 而停止更新}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{V}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{E}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{edge} \PYG{n}{e} \PYG{o}{=} \PYG{n}{es}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{to}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{from}\PYG{p}{]} \PYG{o}{+} \PYG{n}{e}\PYG{p}{.}\PYG{n}{cost}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
        \PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{to}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{from}\PYG{p}{]} \PYG{o}{+} \PYG{n}{e}\PYG{p}{.}\PYG{n}{cost}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{n}{V}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Dijkstra 算法}
\label{\detokenize{mathematicsAlgorithm/03_shortestPath:dijkstra}}
适合处理没有负边的情形。每一次循环，在尚未确定最短距离的顶点中，d{[}i{]} 最小的顶点就是下一个确定的顶点。但是如果存在负边，d{[}i{]} 在之后的更新中还会变小，因此算法失效。
\begin{itemize}
\item {} \begin{description}
\item[{方法一}] \leavevmode
直接使用邻接矩阵，时间复杂度 \(\mathcal{O}(V^2)\) 。

\end{description}

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{cost}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}V}\PYG{p}{]}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}V}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{d}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}V}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{used}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}V}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{V}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{dijkstra}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{fill}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n}{d}\PYG{o}{+}\PYG{n}{V}\PYG{p}{,} \PYG{n}{INF}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{d}\PYG{p}{[}\PYG{n}{s}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{n}{fill}\PYG{p}{(}\PYG{n}{used}\PYG{p}{,} \PYG{n}{used}\PYG{o}{+}\PYG{n}{V}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{v} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{u} \PYG{o}{\PYGZlt{}} \PYG{n}{V}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{used}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{v}\PYG{o}{=}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{d}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{n}{v} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{v} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{d}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{INF}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
    \PYG{c+c1}{// v == \PYGZhy{}1 表示所有顶点都找到了最短距离}
    \PYG{c+c1}{// d[v] == INF 表示后面所有的顶点都已经不可达，直接结束循环}

    \PYG{n}{used}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{u} \PYG{o}{\PYGZlt{}} \PYG{n}{V}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{d}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]} \PYG{o}{=} \PYG{n}{min}\PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{p}{,} \PYG{n}{d}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]} \PYG{o}{+} \PYG{n}{cost}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} \begin{description}
\item[{方法二}] \leavevmode
使用最小堆（优先队列），堆中元素个数为 \(\mathcal{O}(V)\)，出队（弹出最小值）的次数为 \(\mathcal{O}(E)\)，时间复杂度 \(\mathcal{O}(E \log V)\)。

\end{description}

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{edge} \PYG{p}{\PYGZob{}}\PYG{k+kt}{int} \PYG{n}{to}\PYG{p}{,} \PYG{n}{cost}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{typedef} \PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{P}\PYG{p}{;} \PYG{c+c1}{// first：最短距离，second：顶点}

\PYG{k+kt}{int} \PYG{n}{V}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edge}\PYG{o}{\PYGZgt{}} \PYG{n}{G}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}V}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 边}
\PYG{k+kt}{int} \PYG{n}{d}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}V}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{dijkstra}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{priority\PYGZus{}queue}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{greater}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{que}\PYG{p}{;}

  \PYG{n}{fill}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n}{d}\PYG{o}{+}\PYG{n}{V}\PYG{p}{,} \PYG{n}{INF}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{d}\PYG{p}{[}\PYG{n}{s}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

  \PYG{n}{que}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{P}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{o}{!}\PYG{n}{que}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{P} \PYG{n}{p} \PYG{o}{=} \PYG{n}{que}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{que}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{v} \PYG{o}{=} \PYG{n}{p}\PYG{p}{.}\PYG{n}{second}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{first}\PYG{p}{)} \PYG{k}{continue}\PYG{p}{;}

    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{G}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+} \PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{edge} \PYG{n}{e} \PYG{o}{=} \PYG{n}{G}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{to}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]} \PYG{o}{+} \PYG{n}{e}\PYG{p}{.}\PYG{n}{cost}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
        \PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{to}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]} \PYG{o}{+} \PYG{n}{e}\PYG{p}{.}\PYG{n}{cost}\PYG{p}{;}
        \PYG{n}{que}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{P}\PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{n}{e}\PYG{p}{.}\PYG{n}{to}\PYG{p}{]}\PYG{p}{,} \PYG{n}{e}\PYG{p}{.}\PYG{n}{to}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{实例}
\label{\detokenize{mathematicsAlgorithm/03_shortestPath:id2}}\begin{itemize}
\item {} 
耗时最短的路径：某些顶点有自行车，骑上自行车之后耗时减半。Hint：广度优先遍历，使用优先队列/堆，最早到达终点的一定是耗时最短路径。这里
需要设置两个全局数组，一个记录当前顶点有自行车的最短耗时，另一个记录当前顶点没有自行车的最短耗时。

\sphinxurl{https://www.nowcoder.com/practice/7689b595f3eb419b9e7816c4f45a400d?tpId=90\&tqId=30852\&tPage=4\&rp=4\&ru=/ta/2018test\&qru=/ta/2018test/question-ranking}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{heapq} \PYG{k+kn}{as} \PYG{n+nn}{hq}

\PYG{n}{n}\PYG{p}{,} \PYG{n}{m} \PYG{o}{=} \PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{stdin}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{edges} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{p}{]} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{begin}\PYG{p}{,} \PYG{n}{end}\PYG{p}{,} \PYG{n}{cost} \PYG{o}{=} \PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{stdin}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{begin} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{end} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{edges}\PYG{p}{[}\PYG{n}{begin}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{end}\PYG{p}{,} \PYG{n}{cost}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 无向边}
    \PYG{n}{edges}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{begin}\PYG{p}{,} \PYG{n}{cost}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{have\PYGZus{}bike} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb+bp}{False} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{k} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{stdin}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{v} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{stdin}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{v} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{have\PYGZus{}bike}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{True}

\PYG{n}{INF} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{inf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 无穷大}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 根据当前顶点是否有自行车，需要定义两个全局数组，存储当前最短耗时}
\PYG{n}{global\PYGZus{}cost} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n+nb+bp}{False}\PYG{p}{:} \PYG{p}{[}\PYG{n}{INF} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb+bp}{True}\PYG{p}{:} \PYG{p}{[}\PYG{n}{INF} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\PYG{n}{global\PYGZus{}cost}\PYG{p}{[}\PYG{n}{have\PYGZus{}bike}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{ans} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 堆元素：(cost, v, have\PYGZus{}bike)}
\PYG{n}{hq}\PYG{o}{.}\PYG{n}{heappush}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{have\PYGZus{}bike}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{while} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{v\PYGZus{}cost}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{v\PYGZus{}bike} \PYG{o}{=} \PYG{n}{hq}\PYG{o}{.}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{v} \PYG{o}{==} \PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{ans} \PYG{o}{=} \PYG{n}{v\PYGZus{}cost}
        \PYG{k}{break}
    \PYG{k}{for} \PYG{n}{u}\PYG{p}{,} \PYG{n}{uv\PYGZus{}cost} \PYG{o+ow}{in} \PYG{n}{edges}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{v\PYGZus{}bike}\PYG{p}{:}
            \PYG{n}{uv\PYGZus{}cost} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{u\PYGZus{}cost} \PYG{o}{=} \PYG{n}{v\PYGZus{}cost} \PYG{o}{+} \PYG{n}{uv\PYGZus{}cost}
        \PYG{n}{u\PYGZus{}bike} \PYG{o}{=} \PYG{n}{have\PYGZus{}bike}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]} \PYG{o+ow}{or} \PYG{n}{v\PYGZus{}bike}

        \PYG{k}{if} \PYG{n}{u\PYGZus{}cost} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{global\PYGZus{}cost}\PYG{p}{[}\PYG{n}{u\PYGZus{}bike}\PYG{p}{]}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{p}{:}
            \PYG{k}{continue}
        \PYG{n}{global\PYGZus{}cost}\PYG{p}{[}\PYG{n}{u\PYGZus{}bike}\PYG{p}{]}\PYG{p}{[}\PYG{n}{u}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u\PYGZus{}cost}
        \PYG{n}{hq}\PYG{o}{.}\PYG{n}{heappush}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{p}{(}\PYG{n}{u\PYGZus{}cost}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{u\PYGZus{}bike}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{ans}
\end{sphinxVerbatim}

\end{itemize}


\section{二叉树遍历}
\label{\detokenize{mathematicsAlgorithm/04_treeTraversal::doc}}\label{\detokenize{mathematicsAlgorithm/04_treeTraversal:id1}}

\subsection{定义}
\label{\detokenize{mathematicsAlgorithm/04_treeTraversal:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Definition for a binary tree node.}
\PYG{k}{struct} \PYG{n}{TreeNode}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{val}\PYG{p}{;}
   \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{left}\PYG{p}{;}
   \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{right}\PYG{p}{;}
   \PYG{n}{TreeNode}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)} \PYG{o}{:} \PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{left}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{,} \PYG{n}{right}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{先序遍历}
\label{\detokenize{mathematicsAlgorithm/04_treeTraversal:id3}}\begin{itemize}
\item {} 
递归

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{preOrder\PYGZus{}Recur}\PYG{p}{(}\PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{T}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{T}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k}{else}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{visite}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{preOrder\PYGZus{}Recur}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{left}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{preOrder\PYGZus{}Recur}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
非递归

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{preOrder\PYGZus{}NonRecur}\PYG{p}{(}\PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{T}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{stack}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{n}{stk}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{o}{!}\PYG{n}{stk}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{visite}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{stk}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{T} \PYG{o}{=} \PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{left}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!} \PYG{n}{stk}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{T} \PYG{o}{=} \PYG{n}{stk}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{stk}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{T} \PYG{o}{=} \PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{中序遍历}
\label{\detokenize{mathematicsAlgorithm/04_treeTraversal:id4}}\begin{itemize}
\item {} 
递归

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{inOrder\PYGZus{}Recur}\PYG{p}{(}\PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{T}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{T}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k}{else}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{inOrder\PYGZus{}Recur}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{left}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{visite}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{inOrder\PYGZus{}Recur}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
非递归

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{inOrder\PYGZus{}NonRecur}\PYG{p}{(}\PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{T}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{stack}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{n}{stk}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{o}{!}\PYG{n}{stk}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{stk}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{T} \PYG{o}{=} \PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{left}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!} \PYG{n}{stk}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{T} \PYG{o}{=} \PYG{n}{stk}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{stk}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{visite}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{T} \PYG{o}{=} \PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{后序遍历}
\label{\detokenize{mathematicsAlgorithm/04_treeTraversal:id5}}\begin{itemize}
\item {} 
递归

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{postOrder\PYGZus{}Recur}\PYG{p}{(}\PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{T}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{T}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k}{else}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{postOrder\PYGZus{}Recur}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{left}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{postOrder\PYGZus{}Recur}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{visite}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
非递归
\begin{itemize}
\item {} 
方法一：后序遍历顺序是：left - right - root；先序遍历顺序是：root - left - right。采用先序遍历的方式，用栈来存储节点（FILO），得到的是按 root - right - left 顺序遍历的临时结果；把临时结果逆序输出，就是后序遍历的结果。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{postOrder\PYGZus{}NonRecur}\PYG{p}{(}\PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{T}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{res}\PYG{p}{;}
  \PYG{n}{stack}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{n}{nodePtr}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)} \PYG{n}{nodePtr}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{o}{!} \PYG{n}{nodePtr}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{T} \PYG{o}{=} \PYG{n}{nodePtr}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{nodePtr}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{res}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{left}\PYG{p}{)} \PYG{n}{nodePtr}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{left}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{)} \PYG{n}{nodePtr}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{res}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{res}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
方法二：一个节点如果不存在右子树，则遍历完左子树之后可以直接访问该节点的值；如果存在右子树，用一个额外的栈（inNode）来临时保存该节点。访问完该节点的右子树之后，就从栈弹出该节点进行访问。

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{postOrder\PYGZus{}NonRecur}\PYG{p}{(}\PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{T}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{res}\PYG{p}{;}
  \PYG{n}{stack}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{n}{nodePtr}\PYG{p}{;}
  \PYG{n}{stack}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{n}{inNode}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{o}{!} \PYG{n}{nodePtr}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
      \PYG{k}{while}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
          \PYG{n}{nodePtr}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{p}{;}
          \PYG{n}{T} \PYG{o}{=} \PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{left}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{n}{T} \PYG{o}{=} \PYG{n}{nodePtr}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{nodePtr}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

      \PYG{k}{if}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
          \PYG{n}{inNode}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{p}{;}
          \PYG{n}{T} \PYG{o}{=} \PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{else}
      \PYG{p}{\PYGZob{}}
          \PYG{n}{res}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
          \PYG{k}{while}\PYG{p}{(}\PYG{o}{!}\PYG{n}{inNode}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{T} \PYG{o}{=}\PYG{o}{=} \PYG{n}{inNode}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{)}
          \PYG{c+c1}{// 访问完节点的右子树之后，就从栈弹出该节点进行访问}
          \PYG{p}{\PYGZob{}}
              \PYG{n}{res}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{inNode}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
              \PYG{n}{T} \PYG{o}{=} \PYG{n}{inNode}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
              \PYG{n}{inNode}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
          \PYG{p}{\PYGZcb{}}
          \PYG{n}{T} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}


\subsection{层次遍历}
\label{\detokenize{mathematicsAlgorithm/04_treeTraversal:id6}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{layerTraversal}\PYG{p}{(}\PYG{n}{TreeNode}\PYG{o}{*} \PYG{n}{T}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{queue}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{n}{Q}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)} \PYG{n}{Q}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{o}{!}\PYG{n}{Q}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{T} \PYG{o}{=} \PYG{n}{Q}\PYG{p}{.}\PYG{n}{front}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Q}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{visite}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{left}\PYG{p}{)} \PYG{n}{Q}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{left}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{)} \PYG{n}{Q}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{mathematicsAlgorithm/04_treeTraversal:id7}}\begin{enumerate}
\item {} 
二叉树后序遍历非递归的三种写法 (数据结构)

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/demian/p/8117888.html}
\end{quote}


\section{游戏与必胜策略}
\label{\detokenize{mathematicsAlgorithm/05_game::doc}}\label{\detokenize{mathematicsAlgorithm/05_game:id1}}

\subsection{硬币游戏}
\label{\detokenize{mathematicsAlgorithm/05_game:id2}}
\sphinxstylestrong{描述} ：有 \(x\) 枚硬币，A 和 B 两个人轮流取，每次所取的硬币数量要在 \(a_1, a_2,...,a_k\) 当中（其中包含 \(1\) ）。
A 先取，取走最后一枚硬币的一方获胜。当双方都采取最优策略，谁会获胜？

\sphinxstylestrong{策略} ：动态规划。考虑轮到 A 时，还剩下 \(j\) 枚硬币。当 \(j=0\) ，A 必败；如果存在 \(a_i\) ，使得 \(j - a_i\) 是必败态，则 \(j\) 就是必胜态；
如果对于所有的 \(a_i\) ， \(1 \leqslant i \leqslant k\) ，使得 \(j - a_i\) 都是必胜态，则 \(j\) 是必败态。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{X}\PYG{p}{,} \PYG{n}{K}\PYG{p}{,} \PYG{n}{A}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}K}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n}{win}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}X} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{solve}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{win}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{X}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{win}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{K}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{win}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{win}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{j} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{win}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Nim 游戏}
\label{\detokenize{mathematicsAlgorithm/05_game:nim}}
\sphinxstylestrong{描述} ：有 \(n\) 堆石子，每堆 \(a_i\) 颗石子。A 和 B 两个人轮流取，每次从石子堆中至少取走一颗。A 先取，最后取光所有石子的一方获胜。当双方都采取最优策略，谁会获胜？

\sphinxstylestrong{策略} ： \(a_1\ \oplus\ a_2\ \oplus\ ...\ \oplus\ a_n \ne 0\) （异或运算），则 A 必胜； \(a_1\ \oplus\ a_2\ \oplus\ ...\ \oplus\ a_n = 0\) ，则 A 必败。


\subsection{Grundy 数}
\label{\detokenize{mathematicsAlgorithm/05_game:grundy}}
\sphinxstylestrong{描述} ：有 \(n\) 堆硬币，每堆 \(x_i\) 枚硬币。A 和 B 两个人轮流取，每次所取的硬币数量要在 \(a_1, a_2,...,a_k\) 当中（其中包含 \(1\) ）。
A 先取，取走最后一枚硬币的一方获胜。当双方都采取最优策略，谁会获胜？

\sphinxstylestrong{策略} ：转换成 Nim， \(grundy(x_1)\ \oplus\ grundy(x_2)\ \oplus\ ...\ \oplus\ grundy(x_n) \ne 0\) 则 A 必胜，否则必败。
当前状态的 grundy 值表示：从该状态出发，一步可达状态的 grundy 值的集合之外的最小非负整数。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{N}\PYG{p}{,} \PYG{n}{K}\PYG{p}{,} \PYG{n}{X}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}N}\PYG{p}{]}\PYG{p}{,} \PYG{n}{A}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}K}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{grundy}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}X} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 全局数组，初始化为 0}

\PYG{k+kt}{void} \PYG{n+nf}{solve}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{grundy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

  \PYG{k+kt}{int} \PYG{n}{max\PYGZus{}x} \PYG{o}{=} \PYG{o}{*}\PYG{n}{max\PYGZus{}element}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{X}\PYG{o}{+}\PYG{n}{N}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{max\PYGZus{}x}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{set}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{s}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{K}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{)} \PYG{n}{s}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{grundy}\PYG{p}{[}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 一步可达状态的 grundy 值}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{int} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 集合之外的最小非负整数}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{g}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{n}{grundy}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{N}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)} \PYG{n}{res} \PYG{o}{\PYGZca{}}\PYG{o}{=} \PYG{n}{grundy}\PYG{p}{[}\PYG{n}{X}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{res} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A wins.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{k}{else} \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{B wins.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{蓄水池抽样}
\label{\detokenize{mathematicsAlgorithm/06_randomSample::doc}}\label{\detokenize{mathematicsAlgorithm/06_randomSample:id1}}
\sphinxstylestrong{问题描述} ：随机从一个数据流中选取1个或k个数，保证每个数被选中的概率是相同的。数据流的长度 \(n\) 未知或者是非常大。


\subsection{随机选择1个数}
\label{\detokenize{mathematicsAlgorithm/06_randomSample:id2}}
在数据流中，依次以概率 \(1\) 选择第一个数，以概率 \(\frac{1}{2}\) 选择第二个数（替换已选中的数），…，依此类推，以概率 \(\frac{1}{m}\) 选择第 m 个数（替换已选中的数）。
结束时（遍历完了整个数据流），每个数被选中的概率都是 \(\frac{1}{n}\) 。证明:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{第} \PYG{n}{m} \PYG{n}{个对象最终被选中的概率} \PYG{o}{=} \PYG{n}{选择第} \PYG{n}{m} \PYG{n}{个数的概率} \PYG{n}{x} \PYG{n}{后续所有数都不被选择的概率}
\end{sphinxVerbatim}

即
\begin{equation*}
\begin{split}P = \frac{1}{m} \times \left( \frac{m}{m+1} \times \frac{m+1}{m+2} \times \cdots \times \frac{n-1}{n} \right) = \frac{1}{n}.\end{split}
\end{equation*}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}utility\PYGZgt{} // swap}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}ctime\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdlib\PYGZgt{} // rand, srand}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{typedef} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{VecInt}\PYG{p}{;}
\PYG{k}{typedef} \PYG{n}{VecInt}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{Itr}\PYG{p}{;}
\PYG{k}{typedef} \PYG{n}{VecInt}\PYG{o}{:}\PYG{o}{:}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{CItr}\PYG{p}{;}

\PYG{c+c1}{// 等概率产生区间 [a, b] 之间的随机数}
\PYG{k+kt}{int} \PYG{n+nf}{RandInt}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{)} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{rand}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n+nf}{Sample}\PYG{p}{(}\PYG{k}{const} \PYG{n}{VecInt} \PYG{n}{data}\PYG{p}{,} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{result}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}

  \PYG{c+c1}{//srand(time(nullptr)); // 设置随机seed}

  \PYG{n}{CItr} \PYG{n}{it} \PYG{o}{=} \PYG{n}{data}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{result} \PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{m}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{it} \PYG{o}{=} \PYG{n}{data}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{data}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{m}\PYG{p}{,} \PYG{o}{+}\PYG{o}{+}\PYG{n}{it}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{ri} \PYG{o}{=} \PYG{n}{RandInt}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ri \PYGZlt{} 1 的概率为 1/(m+1)}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ri} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{result} \PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{随机选择k个数}
\label{\detokenize{mathematicsAlgorithm/06_randomSample:k}}
在数据流中，先把读到的前 k 个数放入“池”中，然后依次以概率 \(\frac{k}{k+1}\) 选择第 k+1 个数，以概率 \(\frac{k}{k+2}\) 选择第 k+2 个数，…，
以概率 \(\frac{k}{m}\) 选择第 m 个数（m \textgreater{} k）。如果某个数被选中，则 \sphinxstylestrong{随机替换} “池”中的一个数。最终每个数被选中的概率都为 \(\frac{k}{n}\) 。
证明:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
第 m 个对象最终被选中的概率 = 选择第 m 个数的概率 x（其后元素不被选择的概率 + 其后元素被选择的概率 x 不替换第 m 个数的概率）
\end{sphinxVerbatim}

即
\begin{equation*}
\begin{split}P & = &\ \frac{k}{m} \times \left[ \left( (1-\frac{k}{m+1}) + \frac{k}{m+1} \times \frac{k-1}{k}  \right) \times \left( (1-\frac{k}{m+2}) + \frac{k}{m+2} \times \frac{k-1}{k}  \right) \times \right. \\
  &   &\ \quad \left. \cdots \times \left( (1-\frac{k}{n}) + \frac{k}{n} \times \frac{k-1}{k}  \right) \right] \\
  & = &\ \frac{k}{m} \times \frac{m}{m+1} \times \frac{m+1}{m+2} \times \cdots \times \frac{n-1}{n} \\
  & = &\ \frac{k}{n}.\end{split}
\end{equation*}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}utility\PYGZgt{} // swap}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}ctime\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdlib\PYGZgt{} // rand, srand}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{typedef} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{VecInt}\PYG{p}{;}
\PYG{k}{typedef} \PYG{n}{VecInt}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{Itr}\PYG{p}{;}
\PYG{k}{typedef} \PYG{n}{VecInt}\PYG{o}{:}\PYG{o}{:}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{CItr}\PYG{p}{;}

\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{result}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// 等概率产生区间 [a, b] 之间的随机数}
\PYG{k+kt}{int} \PYG{n+nf}{RandInt}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{)} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{rand}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n+nf}{Sample}\PYG{p}{(}\PYG{k}{const} \PYG{n}{VecInt} \PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{)} \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}

  \PYG{c+c1}{//srand(time(nullptr)); // 设置随机seed}

  \PYG{n}{CItr} \PYG{n}{it} \PYG{o}{=} \PYG{n}{data}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{m} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{m}\PYG{p}{)} \PYG{n}{result}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}

  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{m} \PYG{o}{=} \PYG{n}{k}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{data}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{m}\PYG{p}{,} \PYG{o}{+}\PYG{o}{+}\PYG{n}{it}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{ri} \PYG{o}{=} \PYG{n}{RandInt}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ri} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{)} \PYG{n}{result}\PYG{p}{[}\PYG{n}{ri}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;} \PYG{c+c1}{// ri \PYGZlt{} k 的概率为 k/(m+1)}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{参考资料}
\label{\detokenize{mathematicsAlgorithm/06_randomSample:id3}}\begin{enumerate}
\item {} 
蓄水池抽样——《编程珠玑》读书笔记

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/huagong\_adu/article/details/7619665}
\end{quote}


\section{排序算法}
\label{\detokenize{mathematicsAlgorithm/07_sort::doc}}\label{\detokenize{mathematicsAlgorithm/07_sort:id1}}\begin{description}
\item[{比较排序}] \leavevmode\begin{itemize}
\item {} 
插入排序

\item {} 
选择排序

\item {} 
冒泡排序

\item {} 
快速排序

\item {} 
堆排序

\item {} 
归并排序

\item {} 
希尔排序

\end{itemize}

\item[{非比较排序}] \leavevmode\begin{itemize}
\item {} 
计数排序

\item {} 
桶排序

\item {} 
基数排序

\end{itemize}

\end{description}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=900\sphinxpxdimen]{{07_sort}.jpg}\hspace*{\fill}}
\begin{itemize}
\item {} 
\sphinxstylestrong{稳定性} ：键值相同的元素在排序之后仍能保持原来的相对顺序。

\item {} 
\sphinxstylestrong{空间复杂度} ：算法的额外内存开销，不包括输入所占空间。

\item {} 
\sphinxstylestrong{in-place} ：原位运算，直接在输入数组/链表的基础上修改。

\item {} 
\sphinxstylestrong{k} ：计数排序/桶排序，桶的个数；基数排序，关键字位数。

\end{itemize}


\subsection{插入排序}
\label{\detokenize{mathematicsAlgorithm/07_sort:id2}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{07_insertion}.gif}\hspace*{\fill}}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{insertionSort}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{len}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{arr}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
      \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{j}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{选择排序}
\label{\detokenize{mathematicsAlgorithm/07_sort:id3}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{07_selection}.gif}\hspace*{\fill}}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{selectionSort}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{len}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{arr}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{len} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)} \PYG{n}{k} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{冒泡排序}
\label{\detokenize{mathematicsAlgorithm/07_sort:id4}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{07_bubble}.gif}\hspace*{\fill}}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 下起泡：大的数下沉}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{bubbleSort}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{len}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{arr}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{len} \PYG{o}{\PYGZhy{}} \PYG{n}{i}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// 上起泡：小的数上浮}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{bubbleSort}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{len}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{arr}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{len} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{len} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{n}{i}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{快速排序}
\label{\detokenize{mathematicsAlgorithm/07_sort:id5}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{07_quick}.gif}\hspace*{\fill}}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 全闭区间 [start, end]}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{int} \PYG{n}{partion}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{start}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{end}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{T} \PYG{n}{p} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{start}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// pivot}
  \PYG{k+kt}{int} \PYG{n}{left} \PYG{o}{=} \PYG{n}{start}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{right} \PYG{o}{=} \PYG{n}{end} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{o}{+}\PYG{o}{+}\PYG{n}{left}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{p} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{left} \PYG{o}{\PYGZlt{}} \PYG{n}{end}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{right}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{left} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{right}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
    \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{left}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{right}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{start}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{right}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{right}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{quickSort}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{start}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{end}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{arr} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{start} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{end}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{p} \PYG{o}{=} \PYG{n}{partion}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{end}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{p} \PYG{o}{\PYGZgt{}} \PYG{n}{start} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{quickSort}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{p} \PYG{o}{\PYGZlt{}} \PYG{n}{end} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{quickSort}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{p}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{end}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

快速排序的空间复杂度是 \(\mathcal{O}(\log n)\) ，用于保存递归的函数栈，最差情况下为 \(\mathcal{O}(n)\) 。


\subsection{堆排序}
\label{\detokenize{mathematicsAlgorithm/07_sort:id6}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{07_heap}.gif}\hspace*{\fill}}

建堆，从 \sphinxstylestrong{最后一个非叶子节点} 开始调整，使其成为大顶堆；将堆顶元素放到数组末尾；最后一个叶子节点放到堆顶，重新调整堆；…。

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 调整堆。区间 [start, end]，除了 start 不满足大顶堆的性质之外，其他节点都满足。}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{heapAdjust}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{start}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{end}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{T} \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{start}\PYG{p}{]}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{start}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{end}\PYG{p}{;} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{end}\PYG{p}{)} \PYG{n}{i} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{?} \PYG{n+nl}{i}\PYG{p}{:} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{tmp}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
    \PYG{n}{arr}\PYG{p}{[}\PYG{n}{start}\PYG{p}{]} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{start} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{n}{arr}\PYG{p}{[}\PYG{n}{start}\PYG{p}{]} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// 某节点下标为 i，则其左右子节点的下标分别为：2*i+1，2*i+2 。}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{heapSort}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{len}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{arr}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{p}{(}\PYG{n}{len}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{k}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{n}{heapAdjust}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{k}\PYG{p}{,} \PYG{n}{len}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{len}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{heapAdjust}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{len}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

初始建立大顶堆的时间复杂度为 \(\mathcal{O}(n \log n)\) ；每次取出堆的最大元素并重新调整堆也要用 \(\mathcal{O}(\log n)\) 时间。


\subsection{归并排序}
\label{\detokenize{mathematicsAlgorithm/07_sort:id7}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{07_merge}.gif}\hspace*{\fill}}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 把有序表 from: [start, mid] 和 from: [mid+1, end] 合并到临时数组 to: [start, end]。}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{merge}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{from}\PYG{p}{,} \PYG{n}{T}\PYG{o}{*} \PYG{n}{to}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{start}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{mid}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{end}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{k}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{n}{start}\PYG{p}{,} \PYG{n}{j} \PYG{o}{=} \PYG{n}{mid}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{k} \PYG{o}{=} \PYG{n}{start}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{mid} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{end}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{from}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{from}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)} \PYG{n}{to}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{from}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{else} \PYG{n}{to}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{from}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{for}\PYG{p}{(}\PYG{p}{;}\PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{mid}\PYG{p}{;} \PYG{p}{)} \PYG{n}{to}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{from}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{p}{;}\PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{end}\PYG{p}{;} \PYG{p}{)} \PYG{n}{to}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{from}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{mergeSort}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{n}{T}\PYG{o}{*} \PYG{n}{atmp}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{start}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{end}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{start} \PYG{o}{=}\PYG{o}{=} \PYG{n}{end}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{mid} \PYG{o}{=} \PYG{n}{start} \PYG{o}{+} \PYG{p}{(}\PYG{n}{end} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{;}
  \PYG{n}{mergeSort}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{atmp}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{mid}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{mergeSort}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{atmp}\PYG{p}{,} \PYG{n}{mid}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{end}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{merge}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{atmp}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{mid}\PYG{p}{,} \PYG{n}{end}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{start}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{end}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{atmp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{mergeSort}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{start}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{end}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{arr}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{n}{T}\PYG{o}{*} \PYG{n}{atmp} \PYG{o}{=} \PYG{k}{new} \PYG{n}{T}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}LEN}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 申请临时空间}
  \PYG{n}{fill}\PYG{p}{(}\PYG{n}{atmp}\PYG{p}{,} \PYG{n}{atmp} \PYG{o}{+} \PYG{n}{MAX\PYGZus{}LEN}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{mergeSort}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{atmp}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{end}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{atmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{希尔排序}
\label{\detokenize{mathematicsAlgorithm/07_sort:id8}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{07_shell}.gif}\hspace*{\fill}}

缩小增量排序法：对于每一个增量（步长），利用插入排序方法进行排序。如果序列是基本有序的，使用直接插入排序效率非常高。

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{insertSort}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{start}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{gap}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{len}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{start} \PYG{o}{+} \PYG{n}{gap}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{n}{gap}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{n}{gap}\PYG{p}{]}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{n}{gap}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{j} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{gap}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{shellSort}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{len}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{arr}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{gap} \PYG{o}{=} \PYG{n}{len}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{gap} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{gap} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{start} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{start} \PYG{o}{\PYGZlt{}} \PYG{n}{gap}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+} \PYG{n}{start}\PYG{p}{)} \PYG{n}{insertSort}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{gap}\PYG{p}{,} \PYG{n}{len}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{计数排序}
\label{\detokenize{mathematicsAlgorithm/07_sort:id9}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{07_counting}.gif}\hspace*{\fill}}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 空间复杂度 O(n+k)}
\PYG{k+kt}{void} \PYG{n+nf}{Sort}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{maxVal}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{len} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{len} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}

  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{count}\PYG{p}{(}\PYG{n}{maxVal} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{for} \PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{x} \PYG{p}{:} \PYG{n}{arr}\PYG{p}{)} \PYG{n}{count}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}

  \PYG{n}{partial\PYGZus{}sum}\PYG{p}{(}\PYG{n}{count}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{count}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{count}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{len} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{val} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{arr}\PYG{p}{[}\PYG{n}{count}\PYG{p}{[}\PYG{n}{val}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{val}\PYG{p}{;}
    \PYG{n}{count}\PYG{p}{[}\PYG{n}{val}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// 空间复杂度 O(k)}
\PYG{k+kt}{void} \PYG{n+nf}{Sort}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{maxVal}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{len} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{len} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}

  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{count}\PYG{p}{(}\PYG{n}{maxVal} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{for} \PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{x} \PYG{p}{:} \PYG{n}{arr}\PYG{p}{)} \PYG{n}{count}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}

  \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{maxVal}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{x}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{while} \PYG{p}{(}\PYG{n}{count}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{桶排序}
\label{\detokenize{mathematicsAlgorithm/07_sort:id10}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{07_bucket}.gif}\hspace*{\fill}}

参考：\sphinxurl{https://blog.csdn.net/developer1024/article/details/79770240}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}iterator\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{BUCKET\PYGZus{}NUM} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{ListNode}
\PYG{p}{\PYGZob{}}
    \PYG{k}{explicit} \PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{:}\PYG{n}{mData}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mNext}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{n}{ListNode}\PYG{o}{*} \PYG{n}{mNext}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{mData}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{ListNode}\PYG{o}{*} \PYG{n+nf}{insert}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*} \PYG{n}{head}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{val}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{ListNode} \PYG{n}{dummyNode}\PYG{p}{;}
    \PYG{n}{ListNode} \PYG{o}{*}\PYG{n}{newNode} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ListNode}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ListNode} \PYG{o}{*}\PYG{n}{pre}\PYG{p}{,}\PYG{o}{*}\PYG{n}{curr}\PYG{p}{;}
    \PYG{n}{dummyNode}\PYG{p}{.}\PYG{n}{mNext} \PYG{o}{=} \PYG{n}{head}\PYG{p}{;}
    \PYG{n}{pre} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{dummyNode}\PYG{p}{;}
    \PYG{n}{curr} \PYG{o}{=} \PYG{n}{head}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{o}{!}\PYG{o}{=}\PYG{n}{curr} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{curr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mData}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{val}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{pre} \PYG{o}{=} \PYG{n}{curr}\PYG{p}{;}
        \PYG{n}{curr} \PYG{o}{=} \PYG{n}{curr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{newNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext} \PYG{o}{=} \PYG{n}{curr}\PYG{p}{;}
    \PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext} \PYG{o}{=} \PYG{n}{newNode}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{dummyNode}\PYG{p}{.}\PYG{n}{mNext}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{ListNode}\PYG{o}{*} \PYG{n+nf}{Merge}\PYG{p}{(}\PYG{n}{ListNode} \PYG{o}{*}\PYG{n}{head1}\PYG{p}{,}\PYG{n}{ListNode} \PYG{o}{*}\PYG{n}{head2}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{ListNode} \PYG{n}{dummyNode}\PYG{p}{;}
    \PYG{n}{ListNode} \PYG{o}{*}\PYG{n}{dummy} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{dummyNode}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{o}{!}\PYG{o}{=}\PYG{n}{head1} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n+nb}{NULL}\PYG{o}{!}\PYG{o}{=}\PYG{n}{head2}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{head1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mData} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{head2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mData}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{dummy}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext} \PYG{o}{=} \PYG{n}{head1}\PYG{p}{;}
            \PYG{n}{head1} \PYG{o}{=} \PYG{n}{head1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{dummy}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext} \PYG{o}{=} \PYG{n}{head2}\PYG{p}{;}
            \PYG{n}{head2} \PYG{o}{=} \PYG{n}{head2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{dummy} \PYG{o}{=} \PYG{n}{dummy}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{o}{!}\PYG{o}{=}\PYG{n}{head1}\PYG{p}{)} \PYG{n}{dummy}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext} \PYG{o}{=} \PYG{n}{head1}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{o}{!}\PYG{o}{=}\PYG{n}{head2}\PYG{p}{)} \PYG{n}{dummy}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext} \PYG{o}{=} \PYG{n}{head2}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{dummyNode}\PYG{p}{.}\PYG{n}{mNext}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n+nf}{BucketSort}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{ListNode}\PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{n}{buckets}\PYG{p}{(}\PYG{n}{BUCKET\PYGZus{}NUM}\PYG{p}{,}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// 插入桶中}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{n}\PYG{p}{;}\PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{index} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{n}{BUCKET\PYGZus{}NUM}\PYG{p}{;}
        \PYG{n}{ListNode} \PYG{o}{*}\PYG{n}{head} \PYG{o}{=} \PYG{n}{buckets}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{index}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{buckets}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{index}\PYG{p}{)} \PYG{o}{=} \PYG{n}{insert}\PYG{p}{(}\PYG{n}{head}\PYG{p}{,}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// 合并各个桶中的排序结果}
    \PYG{n}{ListNode} \PYG{o}{*}\PYG{n}{head} \PYG{o}{=} \PYG{n}{buckets}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{BUCKET\PYGZus{}NUM}\PYG{p}{;}\PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{head} \PYG{o}{=} \PYG{n}{Merge}\PYG{p}{(}\PYG{n}{head}\PYG{p}{,}\PYG{n}{buckets}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// 结果输出到 arr}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{n}\PYG{p}{;}\PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mData}\PYG{p}{;}
        \PYG{n}{head} \PYG{o}{=} \PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNext}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}
\begin{description}
\item[{时间复杂度}] \leavevmode
对于 \(n\) 个待排数据， \(k\) 个桶，平均每个桶 \(\frac{n}{k}\) 个数据，桶内排序复杂度为 \(\mathcal{O}(\frac{n}{k} \log \frac{n}{k})\) ，总体平均时间复杂度为：
\begin{equation*}
\begin{split}\mathcal{O}(n) + \mathcal{O}(k * \frac{n}{k} \log \frac{n}{k}) = \mathcal{O}(n + n(\log n - \log k)).\end{split}
\end{equation*}
当 \(n = k\) ，每个桶只有一个数据，时间复杂度为 \(\mathcal{O}(n)\) 。

\end{description}


\subsection{基数排序}
\label{\detokenize{mathematicsAlgorithm/07_sort:id11}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{07_radix}.gif}\hspace*{\fill}}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// digit 表示关键字位数}
\PYG{k+kt}{void} \PYG{n+nf}{radixSort}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{len}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{digit}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{arr}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}

  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{radix}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{n}{digit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{idx} \PYG{o}{=} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{/} \PYG{n}{order}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{n}{radix}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{radix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{radix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)} \PYG{n}{radix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{pop\PYGZus{}back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{order} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{总结}
\label{\detokenize{mathematicsAlgorithm/07_sort:id12}}\begin{itemize}
\item {} 
从平均时间来看，\sphinxstylestrong{快速排序} 是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。

\item {} 
在 \(n\) 较大时 \sphinxstylestrong{归并排序} 使用时间较少，但使用辅助空间较多。

\item {} 
当序列基本有序或 \(n\) 较小时，直接 \sphinxstylestrong{插入排序} 是好的方法，因此常将它和其他的排序方法（如快速排序、归并排序等）结合在一起使用。

\item {} 
\sphinxstylestrong{选择排序} 、 \sphinxstylestrong{堆排序} 、 \sphinxstylestrong{快速排序} 、 \sphinxstylestrong{希尔排序} 是不稳定的排序方法。

\item {} 
\sphinxstylestrong{基数排序} 适合于 \(n\) 较大而关键字位数较少的情况。

\item {} 
如果我们只希望找到数组中前 \(k\) 大的元素，且 \(k\) 很小，则 \sphinxstylestrong{堆排序} 速度较快。

\end{itemize}


\subsection{参考资料}
\label{\detokenize{mathematicsAlgorithm/07_sort:id13}}\begin{enumerate}
\item {} 
十大经典排序算法（动图演示）

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/onepixel/p/7674659.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
十大经典排序算法

\end{enumerate}
\begin{quote}

\sphinxurl{https://zhuanlan.zhihu.com/p/41923298}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
10大经典排序算法动图演示

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/zhuqi7758258/articles/10643262.html}
\end{quote}


\section{动态规划}
\label{\detokenize{mathematicsAlgorithm/08_dynamicProgramming::doc}}\label{\detokenize{mathematicsAlgorithm/08_dynamicProgramming:id1}}

\subsection{矩阵连乘}
\label{\detokenize{mathematicsAlgorithm/08_dynamicProgramming:id2}}
矩阵连乘，通过调整加括号的方式，使得乘法元素次数最少。设矩阵链 \(A[0:n-1]\) ， \(A[i]\) 的维度为 \(p_i \times p_{i+1}\) 。 \(m[i][j]\) 是计算 \(A[i:j],\ 1 \leqslant i \leqslant j \leqslant n\) 所需的最少乘法次数。

递归关系：
$$
m[i][j] =
\begin{cases}
   min \{ m[i][k] + m[k+1][j] + p_i \times p_{k+1} \times p_{j+1} \},\ i \leqslant k < j & & i \ne j \\
   0 & &  i = j
\end{cases}

$$
\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// s[i][j] 记录 A[i:j] 的划分点 k}
\PYG{k+kt}{void} \PYG{n+nf}{matrixChain}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{p}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{m}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{n}{m}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{gap} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{gap} \PYG{o}{\PYGZlt{}} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{gap}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+} \PYG{n}{gap} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{n}{gap}\PYG{p}{;}
      \PYG{n}{m}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{m}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+} \PYG{n}{p}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{p}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{p}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// k = i}
      \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
      \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{cost} \PYG{o}{=} \PYG{n}{m}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{+} \PYG{n}{m}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+} \PYG{n}{p}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{p}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{p}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{cost} \PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
          \PYG{n}{m}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{cost}\PYG{p}{;}
          \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{k}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{最长公共子序列}
\label{\detokenize{mathematicsAlgorithm/08_dynamicProgramming:id3}}
用 \(c[i][j]\) 记录序列 \(X[0:i-1]\) （前 \(i\) 个字符）和 \(Y[0:j-1]\) （前 \(j\) 个字符）的最长公共子序列的长度。

递归关系：
$$
c[0][j] = 0,\ 0 \leqslant j \leqslant n \\
c[i][0] = 0,\ 0 \leqslant i \leqslant m
$$

$$
c[i][j] =
\begin{cases}
   c[i-1][j-1] + 1 & & {i,j > 0;\ X[i-1] = Y[j-1]} \\
   max\{ c[i-1][j], c[i][j-1] \} & & {i,j > 0;\ X[i-1] \ne Y[j-1]}
\end{cases}
$$
\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{lcsLength}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{m}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{c}\PYG{p}{)} \PYG{c+c1}{// c 对应的实参为 int *c[]}
\PYG{p}{\PYGZob{}}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{m}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{m}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
      \PYG{k}{else} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/* 记录并构造公共子序列 */}

\PYG{k+kt}{void} \PYG{n+nf}{lcsLength}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{m}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{c}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{m}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{m}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
        \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{else}
      \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
          \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
          \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
          \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
          \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{lcs}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{m}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{*}\PYG{o}{*} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{m} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{n} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{lcs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{x}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{lcs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{else} \PYG{n}{lcs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{m}\PYG{p}{,} \PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{最长上升子序列}
\label{\detokenize{mathematicsAlgorithm/08_dynamicProgramming:id4}}\begin{itemize}
\item {} 
方法一

设 \(dp[i]\) 是以 \(a[i]\) 结尾的最长上升子序列的长度。

递归关系：
\begin{equation*}
\begin{split}dp[i] = max\{ 1, dp[j]+1\ |\ j < i\ \text{且}\ a[j] < a[i]\}.\end{split}
\end{equation*}
\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/* O(n\PYGZca{}2) in time.*/}
\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}N}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}N}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{solve}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+} \PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{res}\PYG{p}{,} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
方法二

设 \(dp[i]\) 是长度为 \(i+1\) 的上升子序列中末尾元素的最小值。

\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/* https://leetcode.com/problems/longest\PYGZhy{}increasing\PYGZhy{}subsequence/ */}
\PYG{c+cm}{/* O(nlogn) in time.*/}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{int} \PYG{n}{lengthOfLIS}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{inf} \PYG{o}{=} \PYG{n}{INT\PYGZus{}MAX}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{len} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{dp} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{[}\PYG{n}{len}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{fill}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{inf}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{length} \PYG{o}{=} \PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{+}\PYG{n}{len}\PYG{p}{,} \PYG{n}{inf}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{dp}\PYG{p}{;}
    \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{dp}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{length}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{最大子段和}
\label{\detokenize{mathematicsAlgorithm/08_dynamicProgramming:id5}}
设 \(dp[i]\) 是以 \(a[i]\) 结尾的最大子段和。

递归关系：
\begin{equation*}
\begin{split}dp[i] = max\{ dp[i-1] + a[i], a[i] \},\ 1 \leqslant i < n.\end{split}
\end{equation*}
\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{maxSum}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{dp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dp} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{dp} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{else} \PYG{n}{dp} \PYG{o}{=} \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{res}\PYG{p}{,} \PYG{n}{dp}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{0-1背包问题}
\label{\detokenize{mathematicsAlgorithm/08_dynamicProgramming:id6}}
设 \(dp[i][j]\) 表示从 \(0\) 到 \(i-1\) 这前 \(i\) 个物品中选出总重量不超过 \(j\) 的物品时总价值的最大值。

递归关系：
$$
dp[0][j] = 0,\ 0 \leqslant j \leqslant W
$$

$$
dp[i+1][j] =
\begin{cases}
   dp[i][j] & & j < w[i] \\
   max\{ dp[i][j], dp[i][j-w[i]] + v[i] \} & &  j \geqslant w[i]
\end{cases}
$$
\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,} \PYG{n}{W}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{w}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}N}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}N}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}N}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}W}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n+nf}{solve}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{W}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
      \PYG{k}{else} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{n}{w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]} \PYG{o}{+} \PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{n}{W}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{实例}
\label{\detokenize{mathematicsAlgorithm/08_dynamicProgramming:id7}}\begin{itemize}
\item {} 
有面值1,5,10,20,50,100的人民币，求问10000有多少种组成方法？

\sphinxurl{https://www.zhihu.com/question/315108379}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{n}{money} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{dp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int64}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} dp[m,n]: first m currency values, make money n}
\PYG{n}{dp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{dp}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{money}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{dp}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{n}{money}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]} \PYG{o}{+} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n}\PYG{p}{]}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{dp}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{dp}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{p}{]}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 作者：李泽政}
\PYG{c+c1}{// 链接：https://www.zhihu.com/question/315108379/answer/620254961}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}cstdio\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define maxn 10001}
\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{maxn}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{num}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{maxn}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// 作者把 1 从 num[] 中去掉了，转化到初始化中。全用 1 元只能得到一种组成方案}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{k}{for}\PYG{p}{(}\PYG{n}{j} \PYG{o}{=} \PYG{n}{num}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{maxn}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{n}{dp}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{n}{num}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}lld}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{maxn} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
如何用最少的次数测出鸡蛋会在哪一层摔碎？

\sphinxurl{https://www.zhihu.com/question/19690210}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 作者：知乎用户}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 链接：https://www.zhihu.com/question/19690210/answer/18079633}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} f(n,m)：n 层楼，m 个鸡蛋所需最少次数}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} f(0, m) = 0}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} f(n, 1) = n}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} f(n, m) = min\PYGZob{}max\PYGZob{}f(k\PYGZhy{}1, m\PYGZhy{}1), f(n\PYGZhy{}k, m)\PYGZcb{}\PYGZcb{} + 1, 1 \PYGZlt{}= k \PYGZlt{}= n。 k 表示尝试在第 k 层扔下鸡蛋。}

\PYG{k+kn}{import} \PYG{n+nn}{functools}
\PYG{n+nd}{@functools.lru\PYGZus{}cache}\PYG{p}{(}\PYG{n}{maxsize}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{n} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mi}{0}
    \PYG{k}{if} \PYG{n}{m} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{n}

    \PYG{n}{ans} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{max}\PYG{p}{(}\PYG{p}{[}\PYG{n}{f}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{f}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{n}{i}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{ans}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 14}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 20}
\end{sphinxVerbatim}

\end{itemize}


\section{回溯}
\label{\detokenize{mathematicsAlgorithm/09_backtrack::doc}}\label{\detokenize{mathematicsAlgorithm/09_backtrack:id1}}
总体思路是深度优先遍历（DFS）。


\subsection{子集树}
\label{\detokenize{mathematicsAlgorithm/09_backtrack:id2}}
子集树大小为 \(\mathcal{O}(m^n)\) ，\(m\) 是树的分支个数（ \(m\) 叉树），\(n\) 是树的深度。

算法描述：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{Backtrack}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{t}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{n}\PYG{p}{)} \PYG{n}{Output}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{else}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{x}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{Constrain}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{n}{and} \PYG{n}{Bound}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)} \PYG{n}{Backtrack}\PYG{p}{(}\PYG{n}{t}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{排列树}
\label{\detokenize{mathematicsAlgorithm/09_backtrack:id3}}
排列树大小为 \(\mathcal{O}(n!)\) 。

算法描述：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{Backtrack}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{t}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{n}\PYG{p}{)} \PYG{n}{Output}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{else}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{t}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{Swap}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{Constrain}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{n}{and} \PYG{n}{Bound}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)} \PYG{n}{Backtrack}\PYG{p}{(}\PYG{n}{t}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Swap}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{0-1背包问题}
\label{\detokenize{mathematicsAlgorithm/09_backtrack:id4}}
算法描述：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{Backtrack}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{t}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{n}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{best\PYGZus{}value} \PYG{o}{=} \PYG{n}{curr\PYGZus{}value}\PYG{p}{;}
    \PYG{n}{bext\PYGZus{}x} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{k}{return}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{curr\PYGZus{}weight} \PYG{o}{+} \PYG{n}{w}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{W}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{x}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
      \PYG{n}{curr\PYGZus{}weight} \PYG{o}{+}\PYG{o}{=} \PYG{n}{w}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 进入左子树}
      \PYG{n}{curr\PYGZus{}value} \PYG{o}{+}\PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{Backtrack}\PYG{p}{(}\PYG{n}{t}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

      \PYG{n}{curr\PYGZus{}weight} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{w}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// 状态恢复}
      \PYG{n}{curr\PYGZus{}value} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{x}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{Backtrack}\PYG{p}{(}\PYG{n}{t}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 进入右子树}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{实例}
\label{\detokenize{mathematicsAlgorithm/09_backtrack:id5}}\begin{itemize}
\item {} 
全排列（含重复元素）。Hint：在交换第 \(i\) 个元素与第 \(j\) 个元素之前，要求数组的 \([i, j)\) 区间中的元素没有与第 \(j\) 个元素重复。
\begin{quote}

\sphinxurl{https://blog.csdn.net/so\_geili/article/details/71078945}
\end{quote}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// 不同排列的个数}

\PYG{c+c1}{//检查[from,to)之间的元素和第to号元素是否相同}
\PYG{k+kt}{bool} \PYG{n+nf}{isRepeat}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{A}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{from}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{to}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{from}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{to}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{to}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{permutation}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{*} \PYG{n}{A}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{t}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{t} \PYG{o}{=}\PYG{o}{=} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cnt}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{Output}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{t}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{isRepeat}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{swap}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{,} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{permutation}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{t}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{swap}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{,} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
Next Permutation 下一个排列。Hint：从后往前先找到第一个开始下降的数字 \(x\) （下标 \(i\) ），再从后往前找到第一个比 \(x\) 大的数 \(y\) （下标 \(j\) ）；交换 \(x\) 和 \(y\) ；翻转区间 \([i+1, end]\) 。
\begin{quote}

\sphinxurl{https://www.cnblogs.com/grandyang/p/4428207.html}
\end{quote}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{void} \PYG{n}{nextPermutation}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{num}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{n} \PYG{o}{=} \PYG{n}{num}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{num}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{num}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{for} \PYG{p}{(}\PYG{n}{j} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{n}{i}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if} \PYG{p}{(}\PYG{n}{num}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{num}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{swap}\PYG{p}{(}\PYG{n}{num}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{num}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{num}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{num}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{return}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{num}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{num}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 当前排列是最大的排列，则翻转为最小的排列}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Word search 查找字符串路径。
\begin{quote}

\sphinxurl{https://leetcode.com/problems/word-search/}
\end{quote}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{bool} \PYG{n}{find\PYGZus{}path}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{board}\PYG{p}{,} \PYG{n}{string} \PYG{n}{word}\PYG{p}{,} \PYG{k+kt}{bool}\PYG{o}{*}\PYG{o}{*} \PYG{n}{flag}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{k} \PYG{o}{=}\PYG{o}{=} \PYG{n}{word}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{t} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{t}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{tx} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{n}{mv}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{ty} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{n}{mv}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{flag}\PYG{p}{[}\PYG{n}{tx}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{ty}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{board}\PYG{p}{[}\PYG{n}{tx}\PYG{p}{]}\PYG{p}{[}\PYG{n}{ty}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{word}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{flag}\PYG{p}{[}\PYG{n}{tx}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{ty}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;} \PYG{c+c1}{// 设置 flag}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{find\PYGZus{}path}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{word}\PYG{p}{,} \PYG{n}{flag}\PYG{p}{,} \PYG{n}{tx}\PYG{p}{,} \PYG{n}{ty}\PYG{p}{,} \PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)} \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{n}{flag}\PYG{p}{[}\PYG{n}{tx}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{ty}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;} \PYG{c+c1}{// flag 还原}
            \PYG{p}{\PYGZcb{}}

        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{bool} \PYG{n}{exist}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{board}\PYG{p}{,} \PYG{n}{string} \PYG{n}{word}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{word}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{board}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{M} \PYG{o}{=} \PYG{n}{board}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{N} \PYG{o}{=} \PYG{n}{board}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{bool}\PYG{o}{*}\PYG{o}{*} \PYG{n}{flag} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{bool}\PYG{o}{*}\PYG{p}{[}\PYG{n}{M}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{m} \PYG{o}{\PYGZlt{}} \PYG{n}{M}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{m}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{flag}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{bool}\PYG{p}{[}\PYG{n}{N}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{N}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{m}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{m}\PYG{o}{=}\PYG{o}{=}\PYG{n}{M}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{n}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{n}\PYG{o}{=}\PYG{o}{=}\PYG{n}{N}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{flag}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{k}{else} \PYG{n}{flag}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{bool} \PYG{n}{EXIST} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{M}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{N}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{board}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{flag}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;} \PYG{c+c1}{// 注意： flag 的下标与 board 相差 1}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{find\PYGZus{}path}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{word}\PYG{p}{,} \PYG{n}{flag}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{EXIST} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{// 跳出第二重循环}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{flag}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;} \PYG{c+c1}{// flag 还原}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{EXIST}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{// 跳出第一重循环}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{m} \PYG{o}{\PYGZlt{}} \PYG{n}{M}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{m}\PYG{p}{)} \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{flag}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{flag}\PYG{p}{;}

        \PYG{k}{return} \PYG{n}{EXIST}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k}{static} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{mv}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{Solution}\PYG{o}{:}\PYG{o}{:}\PYG{n}{mv}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\chapter{计算机网络}
\label{\detokenize{computerNetwork/index::doc}}\label{\detokenize{computerNetwork/index:id1}}

\section{计算机网络体系结构}
\label{\detokenize{computerNetwork/01_architechture::doc}}\label{\detokenize{computerNetwork/01_architechture:id1}}

\subsection{不同的体系结构}
\label{\detokenize{computerNetwork/01_architechture:id2}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{01_arch}.png}\hspace*{\fill}}


\subsection{七层网络体系}
\label{\detokenize{computerNetwork/01_architechture:id3}}
\sphinxstylestrong{OSI} （Open System Interconnect Reference Model）：开放式系统互联参考模型。
\begin{itemize}
\item {} \begin{description}
\item[{物理层（pysical layer）}] \leavevmode
把电脑连接起来的物理手段，如光缆、电缆、双绞线、无线电波。它规定了网路的一些电气属性，作用是负责传输0和1比特的电信号。

\end{description}

\item {} \begin{description}
\item[{数据链路层（data link layer）}] \leavevmode
物理寻址，并将比特组装成帧和点到点的传递。

\end{description}

\item {} \begin{description}
\item[{网络层（network layer）}] \leavevmode
负责数据包从源到宿的传递和网际互连，控制子网的运行，逻辑编址、分组传输、路由选择。

\end{description}

\item {} \begin{description}
\item[{传输层（transport layer）}] \leavevmode
提供端到端的可靠报文传递和错误恢复。

\end{description}

\item {} \begin{description}
\item[{会话层（session layer）}] \leavevmode
负责建立、管理和断开通信连接，以及数据的分割等数据传输相关的管理。

\end{description}

\item {} \begin{description}
\item[{表示层（presentation layer）}] \leavevmode
设备固有的数据格式与网络标准数据格式之间的转换（接受不同格式的信息，如文字流、图像、声音等）。

\end{description}

\item {} \begin{description}
\item[{应用层（application layer）}] \leavevmode
针对特定应用的协议，如电子邮件协议、SSH、FTP、HTTP。

\end{description}

\end{itemize}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{01_osi}.gif}\hspace*{\fill}}


\subsection{参考资料}
\label{\detokenize{computerNetwork/01_architechture:id4}}\begin{enumerate}
\item {} 
七层网络结构

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/u010359398/article/details/82142449}
\end{quote}


\section{TCP}
\label{\detokenize{computerNetwork/02_tcp::doc}}\label{\detokenize{computerNetwork/02_tcp:tcp}}
\sphinxstylestrong{TCP} （Transmission Control Protocol，传输控制协议）是一种 \sphinxstylestrong{面向连接的、可靠的、基于字节流} 的传输层通信协议。


\subsection{三次握手与四次挥手}
\label{\detokenize{computerNetwork/02_tcp:id1}}

\subsubsection{三次握手}
\label{\detokenize{computerNetwork/02_tcp:id2}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=600\sphinxpxdimen]{{02_tcpEstablish}.png}\hspace*{\fill}}
\begin{itemize}
\item {} \begin{description}
\item[{第一次握手}] \leavevmode
起初两端都处于CLOSED关闭状态，\sphinxcode{\sphinxupquote{Client}} 将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给 \sphinxcode{\sphinxupquote{Server}} ， \sphinxcode{\sphinxupquote{Client}} 进入SYN-SENT状态，等待 \sphinxcode{\sphinxupquote{Server}} 确认。

\end{description}

\item {} \begin{description}
\item[{第二次握手}] \leavevmode
\sphinxcode{\sphinxupquote{Server}} 收到数据包后由标志位SYN=1得知 \sphinxcode{\sphinxupquote{Client}} 请求建立连接， \sphinxcode{\sphinxupquote{Server}} 将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给 \sphinxcode{\sphinxupquote{Client}} 以确认连接请求， \sphinxcode{\sphinxupquote{Server}} 进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量。

\end{description}

\item {} \begin{description}
\item[{第三次握手}] \leavevmode
\sphinxcode{\sphinxupquote{Client}} 收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给 \sphinxcode{\sphinxupquote{Server}} 。 \sphinxcode{\sphinxupquote{Server}} 检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功， \sphinxcode{\sphinxupquote{Client}} 和 \sphinxcode{\sphinxupquote{Server}} 进入ESTABLISHED状态，完成三次握手，随后 \sphinxcode{\sphinxupquote{Client}} 和 \sphinxcode{\sphinxupquote{Server}} 就可以开始传输数据。

\end{description}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}\begin{description}
\item[{为什么 \sphinxcode{\sphinxupquote{Client}} 还要发送一次确认呢？可以二次握手吗？}] \leavevmode
主要为了防止已失效的连接请求报文段突然又传送到了 \sphinxcode{\sphinxupquote{Server}} ，因而产生错误。如 \sphinxcode{\sphinxupquote{Client}} 发出连接请求，但因连接请求报文丢失而未收到确认，于是 \sphinxcode{\sphinxupquote{Client}} 再重传一次连接请求。
后来收到了确认，建立了连接。数据传输完毕后，就释放了连接， \sphinxcode{\sphinxupquote{Client}} 发出了两个连接请求报文段，其中第一个丢失，第二个到达了 \sphinxcode{\sphinxupquote{Server}} ，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达 \sphinxcode{\sphinxupquote{Server}} ，此时 \sphinxcode{\sphinxupquote{Server}} 误认为 \sphinxcode{\sphinxupquote{Client}} 又发出一次新的连接请求，于是就向 \sphinxcode{\sphinxupquote{Client}} 发出确认报文段，同意建立连接。
不采用三次握手，只要 \sphinxcode{\sphinxupquote{Server}} 发出确认，就建立新的连接了，此时 \sphinxcode{\sphinxupquote{Client}} 不理睬 \sphinxcode{\sphinxupquote{Server}} 的确认且不发送数据，则 \sphinxcode{\sphinxupquote{Server}} 一直等待 \sphinxcode{\sphinxupquote{Client}} 发送数据，浪费资源。

\end{description}
\end{sphinxadmonition}


\subsubsection{四次挥手}
\label{\detokenize{computerNetwork/02_tcp:id3}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=600\sphinxpxdimen]{{02_tcpClose}.png}\hspace*{\fill}}
\begin{itemize}
\item {} \begin{description}
\item[{第一次挥手}] \leavevmode
\sphinxcode{\sphinxupquote{Client}} 的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待 \sphinxcode{\sphinxupquote{Server}} 的确认。

\end{description}

\item {} \begin{description}
\item[{第二次挥手}] \leavevmode
\sphinxcode{\sphinxupquote{Server}} 收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v）， \sphinxcode{\sphinxupquote{Server}} 进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态， \sphinxcode{\sphinxupquote{Client}} 到 \sphinxcode{\sphinxupquote{Server}} 的连接释放；

\sphinxcode{\sphinxupquote{Client}} 收到 \sphinxcode{\sphinxupquote{Server}} 的确认后，进入FIN-WAIT-2（终止等待2）状态，等待 \sphinxcode{\sphinxupquote{Server}} 发出的连接释放报文段。

\end{description}

\item {} \begin{description}
\item[{第三次挥手}] \leavevmode
\sphinxcode{\sphinxupquote{Server}} 没有要向 \sphinxcode{\sphinxupquote{Client}} 发出的数据了， \sphinxcode{\sphinxupquote{Server}} 发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1）， \sphinxcode{\sphinxupquote{Server}} 进入LAST-ACK（最后确认）状态，等待 \sphinxcode{\sphinxupquote{Client}} 的确认。

\end{description}

\item {} \begin{description}
\item[{第四次挥手}] \leavevmode\begin{quote}

\sphinxcode{\sphinxupquote{Client}} 收到 \sphinxcode{\sphinxupquote{Server}} 的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1）， \sphinxcode{\sphinxupquote{Client}} 进入TIME-WAIT（时间等待）状态。

\sphinxcode{\sphinxupquote{Server}} 收到确认报文段后进入CLOSED状态。
\end{quote}

经过时间等待计时器设置的时间2MSL后， \sphinxcode{\sphinxupquote{Client}} 才进入CLOSED状态。

\end{description}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} \begin{description}
\item[{为什么连接的时候是三次握手，关闭的时候却是四次挥手？}] \leavevmode
因为当 \sphinxcode{\sphinxupquote{Server}} 收到 \sphinxcode{\sphinxupquote{Client}} 的SYN连接请求报文后，可以直接同时发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当 \sphinxcode{\sphinxupquote{Server}} 端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉 \sphinxcode{\sphinxupquote{Client}} 端：“你发的FIN报文我收到了，只有等到我 \sphinxcode{\sphinxupquote{Server}} 端所有的报文都发送完了，我才能发送FIN报文”。
即FIN和ACK不能一起发送，故需要四步握手。

\end{description}

\item {} \begin{description}
\item[{为什么 \sphinxcode{\sphinxupquote{Client}} 需要经过2MSL（最大报文段生存时间）才能从TIME\_WAIT状态进入CLOSE状态？}] \leavevmode
最后一个ACK有可能丢失，所以TIME\_WAIT状态就是用来重发可能丢失的ACK报文。

\end{description}

\end{itemize}
\end{sphinxadmonition}


\subsection{TCP 和 UDP 的区别}
\label{\detokenize{computerNetwork/02_tcp:tcp-udp}}
\sphinxstylestrong{TCP} 是 \sphinxstylestrong{面向连接的、可靠的、基于字节流} 的数据流传输协议，效率低。

\sphinxstylestrong{UDP} （User Datagram Protocol，用户数据协议）是 \sphinxstylestrong{非面向连接的、不可靠} 的数据流传输协议。不需要建立连接，只需要知道对方的IP（Internet Protocol）地址和端口号（port），就可以直接发数据包。因此效率高。


\subsection{参考资料}
\label{\detokenize{computerNetwork/02_tcp:id4}}\begin{enumerate}
\item {} 
TCP三次握手和四次挥手过程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/Andya/p/7272462.html}
\end{quote}


\section{网桥、交换机、路由器、网关}
\label{\detokenize{computerNetwork/03_router::doc}}\label{\detokenize{computerNetwork/03_router:id1}}

\subsection{网桥（Bridge）}
\label{\detokenize{computerNetwork/03_router:bridge}}
两个或多个以太网通过 \sphinxstylestrong{网桥} 连接起来后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就可称为一个网段。

\sphinxstylestrong{网桥工作在数据链路层的MAC子层} ，可以互联不同的物理层、不同的MAC子层以及不同速率的以太网，使以太网各网段成为隔离开的碰撞域。

\sphinxstylestrong{网桥} 具有过滤帧以及存储转发帧的功能，可以隔离冲突域，但不能隔离广播域。


\subsection{交换机（Switch）}
\label{\detokenize{computerNetwork/03_router:switch}}
\sphinxstylestrong{交换机工作在数据链路层} ，相当于一个多端口的网桥，是交换式局域网的核心设备。

\sphinxstylestrong{交换机} 内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张ARP表。
在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。

利用 \sphinxstylestrong{交换机} 可以实现虚拟局域网(VLAN)，VLAN可以隔离冲突域，也可以隔离广播域。


\subsection{路由器（Router）}
\label{\detokenize{computerNetwork/03_router:router}}
\sphinxstylestrong{路由器是网络层设备} ，可以连接不同的网络（异构网络）并主要完成两个功能：分组转发和路由计算。
前者处理通过路由器的数据流，关键操作是转发表查询、转发以及相关的队列管理和任务调度等；后者通过和其他路由器进行基于路由协议的交互，完成路由表的计算。


\subsection{网关（Gateway）}
\label{\detokenize{computerNetwork/03_router:gateway}}
\sphinxstylestrong{网关} 能在不同协议间移动数据，而路由器是在不同网络间移动数据。

\sphinxstylestrong{网关} 是连接两个网络的设备。语音网关可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，并加入协议再进行传输。


\subsection{参考资料}
\label{\detokenize{computerNetwork/03_router:id2}}\begin{enumerate}
\item {} 
牛客网：精华专题

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.nowcoder.com/questionTerminal/497f4570bcfa4399a803f23fb92f7732}
\end{quote}


\chapter{资源链接}
\label{\detokenize{link/index::doc}}\label{\detokenize{link/index:id1}}

\section{Github Page}
\label{\detokenize{link/index:github-page}}
\sphinxurl{https://fongyq.github.io/}


\section{AnyKnew}
\label{\detokenize{link/index:anyknew}}
\sphinxurl{https://www.anyknew.com/\#/}


\section{arXiv}
\label{\detokenize{link/index:arxiv}}
\sphinxurl{https://arxiv.org/}


\section{Read the Docs}
\label{\detokenize{link/index:read-the-docs}}
\sphinxurl{https://readthedocs.org/}


\section{C++ Reference}
\label{\detokenize{link/index:c-reference}}
\sphinxurl{http://www.cplusplus.com/reference/}


\section{Numpy}
\label{\detokenize{link/index:numpy}}
\sphinxurl{http://cs231n.github.io/python-numpy-tutorial/}


\section{Pytorch}
\label{\detokenize{link/index:pytorch}}
Tutorials: \sphinxurl{https://pytorch.org/tutorials/}

Docs: \sphinxurl{https://pytorch.org/docs/master/index.html}


\section{Jupyter Notebook}
\label{\detokenize{link/index:jupyter-notebook}}
\sphinxurl{https://jupyter.org/}


\section{Standford University Lectures}
\label{\detokenize{link/index:standford-university-lectures}}
CS229: \sphinxurl{http://cs229.stanford.edu/syllabus.html}

CS231: \sphinxurl{http://cs231n.github.io/}


\section{ShareLatex}
\label{\detokenize{link/index:sharelatex}}
\sphinxurl{https://www.sharelatex.com/login}


\section{PlanetB}
\label{\detokenize{link/index:planetb}}
\sphinxurl{http://www.planetb.ca/syntax-highlight-word}


\section{Vision Open Source Library}
\label{\detokenize{link/index:vision-open-source-library}}
检索： \sphinxurl{http://yael.gforge.inria.fr/index.html}

特征： \sphinxurl{http://www.vlfeat.org/index.html}


\section{牛客网}
\label{\detokenize{link/index:id2}}
\sphinxurl{https://www.nowcoder.com/}


\chapter{实用软件}
\label{\detokenize{softwares/index::doc}}\label{\detokenize{softwares/index:id1}}

\section{Listary}
\label{\detokenize{softwares/index:listary}}
\begin{sphinxadmonition}{note}{Note:}
Windows下快速查找文件及应用程序

\sphinxurl{http://www.listary.com/}
\end{sphinxadmonition}


\section{FreeCommander}
\label{\detokenize{softwares/index:freecommander}}
\begin{sphinxadmonition}{note}{Note:}
Windows下的资源管理器

\sphinxurl{https://freecommander.com/en/summary/}
\end{sphinxadmonition}


\section{MobaXterm}
\label{\detokenize{softwares/index:mobaxterm}}
\begin{sphinxadmonition}{note}{Note:}
Windows下连接服务器的终端

\sphinxurl{https://mobaxterm.mobatek.net/}
\end{sphinxadmonition}


\section{TeamViewer}
\label{\detokenize{softwares/index:teamviewer}}
\begin{sphinxadmonition}{note}{Note:}
远程连接

\sphinxurl{https://www.teamviewer.com/zhCN/}
\end{sphinxadmonition}


\section{Notepad++}
\label{\detokenize{softwares/index:notepad}}
\begin{sphinxadmonition}{note}{Note:}
强大的文本阅读/编辑器

\sphinxurl{https://notepad-plus-plus.org/}
\end{sphinxadmonition}


\section{cmder}
\label{\detokenize{softwares/index:cmder}}
\begin{sphinxadmonition}{note}{Note:}
Windows下终端神器

\sphinxurl{https://cmder.net/}
\end{sphinxadmonition}


\chapter{Tech}
\label{\detokenize{tech/index:tech}}\label{\detokenize{tech/index::doc}}

\section{技巧}
\label{\detokenize{tech/index:id1}}\begin{itemize}
\item {} 
怎样安装 Windows 7 与 Linux 的双系统？
\begin{quote}

\sphinxurl{https://www.zhihu.com/question/19867618?sort=created}
\end{quote}

\item {} 
Windows10终端优化方案：Ubuntu子系统+cmder+oh-my-zsh
\begin{quote}

\sphinxurl{https://zhuanlan.zhihu.com/p/34152045}

\sphinxurl{https://www.jianshu.com/p/dc32a75e2de4}
\end{quote}

\item {} 
将DOS格式文本文件转换成UNIX格式
\begin{quote}

\sphinxurl{https://codingstandards.iteye.com/blog/810900}
\end{quote}

\item {} 
加速git clone
\begin{quote}

\sphinxurl{https://blog.51cto.com/11887934/2051323}

\sphinxurl{https://blog.lizebang.top/2018/02/git-clone-slow/}
\end{quote}

\item {} 
在windows下安装Jupyter Notebook的安装和使用
\begin{quote}

\sphinxurl{https://www.cnblogs.com/gengyi/p/9769471.html}
\end{quote}

\item {} 
加速TexLive编译
\begin{quote}

\sphinxurl{https://blog.csdn.net/raby\_gyl/article/details/73613601}
\end{quote}

\end{itemize}


\section{问题}
\label{\detokenize{tech/index:id2}}\begin{itemize}
\item {} 
Unable to locate package python-pip
\begin{quote}

\sphinxurl{https://askubuntu.com/questions/268539/unable-to-locate-package-python-pip-on-live-system}
\end{quote}

\item {} 
pytorch: custom nn modules \& define new autograd functions
\begin{quote}

\sphinxurl{https://pytorch.org/tutorials/beginner/pytorch\_with\_examples.html\#pytorch-custom-nn-modules}

\sphinxurl{https://pytorch.org/tutorials/beginner/pytorch\_with\_examples.html\#pytorch-defining-new-autograd-functions}
\end{quote}

\end{itemize}


\chapter{其他}
\label{\detokenize{else/index::doc}}\label{\detokenize{else/index:id1}}

\section{复习}
\label{\detokenize{else/01_interview::doc}}\label{\detokenize{else/01_interview:id1}}

\subsection{汇总}
\label{\detokenize{else/01_interview:id2}}\begin{enumerate}
\item {} 
github

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxurl{https://github.com/imhuay/Algorithm\_Interview\_Notes-Chinese}

\item {} 
\sphinxurl{https://github.com/jwasham/coding-interview-university/blob/master/translations/README-cn.md}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
2018校招算法岗面试题汇总

\end{enumerate}
\begin{quote}

\sphinxurl{https://zhuanlan.zhihu.com/p/36801851}
\end{quote}


\subsection{编程算法}
\label{\detokenize{else/01_interview:id3}}\begin{enumerate}
\item {} 
找出数组中N个出现1（或奇数次）次的数字

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/e1331664c8cf}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
均匀分布生成其他分布的方法

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/haolexiao/article/details/60511164}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
海量数据处理。Hint：哈希方法，把大文件划分成小文件，读进内存依次处理；Bitmap，用一个（或几个）比特位来标记某个元素对应的值。

\end{enumerate}
\begin{itemize}
\item {} 
面试题集锦
\begin{quote}

\sphinxurl{https://blog.csdn.net/v\_july\_v/article/details/6685962}
\end{quote}

\item {} 
大文件中返回频数最高的100个词
\begin{quote}

\sphinxurl{https://blog.csdn.net/tiankong\_/article/details/77240283}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
链表

\end{enumerate}
\begin{quote}
\begin{itemize}
\item {} 
反转链表。Hint：方法一，逐个反转；方法二，递归；方法三，使用栈保存节点的值，反向赋给所有节点。

\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{struct} \PYG{n}{ListNode}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{val}\PYG{p}{;}
    \PYG{n}{ListNode} \PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
    \PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)} \PYG{o}{:} \PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{next}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 方法一，逐个反转}
\PYG{n}{ListNode}\PYG{o}{*} \PYG{n+nf}{reverseList}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*} \PYG{n}{head}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{head}\PYG{o}{=}\PYG{o}{=}\PYG{n+nb}{NULL} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{=}\PYG{o}{=}\PYG{n+nb}{NULL}\PYG{p}{)} \PYG{k}{return} \PYG{n}{head}\PYG{p}{;}
    \PYG{n}{ListNode}\PYG{o}{*} \PYG{n}{newHead} \PYG{o}{=} \PYG{n}{head}\PYG{p}{;}
    \PYG{n}{ListNode}\PYG{o}{*} \PYG{n}{curr} \PYG{o}{=} \PYG{n}{head} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next}\PYG{p}{;}
    \PYG{n}{ListNode}\PYG{o}{*} \PYG{n}{post} \PYG{o}{=} \PYG{n}{curr} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next}\PYG{p}{;}
    \PYG{n}{newHead} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{curr}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{curr} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next} \PYG{o}{=} \PYG{n}{newHead}\PYG{p}{;}
        \PYG{n}{newHead} \PYG{o}{=} \PYG{n}{curr}\PYG{p}{;}
        \PYG{n}{curr} \PYG{o}{=} \PYG{n}{post}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{post}\PYG{p}{)} \PYG{n}{post} \PYG{o}{=} \PYG{n}{post} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{newHead}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 方法二，递归}
\PYG{n}{ListNode}\PYG{o}{*} \PYG{n+nf}{reverseList}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*} \PYG{n}{head}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{head}\PYG{o}{=}\PYG{o}{=}\PYG{n+nb}{NULL} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{=}\PYG{o}{=}\PYG{n+nb}{NULL}\PYG{p}{)} \PYG{k}{return} \PYG{n}{head}\PYG{p}{;}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{ListNode}\PYG{o}{*} \PYG{n}{newHead} \PYG{o}{=} \PYG{n}{reverseList}\PYG{p}{(}\PYG{n}{head} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{head} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next} \PYG{o}{=} \PYG{n}{head}\PYG{p}{;} \PYG{c+c1}{// head 指向的下一个节点是 newHead 的最后一个节点}
        \PYG{n}{head} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{newHead}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 方法三，使用栈保存节点的值，占用 O(n) 额外空间}
\PYG{n}{ListNode}\PYG{o}{*} \PYG{n+nf}{reverseList}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*} \PYG{n}{head}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{head}\PYG{o}{=}\PYG{o}{=}\PYG{n+nb}{NULL} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{=}\PYG{o}{=}\PYG{n+nb}{NULL}\PYG{p}{)} \PYG{k}{return} \PYG{n}{head}\PYG{p}{;}
    \PYG{n}{stack}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{stk}\PYG{p}{;}
    \PYG{n}{ListNode}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{head}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stk}\PYG{p}{.}\PYG{n}{emplace}\PYG{p}{(}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{p} \PYG{o}{=} \PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{p} \PYG{o}{=} \PYG{n}{head}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val} \PYG{o}{=} \PYG{n}{stk}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{stk}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{p} \PYG{o}{=} \PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{next}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{head}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
求有环单链表中的环长、环起点、链表长。
\begin{quote}

\sphinxurl{https://www.cnblogs.com/xudong-bupt/p/3667729.html}
\end{quote}

\item {} 
判断两个链表是否相交并找出交点。
\begin{quote}

\sphinxurl{https://blog.csdn.net/jiary5201314/article/details/50990349}
\end{quote}

\item {} 
单链表 \(\mathcal{O}(1)\) 时间删除给定节点。Hint：交换当前节点与下一个节点的值，删除下一个节点。
\begin{quote}

\sphinxurl{https://blog.csdn.net/qq\_35546040/article/details/80341136}
\end{quote}

\end{itemize}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
排列组合：\(k\) 个球放入 \(m\) 个盒子

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qwb492859377/article/details/50654627?tdsourcetag=s\_pctim\_aiomsg}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
{[}LeetCode{]} Sort Colors（三颜色排序\(\rightarrow\)K颜色排序）

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/princexiexiaofeng/article/details/79645511}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
找到数组第 \(k\) 大的数

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/kth-largest-element-in-an-array/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, 7, 8, 14, 15, 24, 25, 28, 29,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{partition}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{pivot} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{r} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{l}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{j} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{n}{pivot}\PYG{p}{)} \PYG{n}{l}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{r}\PYG{o}{\PYGZgt{}}\PYG{n}{i} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{n}{pivot}\PYG{p}{)} \PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{l}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{r}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
            \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{l}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// partition 可用如下更简洁的形式}
    \PYG{k+kt}{int} \PYG{n}{partition}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{pivot} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{r} \PYG{o}{=} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{o}{+}\PYG{o}{+}\PYG{n}{l}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{n}{pivot} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{l}\PYG{o}{\PYGZlt{}}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{r}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{n}{pivot}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{l}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{r}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
            \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// T(n) = T(n/2) + O(n)，时间复杂度 O(N)}
    \PYG{k+kt}{int} \PYG{n}{quicksort}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{p} \PYG{o}{=} \PYG{n}{partition}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{=}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)} \PYG{k}{return} \PYG{n}{p}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{)} \PYG{k}{return} \PYG{n}{quicksort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{k} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else} \PYG{k}{return} \PYG{n+nf}{quicksort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{p}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{int} \PYG{n}{findKthLargest}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{k\PYGZus{}id} \PYG{o}{=} \PYG{n}{quicksort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k\PYGZus{}id}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{7}
\item {} 
{[}LeetCode{]} Best Time to Buy and Sell Stock 买卖股票的最佳时间

\end{enumerate}
\begin{itemize}
\item {} 
最多一次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4280131.html}
\end{quote}

\item {} 
无限次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4280803.html}
\end{quote}

\item {} 
最多两次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4281975.html}
\end{quote}

\item {} 
最多k次交易
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4295761.html}

\sphinxurl{https://blog.csdn.net/linhuanmars/article/details/23236995}
\end{quote}

\item {} 
交易冷却
\begin{quote}

\sphinxurl{https://www.cnblogs.com/grandyang/p/4997417.html}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{8}
\item {} 
{[}LeetCode{]} Partition Equal Subset Sum 数组分成两个子集，和相等

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/partition-equal-subset-sum/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, 2, 7, 9, 23,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
\PYG{k}{def} \PYG{n+nf}{backtrack}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}current}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} self}
    \PYG{k}{if} \PYG{n}{sum\PYGZus{}current} \PYG{o}{==} \PYG{n}{sum\PYGZus{}nums}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{True}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{False}
    \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{backtrack}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}current}\PYG{o}{+}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} self}
        \PYG{k}{return} \PYG{n+nb+bp}{True}
    \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{backtrack}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}current}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} self}
        \PYG{k}{return} \PYG{n+nb+bp}{True}
    \PYG{k}{return} \PYG{n+nb+bp}{False}

\PYG{k}{def} \PYG{n+nf}{canPartition}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    :type nums: List[int]}
\PYG{l+s+sd}{    :rtype: bool}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{False}
    \PYG{n}{sum\PYGZus{}nums} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{sum\PYGZus{}nums} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{False}
    \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{backtrack}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{sum\PYGZus{}nums}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} self}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{9}
\item {} 
{[}LeetCode{]} Find All Anagrams in a String 统计变位词出现的位置。Hint：采用滑动窗口和 \sphinxstylestrong{计数器} 进行比较。

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/find-all-anagrams-in-a-string/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/* https://leetcode.com/problems/find\PYGZhy{}all\PYGZhy{}anagrams\PYGZhy{}in\PYGZhy{}a\PYGZhy{}string/discuss/92027/C\PYGZpc{}2B\PYGZpc{}2B\PYGZhy{}O(n)\PYGZhy{}sliding\PYGZhy{}window\PYGZhy{}concise\PYGZhy{}solution\PYGZhy{}with\PYGZhy{}explanation */}

\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{findAnagrams}\PYG{p}{(}\PYG{n}{string} \PYG{n}{s}\PYG{p}{,} \PYG{n}{string} \PYG{n}{p}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{vec}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n}{p}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{k}{return} \PYG{n}{vec}\PYG{p}{;}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{p\PYGZus{}counter}\PYG{p}{(}\PYG{l+m+mi}{26}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s\PYGZus{}counter}\PYG{p}{(}\PYG{l+m+mi}{26}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{o}{+}\PYG{o}{+} \PYG{n}{p\PYGZus{}counter}\PYG{p}{[}\PYG{n}{p}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{;}
            \PYG{o}{+}\PYG{o}{+} \PYG{n}{s\PYGZus{}counter}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{p\PYGZus{}counter} \PYG{o}{=}\PYG{o}{=} \PYG{n}{s\PYGZus{}counter}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{p}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{s\PYGZus{}counter}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{;}
            \PYG{o}{+}\PYG{o}{+} \PYG{n}{s\PYGZus{}counter}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{s\PYGZus{}counter} \PYG{o}{=}\PYG{o}{=} \PYG{n}{p\PYGZus{}counter}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{vec}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

11. {[}LeetCode{]} Find the Duplicate Number 寻找重复数。数值范围为 \(\{ 1,2,3,...,n \}\) 。Hint：把数组元素的值当做下标，由于元素存在重复，因此必然会 \sphinxstylestrong{重复多次访问同一个位置} 。
从另一个角度讲，访问序列中存在“环”。哈希不满足空间复杂度为 \(\mathcal{O}(1)\) 的要求。
\begin{quote}
\begin{itemize}
\item {} 
找到一个重复数字。
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/4843654.html}
\end{quote}

\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 解法一：快慢指针，寻找某个“环”的入口}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{findDuplicate}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{slow} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fast} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while} \PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{slow} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{slow}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{fast} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{fast}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{slow} \PYG{o}{=}\PYG{o}{=} \PYG{n}{fast}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{while} \PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{slow} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{slow}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{t} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{slow} \PYG{o}{=}\PYG{o}{=} \PYG{n}{t}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{slow}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 解法二：不断交换位置，找到第一个重复访问的元素}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{findDuplicate}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{duplicate} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{duplicate} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{;}
                    \PYG{k}{break}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// 一次交换之后，下标为 nums[k]\PYGZhy{}1 的元素就等于 nums[k] 了。}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{duplicate} \PYG{o}{!}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{duplicate}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
找到所有重复数字。
\begin{quote}

\sphinxurl{http://www.cnblogs.com/grandyang/p/6209746.html}
\end{quote}

\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 解法一：将访问过的元素置为相反数（负数），如果下次访问到一个负数，说明这个元素被重复访问}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{findDuplicates}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{res}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{idx} \PYG{o}{=} \PYG{n}{abs}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{res}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{idx} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{else} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
        \PYG{c+c1}{// 这种方法得到的 res 可能多次包含同一个元素，可以使用 set}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 解法二：不断交换位置使得 i == nums[i]\PYGZhy{}1}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{findDisappearedNumbers}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{disappear}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{disappear}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)} \PYG{n}{disappear}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{disappear}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{11}
\item {} 
{[}LeetCode{]} Spiral Matrix 环形打印矩阵

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/spiral-matrix/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{void} \PYG{n}{tranverseMatrixAccorindTo4Directions}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{matrix}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{row}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{col}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{start}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{vec}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// 特别注意}
        \PYG{c+c1}{// 如果把 start, endX, endY, k 声明为 unsigned int 类型，在减到 0 的时候可能会死循环，因为 unsigned int 类型不会小于 0。}

        \PYG{k+kt}{int} \PYG{n}{endX} \PYG{o}{=} \PYG{n}{row}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{endY} \PYG{o}{=} \PYG{n}{col}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{;}

        \PYG{c+c1}{// 1 向右}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{start}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{endY}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{start}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// 2 向下}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{start}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{endX}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{n}{endY}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// 3 向左：要求至少存在两行（不加判断会重复扫描同一行）}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{endX} \PYG{o}{\PYGZgt{}} \PYG{n}{start}\PYG{p}{)} \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{endY}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{start}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{endX}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// 4 向上：要求至少存在两列（不加判断会重复扫描同一列）}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{endY} \PYG{o}{\PYGZgt{}} \PYG{n}{start}\PYG{p}{)} \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{endX}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZgt{}} \PYG{n}{start}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{n}{start}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{spiralOrder}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{matrix}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{vec}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{row} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{row} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{n}{vec}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{col} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{col} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{n}{vec}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{start} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{c+c1}{// 循环中止条件：圈数判断（ (start,start) 是每一圈的入口坐标）}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{start}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}} \PYG{n}{row} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{start}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}} \PYG{n}{col}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tranverseMatrixAccorindTo4Directions}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,} \PYG{n}{row}\PYG{p}{,} \PYG{n}{col}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{vec}\PYG{p}{)}\PYG{p}{;}
            \PYG{o}{+}\PYG{o}{+} \PYG{n}{start}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{vec}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{12}
\item {} 
{[}LeetCode{]} Longest Consecutive Sequence 最长连续序列。Hint：方法一，排序；方法二，对于每个元素 \(n\) ，搜索 \(n+1\) 是否在数组中，使用 hash（set）可以获得 \(\mathcal{O}(1)\) 的查找复杂度。

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/longest-consecutive-sequence/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}\PYG{p}{(}\PYG{n}{object}\PYG{p}{)}\PYG{o}{:}
\PYG{n}{def} \PYG{n}{longestConsecutive}\PYG{p}{(}\PYG{n}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}\PYG{o}{:}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}
    \PYG{o}{:}\PYG{n}{type} \PYG{n+nl}{nums}\PYG{p}{:} \PYG{n}{List}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}
    \PYG{o}{:}\PYG{n+nl}{rtype}\PYG{p}{:} \PYG{k+kt}{int}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}

    \PYG{n}{longest} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{num\PYGZus{}set} \PYG{o}{=} \PYG{n}{set}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{num} \PYG{n}{in} \PYG{n+nl}{nums}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{num}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{not} \PYG{n}{in} \PYG{n+nl}{num\PYGZus{}set}\PYG{p}{:}
            \PYG{n}{current\PYGZus{}long} \PYG{o}{=} \PYG{l+m+mi}{1}
            \PYG{k}{while} \PYG{n}{num} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{n}{in} \PYG{n+nl}{num\PYGZus{}set}\PYG{p}{:}
                \PYG{n}{current\PYGZus{}long} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
                \PYG{n}{num} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
            \PYG{n}{longest} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{longest}\PYG{p}{,} \PYG{n}{current\PYGZus{}long}\PYG{p}{)}

    \PYG{n}{num\PYGZus{}set}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{longest}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{13}
\item {} 
最小公约数与最大公倍数。Hint：辗转相除法；最大公倍数等于两数乘积除以最大公约数。

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/Arvin-JIN/p/7247619.html}
\end{quote}

15. 跳跃的蚂蚱：从 0 点出发，往正或负向跳跃，第一次跳跃一个单位，之后每次跳跃距离比上一次多一个单位，跳跃多少次可到到达坐标 \(x\) 处？
Hint：走 \(n\) 步之后能到达的坐标是一个差为 2 的等差数列（如 \(n=3\) ，可到达 \(\{-3,-1,1,3\}\) ）。
只需找到第最小的 \(n\) 使得
\begin{equation*}
\begin{split}(1+2+...+n) - x = \frac{n(n+1)}{2} - x\end{split}
\end{equation*}
是非负偶数。跳到 \(x\) 和跳到 \(-x\) 的次数相同，
因此只考虑 \(x\) 为正的情况。
\begin{quote}

\sphinxurl{https://www.zhihu.com/question/50790221}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 作者：Rukia}
\PYG{c+c1}{// 链接：https://www.zhihu.com/question/50790221/answer/125213696}

\PYG{k+kt}{int} \PYG{n+nf}{minStep}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{=}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 快速找到一个接近答案的 n}
  \PYG{k}{while} \PYG{p}{(}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{x} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{n}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}} \PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{// \PYGZam{} 的优先级低}
          \PYG{o}{+}\PYG{o}{+}\PYG{n}{n}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{n}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

16. 求 \(n\) 的阶乘末尾有多少个 \(0\) 。Hint：1个 \(5\) 和1个 \(2\) 搭配可以得到1个 \(0\) ；\(2\) 的个数比 \(5\) 多，
因此只关心 \(5\) 的个数；\(25\) 包含2个 \(5\) ，\(125\) 包含3个 \(5\) …。
\begin{quote}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{trailingZeroes}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{res} \PYG{o}{+}\PYG{o}{=} \PYG{n}{n} \PYG{o}{/} \PYG{l+m+mi}{5}\PYG{p}{;}
            \PYG{n}{n} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

17. 求一个整数的二进制表示中 \(1\) 的个数。Hint：移位操作，负数可能造成死循环。 \sphinxstylestrong{注：指定移位次数大于或等于对象类型的比特数（如int型的32位），或者对负数进行左移操作，结果都是未定义的} 。
例如：\sphinxcode{\sphinxupquote{n \textgreater{}\textgreater{} 32}} 是未定义的，但是允许 \sphinxcode{\sphinxupquote{n \textgreater{}\textgreater{}= 1}} 执行无限次，这是安全的。
\begin{quote}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 方法一：不断右移n。如果n是负数，需要保持最高位为1，不断移位后这个数字会变成 0xFFFFFFFF 而陷入死循环。}
\PYG{k+kt}{int} \PYG{n+nf}{Numberof1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{n}{n} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{cnt}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 方法二：n不动，左移一个比较子。}
\PYG{k+kt}{int} \PYG{n+nf}{Numberof1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{flag} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{n}{flag}\PYG{p}{)} \PYG{c+c1}{// 连续左移32次之后为0}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZam{}} \PYG{n}{flag}\PYG{p}{)} \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{n}{flag} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{cnt}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 方法三：把一个整数减1，再和原整数做逻辑与运算，会把该整数最右边的一个1变成0。}
\PYG{k+kt}{int} \PYG{n+nf}{Numberof1}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{n}{n} \PYG{o}{=} \PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{n}{n}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{cnt}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

18. {[}LeetCode{]} Subarray Sum Equals K 子数组和为 \(K\) 。Hint：依次求数组的前 \(n\) 项和 \(sum[n]\) ，\(n \in [0, arr\_size]\) （注意：0也在内），
将和作为哈希表的key，和的值出现次数作为value；如果存在 \(sum[i]−sum[j]=K \ (i \ge j)\) ，则 \(sum[i]\) 和 \(sum[j]\) 都应该在哈希表中。
\begin{quote}

\sphinxurl{https://leetcode.com/problems/subarray-sum-equals-k/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// https://leetcode.com/problems/subarray\PYGZhy{}sum\PYGZhy{}equals\PYGZhy{}k/solution/ : Approach \PYGZsh{}4 Using hashmap}

\PYG{n}{from} \PYG{n}{collections} \PYG{n}{import} \PYG{n}{defaultdict}
\PYG{k}{class} \PYG{n+nc}{Solution}\PYG{p}{(}\PYG{n}{object}\PYG{p}{)}\PYG{o}{:}
\PYG{n}{def} \PYG{n}{subarraySum}\PYG{p}{(}\PYG{n}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{o}{:}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}
    \PYG{o}{:}\PYG{n}{type} \PYG{n+nl}{nums}\PYG{p}{:} \PYG{n}{List}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}
    \PYG{o}{:}\PYG{n}{type} \PYG{n+nl}{k}\PYG{p}{:} \PYG{k+kt}{int}
    \PYG{o}{:}\PYG{n+nl}{rtype}\PYG{p}{:} \PYG{k+kt}{int}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}

    \PYG{k}{if} \PYG{n}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{:}
        \PYG{k}{return} \PYG{l+m+mi}{0}

    \PYG{n}{N} \PYG{o}{=} \PYG{n}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}

    \PYG{n}{sum\PYGZus{}to\PYGZus{}num} \PYG{o}{=} \PYG{n}{defaultdict}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
    \PYG{n}{sum\PYGZus{}to\PYGZus{}num}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{c+c1}{// 前 0 项和}

    \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{tmp\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{n} \PYG{n}{in} \PYG{n+nl}{nums}\PYG{p}{:}
        \PYG{n}{tmp\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{n}
        \PYG{n}{diff} \PYG{o}{=} \PYG{n}{tmp\PYGZus{}sum} \PYG{o}{\PYGZhy{}} \PYG{n}{k}
        \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{n}{sum\PYGZus{}to\PYGZus{}num}\PYG{p}{[}\PYG{n}{diff}\PYG{p}{]}
        \PYG{n}{sum\PYGZus{}to\PYGZus{}num}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}sum}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{return} \PYG{n}{cnt}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{18}
\item {} 
使用位运算进行加法运算。Hint：原位加法运算等效为 \sphinxcode{\sphinxupquote{\textasciicircum{}}} 运算，进位等效为 \sphinxcode{\sphinxupquote{\&}} 和 \sphinxcode{\sphinxupquote{移位}} 的复合。 \sphinxstylestrong{注：C++不允许对负数进行左移运算。}

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/sum-of-two-integers/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{getSum}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{sum}\PYG{p}{,} \PYG{n}{carry}\PYG{p}{;}
        \PYG{k}{do}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sum} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZca{}} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{carry} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZam{}} \PYG{n}{b} \PYG{o}{\PYGZam{}} \PYG{n}{INT\PYGZus{}MAX}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// \PYGZam{} INT\PYGZus{}MAX 操作保证移位前的数是正数，否则结果是未定义的。}
            \PYG{n}{a} \PYG{o}{=} \PYG{n}{sum}\PYG{p}{;}
            \PYG{n}{b} \PYG{o}{=} \PYG{n}{carry}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}\PYG{k}{while}\PYG{p}{(}\PYG{n}{b} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{a}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{int32}

\PYG{k}{class} \PYG{n+nc}{Solution}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{getSum}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        :type a: int}
\PYG{l+s+sd}{        :type b: int}
\PYG{l+s+sd}{        :rtype: int}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{int32}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{,} \PYG{n}{int32}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}

        \PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
            \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZca{}} \PYG{n}{b}\PYG{p}{,} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+m+mi}{1}
            \PYG{k}{print} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}
            \PYG{k}{if} \PYG{n}{b} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
                \PYG{k}{break}

        \PYG{k}{return} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 注意，这里并没有与 0x7fffffff 做 \PYGZam{} 运算}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 假设 a \PYGZam{} b = \PYGZhy{}16，\PYGZhy{}16 \PYGZam{} 0x7fffffff = 2147483632}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} C++ 中，对 2147483632 左移1位使得最高位符号位为 1，得到 \PYGZhy{}32}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} python中，2147483632的符号位为 0，继续左移1位，会直接做大整数运算，得到 4294967264L，导致不能得到正确结果}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} python 中，使用type()查看数据类型时发现，有时候系统会把 int32 转化为 int64，或者 int64 转为 int32，疑惑中。。。}
\end{sphinxVerbatim}
\end{quote}

20. {[}LeetCode{]} Longest Substring with At Least K Repeating Characters 包含重复字符的最长子串。Hint：由于该字符串只包含小写字母，因此
直接使用长度为26的静态数组来统计字符频率更为简洁高效，不需要使用map。
\begin{quote}

\sphinxurl{https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// https://www.cnblogs.com/grandyang/p/5852352.html}
\PYG{c+c1}{// 使用一个int型（32位）的mask，指示各字符频率是否到达k}
\PYG{c+c1}{// 以每一个字符作为起点，往后统计。时间复杂度 O(N\PYGZca{}2)}
\PYG{c+c1}{// mask第 idx 位从 0 \PYGZhy{}\PYGZgt{} 1，表示对应字符出现了，但是未达到k次}
\PYG{c+c1}{// mask第 idx 位从 1 \PYGZhy{}\PYGZgt{} 0，表示对应字符已经出现了k次}
\PYG{c+c1}{// mask变成 0，表示这段子串满足要求}

\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{longestSubstring}\PYG{p}{(}\PYG{n}{string} \PYG{n}{s}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{ans} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{start} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{start} \PYG{o}{+} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{hash}\PYG{p}{[}\PYG{l+m+mi}{26}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{mask} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{next\PYGZus{}start} \PYG{o}{=} \PYG{n}{start} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{end} \PYG{o}{=} \PYG{n}{start}\PYG{p}{;} \PYG{n}{end} \PYG{o}{\PYGZlt{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+} \PYG{n}{end}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{idx} \PYG{o}{=} \PYG{n}{s}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+} \PYG{n}{hash}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{hash}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{)} \PYG{n}{mask} \PYG{o}{\textbar{}}\PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{idx}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 0 \PYGZhy{}\PYGZgt{} 1}
                \PYG{k}{else} \PYG{n}{mask} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{o}{\PYGZti{}}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{idx}\PYG{p}{)}\PYG{p}{;}             \PYG{c+c1}{// 1 \PYGZhy{}\PYGZgt{} 0}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{mask} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{ans} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{ans}\PYG{p}{,} \PYG{n}{end} \PYG{o}{\PYGZhy{}} \PYG{n}{start} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{next\PYGZus{}start} \PYG{o}{=} \PYG{n}{end} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{start} \PYG{o}{=} \PYG{n}{next\PYGZus{}start}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{ans}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{20}
\item {} 
{[}LeetCode{]} 4Sum II 4个数和为0的组合数。Hint：两两之和存入哈希表，时间复杂度和空间复杂度 \(\mathcal{O}(N^2)\) 。

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/4sum-ii/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{fourSumCount}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{A}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{D}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{AB} \PYG{o}{=} \PYG{n}{collections}\PYG{o}{.}\PYG{n}{Counter}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b} \PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n}{A} \PYG{k}{for} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n}{B}\PYG{p}{)}
    \PYG{k}{return} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{AB}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{n}{d}\PYG{p}{]} \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{C} \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{D}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{21}
\item {} 
{[}LeetCode{]} Maximum Product Subarray 求连续子数组的最大乘积。Hint：数组中存在负数，负负得正，因此相比于连续子数组最大和问题，不仅需要记录以每个元素结尾的连续乘积的最大值，还需要记录最小值。

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/xblog\_/article/details/72872263}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{22}
\item {} 
给定一个十进制整数 \(N\) ，统计从 \(1\) 到 \(N\) 所有的整数各位出现的 \(1\) 的数目。Hint： \(1\) 的数目 = 个位出现 \(1\) 的数目 + 十位出现 \(1\) 的数目 + 百位出现 \(1\) 的数目  + ……。以百位为例：如果百位数字为0，则百位出现1的次数只由更高位决定，如12013，次数为12 * 100；如果百位数字为1，则百位出现1的次数由更高位和更低位同时决定，如12113，次数为12 * 100 + (113 + 1)；如果百位数字大于1，则百位出现1的次数只由更高位决定，如12213，次数为(12 + 1) * 100。时间复杂度 \(\mathcal{O}(\log_{10}(N))\) 。

\end{enumerate}
\begin{quote}

\sphinxurl{http://www.cnblogs.com/jy02414216/archive/2011/03/09/1977724.html}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{typedef} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{ULL}\PYG{p}{;}
\PYG{n}{ULL} \PYG{n+nf}{number\PYGZus{}of\PYGZus{}1}\PYG{p}{(}\PYG{n}{ULL} \PYG{n}{N}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{ULL} \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{n}{ULL} \PYG{n}{factor} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{n}{ULL} \PYG{n}{lowerNum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{n}{ULL} \PYG{n}{currNum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{n}{ULL} \PYG{n}{highNum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{while}\PYG{p}{(}\PYG{n}{N} \PYG{o}{/} \PYG{n}{factor}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{lowerNum} \PYG{o}{=} \PYG{n}{N} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{N} \PYG{o}{/} \PYG{n}{factor}\PYG{p}{)} \PYG{o}{*} \PYG{n}{factor}\PYG{p}{;}
    \PYG{n}{currNum} \PYG{o}{=} \PYG{p}{(}\PYG{n}{N} \PYG{o}{/} \PYG{n}{factor}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10}\PYG{p}{;}
    \PYG{n}{highNum} \PYG{o}{=} \PYG{n}{N} \PYG{o}{/} \PYG{p}{(}\PYG{n}{factor} \PYG{o}{*} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{switch}\PYG{p}{(}\PYG{n}{currNum}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{case} \PYG{l+m+mi}{0}\PYG{o}{:}
        \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{n}{highNum} \PYG{o}{*} \PYG{n}{factor}\PYG{p}{;}
        \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{case} \PYG{l+m+mi}{1}\PYG{o}{:}
        \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{n}{highNum} \PYG{o}{*} \PYG{n}{factor} \PYG{o}{+} \PYG{p}{(}\PYG{n}{lowerNum} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{default}\PYG{o}{:}
        \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{highNum} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{factor}\PYG{p}{;}
        \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{factor} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{cnt}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{23}
\item {} 
数组循环移位：循环右移 \(K\) 位，时间复杂度 \(\mathcal{O}(N)\) 。Hint：三次翻转。

\end{enumerate}
\begin{quote}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{begin}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{end}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{for}\PYG{p}{(}\PYG{p}{;} \PYG{n}{begin} \PYG{o}{\PYGZlt{}} \PYG{n}{end}\PYG{p}{;} \PYG{n}{begin}\PYG{o}{+}\PYG{o}{+}\PYG{p}{,} \PYG{n}{end}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)} \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{begin}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{right\PYGZus{}shift}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{N}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{K}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{K} \PYG{o}{\PYGZpc{}}\PYG{o}{=} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{n}{K}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{n}{K}\PYG{p}{,} \PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{24}
\item {} 
{[}LeetCode{]} Divide Two Integers 整数除法。Hint：先取绝对值，做正整数之间的除法；防止溢出。

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/divide-two-integers/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{divide}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{dividend}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{divisor}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dividend} \PYG{o}{=}\PYG{o}{=} \PYG{n}{INT\PYGZus{}MIN} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{divisor} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{INT\PYGZus{}MAX}\PYG{p}{;} \PYG{c+c1}{// 越界则输出最大值}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dividend} \PYG{o}{=}\PYG{o}{=} \PYG{n}{INT\PYGZus{}MIN} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{divisor} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{INT\PYGZus{}MIN}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{divisor} \PYG{o}{=}\PYG{o}{=} \PYG{n}{INT\PYGZus{}MIN} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{dividend} \PYG{o}{=}\PYG{o}{=} \PYG{n}{INT\PYGZus{}MIN}\PYG{p}{)} \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// 枚举分子为最小整数时的情形}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{divisor} \PYG{o}{=}\PYG{o}{=} \PYG{n}{INT\PYGZus{}MIN}\PYG{p}{)} \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{k+kt}{bool} \PYG{n}{sign} \PYG{o}{=} \PYG{p}{(}\PYG{n}{dividend}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZca{}} \PYG{p}{(}\PYG{n}{divisor}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{?} \PYG{n+nb}{false} \PYG{o}{:} \PYG{n+nb}{true}\PYG{p}{;}

        \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{k+kt}{bool} \PYG{n}{max\PYGZus{}flow} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dividend} \PYG{o}{=}\PYG{o}{=} \PYG{n}{INT\PYGZus{}MIN}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{dividend} \PYG{o}{=} \PYG{n}{abs}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{INT\PYGZus{}MIN}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 防止取绝对值之后溢出}
            \PYG{n}{max\PYGZus{}flow} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{n}{dividend} \PYG{o}{=} \PYG{n}{abs}\PYG{p}{(}\PYG{n}{dividend}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{divisor} \PYG{o}{=} \PYG{n}{abs}\PYG{p}{(}\PYG{n}{divisor}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{while}\PYG{p}{(}\PYG{n}{dividend} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{divisor}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{diff} \PYG{o}{=} \PYG{n}{divisor}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{diff} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{p}{(}\PYG{n}{dividend} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{diff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{dividend} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{diff}\PYG{p}{;}
            \PYG{n}{res} \PYG{o}{+}\PYG{o}{=} \PYG{n}{n}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{max\PYGZus{}flow} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{dividend} \PYG{o}{=}\PYG{o}{=} \PYG{n}{divisor}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{res} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

        \PYG{k}{return} \PYG{n}{sign}\PYG{o}{?} \PYG{n+nl}{res} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{n}{res}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{25}
\item {} 
{[}LeetCode{]} Fraction to Recurring Decimal 循环小数。Hint：小数除法：余数乘以10再求余；如果余数出现重复，则说明是循环小数。

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/fraction-to-recurring-decimal/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{string} \PYG{n}{fractionToDecimal}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{numerator}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{denominator}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numerator} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{denominator} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{sign\PYGZus{}num} \PYG{o}{=} \PYG{n}{numerator} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{o}{?} \PYG{l+m+mi}{1}\PYG{o}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{sign\PYGZus{}den} \PYG{o}{=} \PYG{n}{denominator} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{o}{?} \PYG{l+m+mi}{1}\PYG{o}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}

        \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{num} \PYG{o}{=} \PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{numerator}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{den} \PYG{o}{=} \PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{denominator}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{integer} \PYG{o}{=} \PYG{n}{num} \PYG{o}{/} \PYG{n}{den}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{rem} \PYG{o}{=} \PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{n}{den}\PYG{p}{;}

        \PYG{n}{string} \PYG{n}{int\PYGZus{}part} \PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{integer}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rem}\PYG{p}{)} \PYG{n}{int\PYGZus{}part} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

        \PYG{n}{string} \PYG{n}{frac\PYGZus{}part} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{mp}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{idx} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{k}{while}\PYG{p}{(}\PYG{n}{rem}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{mp}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{rem}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{mp}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{// 余数重复}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{frac\PYGZus{}part}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{mp}\PYG{p}{[}\PYG{n}{rem}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{frac\PYGZus{}part} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{mp}\PYG{p}{[}\PYG{n}{rem}\PYG{p}{]} \PYG{o}{=} \PYG{n}{idx} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{frac\PYGZus{}part} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{rem}\PYG{p}{)} \PYG{o}{/} \PYG{n}{den}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rem} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{rem}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{n}{den}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{string} \PYG{n}{res} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sign\PYGZus{}num} \PYG{o}{*} \PYG{n}{sign\PYGZus{}den} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{res} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{res} \PYG{o}{+}\PYG{o}{=} \PYG{n}{int\PYGZus{}part} \PYG{o}{+} \PYG{n}{frac\PYGZus{}part}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{26}
\item {} 
正整数质因数分解。

\end{enumerate}
\begin{quote}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 不断除以 2 之后，2 的倍数都不可能再整除 n；3 同理。}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 思想类似于：找到 n 以内的素数，即把素数的倍数都排除。}
\PYG{k}{def} \PYG{n+nf}{decomp}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{prime} \PYG{o}{=} \PYG{l+m+mi}{2}
    \PYG{k}{while} \PYG{n}{n} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{prime}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZpc{}} \PYG{n}{prime} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{k}{print} \PYG{n}{prime}
            \PYG{n}{n} \PYG{o}{/}\PYG{o}{=} \PYG{n}{prime}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{prime} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{27}
\item {} 
旋转数组查找。Hint：采用二分查找的思路。

\end{enumerate}
\begin{quote}
\begin{itemize}
\item {} 
二分查找

\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// preliminary: binary search，时间复杂度 O(logN)}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{int} \PYG{n}{binarySearch}\PYG{p}{(}\PYG{n}{T} \PYG{o}{*}\PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{target}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{low} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{high} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k}{while} \PYG{p}{(}\PYG{n}{low} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{high}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{mid} \PYG{o}{=} \PYG{n}{low} \PYG{o}{+} \PYG{p}{(}\PYG{n}{high} \PYG{o}{\PYGZhy{}} \PYG{n}{low}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// mid = (low + high)/2 可能导致溢出}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{target}\PYG{p}{)} \PYG{k}{return} \PYG{n}{mid}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{target}\PYG{p}{)} \PYG{n}{low} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{else} \PYG{n}{high} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
查找旋转数组最小值（含重复元素）
\begin{quote}

\sphinxurl{https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/}
\end{quote}

\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 方法一}
\PYG{c+c1}{// 第一个指针总指向前面递增数组的元素}
\PYG{c+c1}{// 第二个指针总指向后面递增数组的元素}
\PYG{c+c1}{// 最终两个指针指向相邻元素：第一个指针指向前面递增数组的最后一个元素，第二个指针指向后面递增数组的第一个元素（也就是最小元素）}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{int} \PYG{n}{findRotateMin}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{low} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{high} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k}{while} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{low}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{high}\PYG{p}{]}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{high} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{=}\PYG{o}{=} \PYG{n}{low}\PYG{p}{)} \PYG{k}{return} \PYG{n}{high}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{mid} \PYG{o}{=} \PYG{n}{low} \PYG{o}{+} \PYG{p}{(}\PYG{n}{high} \PYG{o}{\PYGZhy{}} \PYG{n}{low}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{;}

    \PYG{c+c1}{// 如果这三个元素相等，则在区间 [low, high] 内顺序查找}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{low}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{high}\PYG{p}{]}\PYG{p}{)} \PYG{k}{return} \PYG{p}{(}\PYG{n}{min\PYGZus{}element}\PYG{p}{(}\PYG{n}{arr} \PYG{o}{+} \PYG{n}{low}\PYG{p}{,} \PYG{n}{arr} \PYG{o}{+} \PYG{n}{high} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{high}\PYG{p}{]}\PYG{p}{)} \PYG{n}{high} \PYG{o}{=} \PYG{n}{mid}\PYG{p}{;}
    \PYG{k}{else} \PYG{n}{low} \PYG{o}{=} \PYG{n}{mid}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{c+c1}{// 如果数组本身是有序的，即 arr[0] \PYGZlt{} arr[n\PYGZhy{}1]，则第一个元素就是最小值}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 方法二}
\PYG{c+c1}{// 如果 arr[mid] \PYGZlt{} arr[mid\PYGZhy{}1]，则 arr[mid] 是最小值}
\PYG{c+c1}{// 每次比较 nums[mid] 与 nums[high]，如果两者相等，则 \PYGZhy{}\PYGZhy{}high}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{int} \PYG{n}{findRotateMin}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{low} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{high} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k}{while} \PYG{p}{(}\PYG{n}{low} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{high}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{mid} \PYG{o}{=} \PYG{n}{low} \PYG{o}{+} \PYG{p}{(}\PYG{n}{high} \PYG{o}{\PYGZhy{}} \PYG{n}{low}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{mid} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{k}{return} \PYG{n}{mid}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{high}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{high}\PYG{p}{;}

    \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{high}\PYG{p}{]}\PYG{p}{)} \PYG{n}{high} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}

    \PYG{k}{else} \PYG{n}{low} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
在旋转数组查找目标值（无重复元素）
\begin{quote}

\sphinxurl{https://leetcode.com/problems/search-in-rotated-sorted-array/}
\end{quote}

\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 每次比较 nums[mid] 与 nums[high]}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{search}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{target}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{n} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{low} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{high} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{low} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{high}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{mid} \PYG{o}{=} \PYG{n}{low} \PYG{o}{+} \PYG{p}{(}\PYG{n}{high} \PYG{o}{\PYGZhy{}} \PYG{n}{low}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{target}\PYG{p}{)} \PYG{k}{return} \PYG{n}{mid}\PYG{p}{;}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{high}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{// 注：只有当 low == high，才会出现： mid == high，nums[mid] == nums[high]}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{target} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{target} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{high}\PYG{p}{]}\PYG{p}{)} \PYG{n}{low} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{else} \PYG{n}{high} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{target} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{target} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{low}\PYG{p}{]}\PYG{p}{)} \PYG{n}{high} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{else} \PYG{n}{low} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
在旋转数组查找目标值（含重复元素）
\begin{quote}

\sphinxurl{https://leetcode.com/problems/search-in-rotated-sorted-array-ii/}
\end{quote}

\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// https://www.cnblogs.com/grandyang/p/4325840.html}
\PYG{c+c1}{// 相对于上例，需要增加一个判断：如果 nums[mid] 与 nums[high] 相等，则 \PYGZhy{}\PYGZhy{}high}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{bool} \PYG{n}{search}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{target}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{n} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{low} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{high} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{low} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{high}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{mid} \PYG{o}{=} \PYG{n}{low} \PYG{o}{+} \PYG{p}{(}\PYG{n}{high} \PYG{o}{\PYGZhy{}} \PYG{n}{low}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{target}\PYG{p}{)} \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{high}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{high}\PYG{p}{;} \PYG{c+c1}{// 增加这个判断。注：只有当 low == high，才会出现： mid == high 。}

            \PYG{k}{else} \PYG{n+nf}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{high}\PYG{p}{]}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{target} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{target} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{high}\PYG{p}{]}\PYG{p}{)} \PYG{n}{low} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{else} \PYG{n}{high} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{target} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{target} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{low}\PYG{p}{]}\PYG{p}{)} \PYG{n}{high} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{else} \PYG{n}{low} \PYG{o}{=} \PYG{n}{mid} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

29. {[}LeetCode{]} Maximum Gap 最大间隔。Hint：方法一，普通排序，逐个比较；方法二，桶排序。将 \(n\) 个数放到 \(n+1\) 个桶中，最小值放第一个桶，
最大值放最后一个桶，每个桶的大小为 \(\frac{max-min}{n}\) 。根据鸽巢原理，至少存在一个桶为空。最大间隔必然出现在空桶两侧，且只与左侧桶的最大值、
右侧桶的最小值有关。（事实上，可以将 \(n\) 个数放到 \(n\) 个桶中，如果没有空桶，则刚好每个桶有且仅有一个数，最大间隔出现在相邻桶中；如果某个桶有2个数以上，
说明存在有空桶，最大间隔出现在非空的相邻桶中。总之，最大间隔不会出现在一个桶中。）
\begin{quote}

\sphinxurl{https://leetcode.com/problems/maximum-gap/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 建立 n 个桶}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{int} \PYG{n}{maximumGap}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{nums}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{n} \PYG{o}{=} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{k+kt}{int} \PYG{n}{MIN} \PYG{o}{=} \PYG{o}{*}\PYG{n}{min\PYGZus{}element}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{MAX} \PYG{o}{=} \PYG{o}{*}\PYG{n}{max\PYGZus{}element}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{MIN} \PYG{o}{=}\PYG{o}{=} \PYG{n}{MAX}\PYG{p}{)} \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{bucket}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{double} \PYG{n}{delta} \PYG{o}{=} \PYG{p}{(}\PYG{n}{MAX} \PYG{o}{\PYGZhy{}} \PYG{n}{MIN}\PYG{p}{)} \PYG{o}{/} \PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{idx} \PYG{o}{=} \PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{MIN}\PYG{p}{)} \PYG{o}{/} \PYG{n}{delta}\PYG{p}{;}
            \PYG{n}{bucket}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k+kt}{int} \PYG{n}{gap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{pre} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{curr} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{curr} \PYG{o}{\PYGZlt{}} \PYG{n}{bucket}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{bucket}\PYG{p}{[}\PYG{n}{curr}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{curr} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{curr} \PYG{o}{\PYGZhy{}} \PYG{n}{pre} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k+kt}{int} \PYG{n}{pre\PYGZus{}max} \PYG{o}{=} \PYG{o}{*}\PYG{n}{max\PYGZus{}element}\PYG{p}{(}\PYG{n}{bucket}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{bucket}\PYG{p}{[}\PYG{n}{pre}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k+kt}{int} \PYG{n}{curr\PYGZus{}min} \PYG{o}{=} \PYG{o}{*}\PYG{n}{min\PYGZus{}element}\PYG{p}{(}\PYG{n}{bucket}\PYG{p}{[}\PYG{n}{curr}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{bucket}\PYG{p}{[}\PYG{n}{curr}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{gap} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{gap}\PYG{p}{,} \PYG{n}{curr\PYGZus{}min} \PYG{o}{\PYGZhy{}} \PYG{n}{pre\PYGZus{}max}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{pre} \PYG{o}{=} \PYG{n}{curr}\PYG{p}{;}
                \PYG{n}{curr} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{gap}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{29}
\item {} 
数组操作模拟大数乘法。Hint：从低位到高位，采用竖式计算，记录所有位的乘积，再将对应位的结果相加，最后进位。假设数组 \(a\) 和 \(b\) 从低位到高位存储了两个大数（可能存在小数点），则乘积为 \(ans[i+j] = ans[i+j] + a[i] + b[j]\) 。

\end{enumerate}
\begin{quote}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{preProcess}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} input: str}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} output: list, l}
    \PYG{n}{pf} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{lf} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{if} \PYG{n}{pf} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{lf} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{pf} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 小数位数}
        \PYG{n}{a} \PYG{o}{=} \PYG{n}{a}\PYG{p}{[}\PYG{p}{:}\PYG{n}{pf}\PYG{p}{]} \PYG{o}{+} \PYG{n}{a}\PYG{p}{[}\PYG{n}{pf}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 去掉小数点}
    \PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{a}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 翻转数组，a[0] 表示最低位}
    \PYG{k}{return} \PYG{n}{a}\PYG{p}{,} \PYG{n}{lf}

\PYG{k}{def} \PYG{n+nf}{strMul}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{la} \PYG{o}{=} \PYG{n}{preProcess}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
    \PYG{n}{b}\PYG{p}{,} \PYG{n}{lb} \PYG{o}{=} \PYG{n}{preProcess}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{lf} \PYG{o}{=} \PYG{n}{la} \PYG{o}{+} \PYG{n}{lb}

    \PYG{n}{ans} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{ia} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{ib} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{ans}\PYG{p}{[}\PYG{n}{ia}\PYG{o}{+}\PYG{n}{ib}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{ia}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{ib}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{carry} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ans}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{ans}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{carry}
        \PYG{n}{ans}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{tmp} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10}
        \PYG{n}{carry} \PYG{o}{=} \PYG{n}{tmp} \PYG{o}{/} \PYG{l+m+mi}{10}
    \PYG{n}{ans} \PYG{o}{=} \PYG{n}{ans}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 翻转数组}

    \PYG{k}{if} \PYG{n}{lf} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{ans}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ans}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{lf}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 插入小数点}
    \PYG{k}{if} \PYG{n}{ans}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{ans} \PYG{o}{=} \PYG{n}{ans}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 最高位是 0 则去掉}
    \PYG{n}{iz} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ans}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n}{lf} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{ans}\PYG{p}{[}\PYG{n}{iz}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 去掉小数点末尾的 0}
        \PYG{n}{iz} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{n}{s} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{ans}\PYG{p}{[}\PYG{p}{:}\PYG{n}{iz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
        \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{s}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{30}
\item {} 
{[}LeetCode{]} Number of Islands 孤岛个数。Hint：使用队列，广度优先遍历（BFS）。

\end{enumerate}
\begin{quote}

\sphinxurl{https://leetcode.com/problems/number-of-islands/}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
   \PYG{k+kt}{void} \PYG{n}{traverseIsland}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{grid}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{m}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{M}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{N}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{queue}\PYG{o}{\PYGZlt{}}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{que}\PYG{p}{;}

        \PYG{n}{que}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{make\PYGZus{}pair}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{grid}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}

        \PYG{k}{while} \PYG{p}{(}\PYG{o}{!}\PYG{n}{que}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{p} \PYG{o}{=} \PYG{n}{que}\PYG{p}{.}\PYG{n}{front}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{que}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

            \PYG{k}{if} \PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{1}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
                \PYG{n}{que}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{make\PYGZus{}pair}\PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p}\PYG{p}{.}\PYG{n}{second}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{n}{M} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{1}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
                \PYG{n}{que}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{make\PYGZus{}pair}\PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p}\PYG{p}{.}\PYG{n}{second}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first}\PYG{p}{]}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{1}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first}\PYG{p}{]}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
                \PYG{n}{que}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{make\PYGZus{}pair}\PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first}\PYG{p}{,} \PYG{n}{p}\PYG{p}{.}\PYG{n}{second} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{n}{N} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first}\PYG{p}{]}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{1}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first}\PYG{p}{]}\PYG{p}{[}\PYG{n}{p}\PYG{p}{.}\PYG{n}{second} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
                \PYG{n}{que}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{make\PYGZus{}pair}\PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{first}\PYG{p}{,} \PYG{n}{p}\PYG{p}{.}\PYG{n}{second} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{int} \PYG{n}{numIslands}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{grid}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{M} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{N} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{island} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{m} \PYG{o}{\PYGZlt{}} \PYG{n}{M}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{m}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{N}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{1}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{island} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                    \PYG{n}{traverseIsland}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{,} \PYG{n}{m}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{island}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{31}
\item {} 
回文。

\end{enumerate}
\begin{quote}
\begin{itemize}
\item {} 
{[}LeetCode{]} Longest Palindromic Substring 最长回文子串（子串连续）。Hint：中心扩展法，回文中心的两侧互为镜像，将每一个位置作为中心进行扩展，回文分偶数和奇数；动态规划，类似于矩阵连乘问题，逐渐增大步长。
\begin{quote}

\sphinxurl{https://leetcode.com/problems/longest-palindromic-substring/}
\end{quote}
$$
dp[i][i] = true
$$

$$
dp[i][j] =
\begin{cases}
true & &\ s[i] = s[j]\ \&\&\ (i \leqslant j \leqslant i+1\ ||\ dp[i+1][j-1]) \\
false & &\ else
\end{cases}
$$
\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 方法一，中心扩展法}
\PYG{k}{class} \PYG{n+nc}{Solution} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{void} \PYG{n}{Palindrome}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{,} \PYG{n}{string} \PYG{n}{s}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{start}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{longest}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{s}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
            \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{n}{j} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{\PYGZgt{}} \PYG{n}{longest}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{longest} \PYG{o}{=} \PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{n}{start} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{string} \PYG{n}{longestPalindrome}\PYG{p}{(}\PYG{n}{string} \PYG{n}{s}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{len} \PYG{o}{=} \PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{len} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{start} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{longest} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+} \PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Palindrome}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{longest}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{Palindrome}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{longest}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{string} \PYG{n}{str}\PYG{p}{;}
        \PYG{n}{str}\PYG{p}{.}\PYG{n}{assign}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{longest}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// 方法二，动态规划}
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{string} \PYG{n}{longestPalindrome}\PYG{p}{(}\PYG{n}{string} \PYG{n}{s}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
        \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{len} \PYG{o}{=} \PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{dp}\PYG{p}{(}\PYG{n}{len}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{len}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{start} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{longest} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{gap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{gap} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+} \PYG{n}{gap}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+} \PYG{n}{gap} \PYG{o}{\PYGZlt{}} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+} \PYG{n}{i}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{n}{gap}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{s}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{n}{longest} \PYG{o}{=} \PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// 由于步长是逐渐增大的，因此最后得到的回文子串一定是最长的}
                        \PYG{n}{start} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{else} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{s}\PYG{p}{.}\PYG{n}{substr}\PYG{p}{(}\PYG{n}{start}\PYG{p}{,} \PYG{n}{longest}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
{[}LeetCode{]} Longest Palindromic Subsequence 最长回文子序列（子序列可以不连续）。Hint：寻找原字符串与翻转字符串的最长公共子序列，动态规划。
\begin{quote}

\sphinxurl{https://leetcode.com/problems/longest-palindromic-subsequence/}
\end{quote}

\end{itemize}

\(\color{darkgreen}{Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// 寻找字符串 str 与其翻转字符串的最长公共子序列}
    \PYG{k+kt}{int} \PYG{n}{lcsLength}\PYG{p}{(}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{str}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{len} \PYG{o}{=} \PYG{n}{str}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{dp}\PYG{p}{(}\PYG{n}{len}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{len}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{len}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{len} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)} \PYG{c+c1}{// 注意这里 j 是反向的}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{str}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{str}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{else} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{max}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{int} \PYG{n}{ans} \PYG{o}{=} \PYG{n}{dp}\PYG{p}{[}\PYG{n}{len}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{n}{dp}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{ans}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{int} \PYG{n}{longestPalindromeSubseq}\PYG{p}{(}\PYG{n}{string} \PYG{n}{s}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{return} \PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nf}{lcsLength}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}


\subsection{C++}
\label{\detokenize{else/01_interview:c}}\begin{enumerate}
\item {} 
虚函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/fighting\_coder/article/details/77187151}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
C++构造函数和析构函数能否声明为虚函数？(转载)

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/hxb316/p/3853544.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
重载、重写（覆盖）和隐藏的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/zx3517288/article/details/48976097}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
C++ STL中vector内存用尽后，为啥每次是两倍的增长，而不是3倍或其他数值？

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.zhihu.com/question/36538542}
\end{quote}


\subsection{Python}
\label{\detokenize{else/01_interview:python}}\begin{enumerate}
\item {} 
基本数据类型

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/littlefivebolg/p/8982889.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Python中的None

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/changbaishan/p/8084863.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
使用lambda高效操作列表的教程

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/mxp-neu/articles/5316557.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
经典7大Python面试题

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/qq\_41597912/article/details/81459804}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
迭代器和生成器

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/chongdongxiaoyu/p/9054847.html}
\end{quote}


\subsection{机器学习（深度学习）}
\label{\detokenize{else/01_interview:id4}}\begin{enumerate}
\item {} 
激活函数

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/deepLearning/02\_activationFunction.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Batch Normalization

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/deepLearning/03\_batchnorm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
过拟合

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/deepLearning/03\_batchnorm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
正则化项L1和L2的区别

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/lyr2015/p/8718104.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
KMeans秘籍之如何确定K值

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/alicelmx/article/details/80991870}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
决策树

\end{enumerate}
\begin{itemize}
\item {} 
ID3、C4.5
\begin{quote}

\sphinxurl{https://www.cnblogs.com/coder2012/p/4508602.html}
\end{quote}

\item {} 
预剪枝与后剪枝
\begin{quote}

\sphinxurl{https://blog.csdn.net/zfan520/article/details/82454814}
\end{quote}

\item {} 
CART分类与回归树
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/b90a9ce05b28}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
Logistic Regression

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/machineLearning/01\_lr.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{7}
\item {} 
Support Vector Machine

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/machineLearning/02\_svm.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{8}
\item {} 
PCA

\end{enumerate}
\begin{quote}

\sphinxurl{https://fongyq.github.io/blog/machineLearning/03\_pca.html}
\end{quote}


\subsection{论文相关}
\label{\detokenize{else/01_interview:id5}}\begin{enumerate}
\item {} 
AlexNet/VGG/GoogleNet

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/gdymind/article/details/83042729}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
CNN卷积神经网络\_ GoogLeNet 之 Inception(V1-V4)

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/diamonjoy\_zone/article/details/70576775}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
ResNeXt

\end{enumerate}
\begin{itemize}
\item {} 
ResNeXt
\begin{quote}

\sphinxurl{https://www.cnblogs.com/bonelee/p/9031639.html}
\end{quote}

\item {} 
ResNeXt算法详解
\begin{quote}

\sphinxurl{https://blog.csdn.net/u014380165/article/details/71667916}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
R-CNN系列

\end{enumerate}
\begin{itemize}
\item {} 
RCNN（三）：Fast R-CNN
\begin{quote}

\sphinxurl{https://blog.csdn.net/u011587569/article/details/52151871}
\end{quote}

\item {} 
【RCNN系列】【超详细解析】
\begin{quote}

\sphinxurl{https://blog.csdn.net/amor\_tila/article/details/78809791}
\end{quote}

\item {} 
实例分割模型Mask R-CNN详解：从R-CNN，Fast R-CNN，Faster R-CNN再到Mask R-CNN
\begin{quote}

\sphinxurl{https://blog.csdn.net/jiongnima/article/details/79094159}
\end{quote}

\item {} 
(Mask RCNN)——论文详解(真的很详细)
\begin{quote}

\sphinxurl{https://blog.csdn.net/wangdongwei0/article/details/83110305}
\end{quote}

\item {} 
ROI-Align 原理理解
\begin{quote}

\sphinxurl{https://blog.csdn.net/gusui7202/article/details/84799535}
\end{quote}

\item {} 
为什么RCNN用SVM做分类而不直接用CNN全连接之后softmax输出？
\begin{quote}

\sphinxurl{https://www.zhihu.com/question/54117650}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Focal Loss（样本不均衡：正/负样本数量不均衡（ \(\alpha\) ），简单/困难样本数量不均衡（ \(\gamma\) ））

\end{enumerate}
\begin{quote}
\begin{equation*}
\begin{split}CE & = &\ -y \log y_t - (1 - y) \log (1 - y_t) & &\ [\text{Cross Entropy Loss}] \\
FL & = &\ -y \alpha (1 - y_t)^\gamma \log y_t - (1 - y) (1 - \alpha) y_t^\gamma \log (1 - y_t) & &\ [\text{Focal Loss}]\end{split}
\end{equation*}
即
$$
CE =
\begin{cases}
- \log y_t, & &\ y=1\\
- \log (1 - y_t), & &\ y=0
\end{cases}
$$

$$
FL =
\begin{cases}
- \alpha (1 - y_t)^\gamma \log y_t, & &\ y=1\\
- (1 - \alpha) y_t^\gamma \log (1 - y_t), & &\ y=0
\end{cases}
$$\begin{itemize}
\item {} 
损失函数改进方法之Focal Loss
\begin{quote}

\sphinxurl{https://blog.csdn.net/sinat\_24143931/article/details/79033538}
\end{quote}

\item {} 
RetinaNet论文理解
\begin{quote}

\sphinxurl{https://blog.csdn.net/wwwhp/article/details/83317738}
\end{quote}

\item {} 
Focal Loss理解
\begin{quote}

\sphinxurl{https://www.cnblogs.com/king-lps/p/9497836.html}
\end{quote}

\end{itemize}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
FCN（Fully Convolutional Networks）

\end{enumerate}
\begin{itemize}
\item {} 
FCN学习:Semantic Segmentation
\begin{quote}

\sphinxurl{https://zhuanlan.zhihu.com/p/22976342?utm\_source=tuicool\&utm\_medium=referral}
\end{quote}

\item {} 
FCN于反卷积(Deconvolution)、上采样(UpSampling)
\begin{quote}

\sphinxurl{https://blog.csdn.net/nijiayan123/article/details/79416764}
\end{quote}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
FPN（Feature Pyramid Networks for Object Detection）

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.cnblogs.com/fangpengchengbupter/p/7681683.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{7}
\item {} 
CapsuleNet解读

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/u013010889/article/details/78722140/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{8}
\item {} 
轻量级网络\textendash{}MobileNet论文解读

\end{enumerate}
\begin{quote}

\sphinxurl{https://blog.csdn.net/u011974639/article/details/79199306}
\end{quote}


\subsection{其他}
\label{\detokenize{else/01_interview:id6}}\begin{enumerate}
\item {} 
理解数据库的事务，ACID，CAP和一致性

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/2c30d1fe5c4e}
\end{quote}


\section{rst语法}
\label{\detokenize{else/02_test_code:rst}}\label{\detokenize{else/02_test_code::doc}}
\sphinxcode{\sphinxupquote{makefile}} 规则：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{target ... }\PYG{o}{:} \PYG{n}{prerequisites} ...
    \PYG{n+nb}{command}
    ...
    ...
\end{sphinxVerbatim}

下面是几个定义：
\begin{description}
\item[{target}] \leavevmode
可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对
于标签这种特性，在后续的“伪目标”章节中会有叙述。

\item[{prerequisites}] \leavevmode
生成该target所依赖的文件和/或target

\item[{command}] \leavevmode
该target要执行的命令（任意的shell命令）

\end{description}

这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，
其生成规则定义在command中。说白一点就是说:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。
\end{sphinxVerbatim}

这就是 \sphinxcode{\sphinxupquote{makefile}} 的规则，也就是 \sphinxcode{\sphinxupquote{makefile}} 中最核心的内容。

\sphinxcode{\sphinxupquote{echo "Hello World!";}}

行内公式使用 \sphinxcode{\sphinxupquote{math}} 这个 \sphinxcode{\sphinxupquote{role}}: \(a^2 + b^2 = c^2\).
\begin{equation*}
\begin{split}(a + b)^2  &=  (a + b)(a + b) \\
           &=  a^2 + 2ab + b^2\end{split}
\end{equation*}
\sphinxcode{\sphinxupquote{latex}} math测试:
\begin{equation*}
\begin{split}X_k =  \sum_{n=0}^{N-1} x_n e^{-{i 2\pi k \frac{n}{N}}} \qquad k = 0,\dots,N-1.\end{split}
\end{equation*}
将高亮语言设置为 \sphinxcode{\sphinxupquote{C}}

测试 \sphinxcode{\sphinxupquote{C}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{char} \PYG{n}{c} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{c}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}c}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

这里是 \sphinxcode{\sphinxupquote{C++}} :

\fvset{hllines={, 3, 4, 5,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{;}
  \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{j}\PYG{p}{;}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// 主函数注释}
\end{sphinxVerbatim}

斜体 \sphinxtitleref{text}

将高亮语言设置为 \sphinxcode{\sphinxupquote{python}}

测试 \sphinxcode{\sphinxupquote{python}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello world}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

这里是 \sphinxcode{\sphinxupquote{python}} (code):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Love Python, Love FreeDome}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E文标点,.0123456789,中文标点,. }\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

如果数据库有问题, 执行下面的 \sphinxcode{\sphinxupquote{SQL}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Dumping data for table {}`item\PYGZus{}table{}`}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{item\PYGZus{}table} \PYG{k}{VALUES} \PYG{p}{(}
\PYG{l+m+mi}{0000000001}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Manual\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}0.18.0\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}This is the manual for Mantis version 0.18.0.\PYGZbs{}r\PYGZbs{}n\PYGZbs{}r\PYGZbs{}nThe Mantis manual is modeled after the [url=http://www.php.net/manual/en/]PHP Manual[/url]. It is authored via the \PYGZbs{}\PYGZbs{}\PYGZdq{}manual\PYGZbs{}\PYGZbs{}\PYGZdq{} module in Mantis CVS.  You can always view/download the latest version of this manual from [url=http://mantisbt.sourceforge.net/manual/]here[/url].\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{20030811192655}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{python}}：

\fvset{hllines={, 2, 3,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} 测试注释}
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Love Python, Love FreeDome}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E文标点,.0123456789,中文标点,. }\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{javescipt}} 的 \sphinxcode{\sphinxupquote{rst}} 源码:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{o}{.}\PYG{o}{.} \PYG{n}{code}\PYG{o}{\PYGZhy{}}\PYG{n}{block}\PYG{p}{:}\PYG{p}{:} \PYG{n}{javascript}
    \PYG{p}{:}\PYG{n}{linenos}\PYG{p}{:}

    \PYG{n}{function} \PYG{n}{whatever}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{such color}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{bash}} :

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} home
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}PATH}
\PYG{n+nb}{source} \PYGZti{}/.bashrc
ls \PYGZhy{}l
mkdir filefolder
\PYG{n+nb}{cd} ..
\end{sphinxVerbatim}

下面是 \sphinxcode{\sphinxupquote{python}} (code-block):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Solution}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{jump\PYGZus{}from\PYGZus{}i}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}
        \PYG{n}{max\PYGZus{}step} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i} \PYG{o}{+} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{max\PYGZus{}step}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{jump\PYGZus{}from\PYGZus{}i}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{return} \PYG{n+nb+bp}{True}
        \PYG{k}{return} \PYG{n+nb+bp}{False}
    \PYG{k}{def} \PYG{n+nf}{canJump}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{nums}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        https://leetcode.com/problems/jump\PYGZhy{}game/}
\PYG{l+s+sd}{        Each element in the array represents your maximum jump length at that position.}

\PYG{l+s+sd}{        Input: [2,3,1,1,4]}
\PYG{l+s+sd}{        Output: true}
\PYG{l+s+sd}{        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.}

\PYG{l+s+sd}{        :type nums: List[int]}
\PYG{l+s+sd}{        :rtype: bool}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{n}{nums} \PYG{o}{==} \PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{False}
        \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{jump\PYGZus{}from\PYGZus{}i}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

代码显示与隐藏：

\(\color{darkgreen}{Show/Hide\ Code}\)

\(\color{darkgreen}{Show/Hide\ Code}\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
from plone import api
...
\end{sphinxVerbatim}

插入空行使用 \sphinxcode{\sphinxupquote{\textbar{}}} 。

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}

上面是两个空行。


\subsection{参考资料}
\label{\detokenize{else/02_test_code:id1}}\begin{enumerate}
\item {} 
reStructuredText(rst)快速入门语法说明

\end{enumerate}
\begin{quote}

\sphinxurl{https://www.jianshu.com/p/1885d5570b37}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
RST 语法

\end{enumerate}
\begin{quote}

\sphinxurl{https://3vshej.cn/rstSyntax/rstSyntax.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
代码隐藏（自定义，\_templates放在conf.py同目录下）

\end{enumerate}
\begin{quote}

\sphinxurl{http://cn.voidcc.com/question/p-pnfmhomd-v.html}

\sphinxurl{https://stackoverflow.com/questions/2454577/sphinx-restructuredtext-show-hide-code-snippets}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
代码隐藏（安装扩展，全屏显示，体验不好）

\end{enumerate}
\begin{quote}

\sphinxurl{https://sphinxcontrib-contentui.readthedocs.io/en/latest/installation.html}

\sphinxurl{https://sphinxcontrib-contentui.readthedocs.io/en/latest/toggle.html}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Sphinx + Github Page + Read the Docs

\end{enumerate}
\begin{quote}

\sphinxurl{https://kyzhang.me/2018/05/08/Sphinx-Readthedocs-GitHub2build-wiki/}

\sphinxurl{https://www.jianshu.com/p/78e9e1b8553a}

\sphinxurl{https://blog.csdn.net/baidu\_25464429/article/details/80805237}

\sphinxurl{https://github.com/mathLab/PyGeM/issues/94}

\sphinxurl{https://jamwheeler.com/college-productivity/how-to-write-beautiful-code-documentation/}

\sphinxurl{https://daler.github.io/sphinxdoc-test/includeme.html}

\sphinxurl{https://github.com/rtfd/sphinx\_rtd\_theme}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
latex 颜色

\end{enumerate}
\begin{quote}

\sphinxurl{http://latexcolor.com/}
\end{quote}



\renewcommand{\indexname}{Index}
\printindex
\end{document}