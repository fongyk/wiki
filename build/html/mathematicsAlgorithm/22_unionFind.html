<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>22. 并查集 &mdash; fong alpha documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="23. 前缀函数与 KMP 算法" href="23_kmp.html" />
    <link rel="prev" title="21. 随机数" href="21_rand.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> fong
            <img src="../_static/logo.jpg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                alpha
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../link/index.html">快速访问</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp/index.html">C/C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/index.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux/index.html">Linux/Shell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git</a></li>
<li class="toctree-l1"><a class="reference internal" href="../machineLearning/index.html">机器学习</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deepLearning/index.html">深度学习</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">数理与算法</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01_complexity.html">1. 算法复杂度与主定理</a></li>
<li class="toctree-l2"><a class="reference internal" href="02_redblackTree.html">2. 红黑树</a></li>
<li class="toctree-l2"><a class="reference internal" href="03_shortestPath.html">3. 最短路径</a></li>
<li class="toctree-l2"><a class="reference internal" href="04_treeTraversal.html">4. 二叉树遍历</a></li>
<li class="toctree-l2"><a class="reference internal" href="05_game.html">5. 游戏与必胜策略</a></li>
<li class="toctree-l2"><a class="reference internal" href="06_randomSample.html">6. 蓄水池抽样</a></li>
<li class="toctree-l2"><a class="reference internal" href="07_sort.html">7. 排序算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="08_dynamicProgramming.html">8. 动态规划</a></li>
<li class="toctree-l2"><a class="reference internal" href="09_backtrack.html">9. 回溯</a></li>
<li class="toctree-l2"><a class="reference internal" href="10_topoSort.html">10. 拓扑排序</a></li>
<li class="toctree-l2"><a class="reference internal" href="11_catalan.html">11. 卡特兰数</a></li>
<li class="toctree-l2"><a class="reference internal" href="12_entropy.html">12. 信息熵</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_cltLLN.html">13. 大数定律和中心极限定理</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_coinWeigh.html">14. 称重问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="15_probability.html">15. 概率基础</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_geometry.html">16. 几何</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_graphCycle.html">17. 图环</a></li>
<li class="toctree-l2"><a class="reference internal" href="18_bTree.html">18. B 树</a></li>
<li class="toctree-l2"><a class="reference internal" href="19_ballBox.html">19. 球盒问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="20_poison.html">20. 喝水试毒</a></li>
<li class="toctree-l2"><a class="reference internal" href="21_rand.html">21. 随机数</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">22. 并查集</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">22.1. 简单版本</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">查询</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">合并</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id6">22.2. 路径压缩</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">22.3. 启发式合并</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">22.4. 复杂度</a></li>
<li class="toctree-l3"><a class="reference internal" href="#python">22.5. Python 参考代码</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kruskal">22.6. Kruskal 算法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">22.7. 参考资料</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="23_kmp.html">23. 前缀函数与 KMP 算法</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../regularExpression/index.html">正则表达式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cron/index.html">Cron 表达式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../computerNetwork/index.html">计算机网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../softwares/index.html">实用软件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tech/index.html">技巧</a></li>
<li class="toctree-l1"><a class="reference internal" href="../else/index.html">其他</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">fong</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">数理与算法</a> &raquo;</li>
      <li><span class="section-number">22. </span>并查集</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/mathematicsAlgorithm/22_unionFind.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1><span class="section-number">22. </span>并查集<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1>
<p>并查集是一种树形的数据结构，顾名思义，它用于处理一些不相交集合（Disjoint Set）的合并及查询问题。它支持两种操作：</p>
<ul class="simple">
<li><p>合并（Union）：把两个不相交的集合合并为一个集合。</p></li>
<li><p>查询（Find）：查询两个元素是否在同一个集合中。</p></li>
</ul>
<p>并查集不支持集合的分离，但是并查集在经过修改后可以支持集合中单个元素的删除操作。</p>
<p>并查集的重要思想在于，用集合中的一个元素（根节点）代表集合。</p>
<section id="id2">
<h2><span class="section-number">22.1. </span>简单版本<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2>
<section id="id3">
<h3>初始化<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h3>
<p>假设有 <span class="math notranslate nohighlight">\(n\)</span> 个元素，用一个数组 parent[] 来存储每个元素的父节点；初始时，将它们的父节点设为自己。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="kt">int</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span><span class="w"></span>
<span class="linenos">2</span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="linenos">3</span><span class="p">{</span><span class="w"></span>
<span class="linenos">4</span><span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="linenos">5</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id4">
<h3>查询<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h3>
<p>用递归的写法实现对 <strong>代表元素</strong> 的查询：层层向上访问父节点，直至根节点（根节点的标志就是：父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="linenos">2</span><span class="p">{</span><span class="w"></span>
<span class="linenos">3</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="linenos">4</span><span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">5</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id5">
<h3>合并<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h3>
<p>先找到两个集合的代表元素，然后将前者的父节点设为后者即可（当然也可以将后者的父节点设为前者）。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="linenos">2</span><span class="p">{</span><span class="w"></span>
<span class="linenos">3</span><span class="w">  </span><span class="n">parent</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="linenos">4</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="id6">
<h2><span class="section-number">22.2. </span>路径压缩<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2>
<p>简单版本的并查集效率是比较低的，因为集合合并可能会导致树结构深度越来越深，想要从底部找到根节点代价会变得越来越大。</p>
<p>既然我们只关心一个元素对应的根节点，那我们希望每个元素到根节点的路径尽可能短（最好只需要一步）。只要我们在查询的过程中，把沿途的每个节点的父节点都设为根节点即可。这样一来，下次查询的效率就很高。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="linenos">2</span><span class="p">{</span><span class="w"></span>
<span class="linenos">3</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="linenos">4</span><span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="linenos">5</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="linenos">6</span><span class="w">    </span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">7</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="linenos">8</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">9</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id7">
<h2><span class="section-number">22.3. </span>启发式合并<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2>
<p>合并可能会使树的深度（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后寻找根节点的路径也就会相应变长。虽然有路径压缩，但路径压缩也是会消耗时间的。</p>
<p>启发式合并方法：把简单的树往复杂的树上合并。因为这样合并后，到根节点距离变长的节点个数比较少。</p>
<p>用一个数组 rank[] 记录每个根节点对应的树的深度（非根节点的 rank 相当于以它为根节点的子树的深度）。初始时，把所有元素的 rank（秩）设为 1；合并时把 rank 较小的树往较大的树上合并。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 2</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">    </span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">    </span><span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 8</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="linenos">11</span><span class="p">{</span><span class="w"></span>
<span class="linenos">12</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="linenos">14</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rx</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">rank</span><span class="p">[</span><span class="n">ry</span><span class="p">])</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">rx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ry</span><span class="p">;</span><span class="w"></span>
<span class="linenos">15</span><span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">ry</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx</span><span class="p">;</span><span class="w"></span>
<span class="linenos">16</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rx</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rank</span><span class="p">[</span><span class="n">ry</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">rx</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="n">rank</span><span class="p">[</span><span class="n">ry</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// 如果深度相同且根节点不同，则新的根节点的深度 +1</span>
<span class="linenos">17</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>由于每一次查询都是对树的一次重构，会把叶节点以及其所有的祖先全部变成根节点的子节点，因此 rank 会失真，无法反应真实的树高。还有一种启发式合并方法是：把节点少的树往节点多的树上合并。</p>
</section>
<section id="id8">
<h2><span class="section-number">22.4. </span>复杂度<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2>
<p>简单来说，对于有 <span class="math notranslate nohighlight">\(n\)</span> 个元素的并查集，空间复杂度是 <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span> ；<span class="math notranslate nohighlight">\(m\)</span> 次合并、查询操作的摊还时间是 <span class="math notranslate nohighlight">\(\mathcal{O}(m \log^* n)\)</span>，其中 <span class="math notranslate nohighlight">\(\log^*\)</span> 是迭代对数（iterated logarithm）。</p>
</section>
<section id="python">
<h2><span class="section-number">22.5. </span>Python 参考代码<a class="headerlink" href="#python" title="Permalink to this headline"></a></h2>
<div class="toggle docutils container">
<div class="header docutils container">
<p><span class="math notranslate nohighlight">\(\color{darkgreen}{Code}\)</span></p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">  2</span><span class="sd">A union-find disjoint set data structure.</span>
<span class="linenos">  3</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">  4</span>
<span class="linenos">  5</span><span class="c1"># 2to3 sanity</span>
<span class="linenos">  6</span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span>
<span class="linenos">  7</span>    <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span>
<span class="linenos">  8</span><span class="p">)</span>
<span class="linenos">  9</span>
<span class="linenos"> 10</span><span class="c1"># Third-party libraries</span>
<span class="linenos"> 11</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="linenos"> 12</span>
<span class="linenos"> 13</span>
<span class="linenos"> 14</span><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="linenos"> 15</span>    <span class="sd">&quot;&quot;&quot;Union-find disjoint sets datastructure.</span>
<span class="linenos"> 16</span><span class="sd">    Union-find is a data structure that maintains disjoint set</span>
<span class="linenos"> 17</span><span class="sd">    (called connected components or components in short) membership,</span>
<span class="linenos"> 18</span><span class="sd">    and makes it easier to merge (union) two components, and to find</span>
<span class="linenos"> 19</span><span class="sd">    if two elements are connected (i.e., belong to the same</span>
<span class="linenos"> 20</span><span class="sd">    component).</span>
<span class="linenos"> 21</span><span class="sd">    This implements the &quot;weighted-quick-union-with-path-compression&quot;</span>
<span class="linenos"> 22</span><span class="sd">    union-find algorithm.  Only works if elements are immutable</span>
<span class="linenos"> 23</span><span class="sd">    objects.</span>
<span class="linenos"> 24</span><span class="sd">    Worst case for union and find: :math:`(N + M \log^* N)`, with</span>
<span class="linenos"> 25</span><span class="sd">    :math:`N` elements and :math:`M` unions. The function</span>
<span class="linenos"> 26</span><span class="sd">    :math:`\log^*` is the number of times needed to take :math:`\log`</span>
<span class="linenos"> 27</span><span class="sd">    of a number until reaching 1. In practice, the amortized cost of</span>
<span class="linenos"> 28</span><span class="sd">    each operation is nearly linear [1]_.</span>
<span class="linenos"> 29</span><span class="sd">    Terms</span>
<span class="linenos"> 30</span><span class="sd">    -----</span>
<span class="linenos"> 31</span><span class="sd">    Component</span>
<span class="linenos"> 32</span><span class="sd">        Elements belonging to the same disjoint set</span>
<span class="linenos"> 33</span><span class="sd">    Connected</span>
<span class="linenos"> 34</span><span class="sd">        Two elements are connected if they belong to the same component.</span>
<span class="linenos"> 35</span><span class="sd">    Union</span>
<span class="linenos"> 36</span><span class="sd">        The operation where two components are merged into one.</span>
<span class="linenos"> 37</span><span class="sd">    Root</span>
<span class="linenos"> 38</span><span class="sd">        An internal representative of a disjoint set.</span>
<span class="linenos"> 39</span><span class="sd">    Find</span>
<span class="linenos"> 40</span><span class="sd">        The operation to find the root of a disjoint set.</span>
<span class="linenos"> 41</span><span class="sd">    Parameters</span>
<span class="linenos"> 42</span><span class="sd">    ----------</span>
<span class="linenos"> 43</span><span class="sd">    elements : NoneType or container, optional, default: None</span>
<span class="linenos"> 44</span><span class="sd">        The initial list of elements.</span>
<span class="linenos"> 45</span><span class="sd">    Attributes</span>
<span class="linenos"> 46</span><span class="sd">    ----------</span>
<span class="linenos"> 47</span><span class="sd">    n_elts : int</span>
<span class="linenos"> 48</span><span class="sd">        Number of elements.</span>
<span class="linenos"> 49</span><span class="sd">    n_comps : int</span>
<span class="linenos"> 50</span><span class="sd">        Number of distjoint sets or components.</span>
<span class="linenos"> 51</span><span class="sd">    Implements</span>
<span class="linenos"> 52</span><span class="sd">    ----------</span>
<span class="linenos"> 53</span><span class="sd">    __len__</span>
<span class="linenos"> 54</span><span class="sd">        Calling ``len(uf)`` (where ``uf`` is an instance of ``UnionFind``)</span>
<span class="linenos"> 55</span><span class="sd">        returns the number of elements.</span>
<span class="linenos"> 56</span><span class="sd">    __contains__</span>
<span class="linenos"> 57</span><span class="sd">        For ``uf`` an instance of ``UnionFind`` and ``x`` an immutable object,</span>
<span class="linenos"> 58</span><span class="sd">        ``x in uf`` returns ``True`` if ``x`` is an element in ``uf``.</span>
<span class="linenos"> 59</span><span class="sd">    __getitem__</span>
<span class="linenos"> 60</span><span class="sd">        For ``uf`` an instance of ``UnionFind`` and ``i`` an integer,</span>
<span class="linenos"> 61</span><span class="sd">        ``res = uf[i]`` returns the element stored in the ``i``-th index.</span>
<span class="linenos"> 62</span><span class="sd">        If ``i`` is not a valid index an ``IndexError`` is raised.</span>
<span class="linenos"> 63</span><span class="sd">    __setitem__</span>
<span class="linenos"> 64</span><span class="sd">        For ``uf`` and instance of ``UnionFind``, ``i`` an integer and ``x``</span>
<span class="linenos"> 65</span><span class="sd">        an immutable object, ``uf[i] = x`` changes the element stored at the</span>
<span class="linenos"> 66</span><span class="sd">        ``i``-th index. If ``i`` is not a valid index an ``IndexError`` is</span>
<span class="linenos"> 67</span><span class="sd">        raised.</span>
<span class="linenos"> 68</span><span class="sd">    .. [1] http://algs4.cs.princeton.edu/lectures/</span>
<span class="linenos"> 69</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 70</span>
<span class="linenos"> 71</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="linenos"> 72</span>        <span class="bp">self</span><span class="o">.</span><span class="n">n_elts</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># current num of elements</span>
<span class="linenos"> 73</span>        <span class="bp">self</span><span class="o">.</span><span class="n">n_comps</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the number of disjoint sets or components</span>
<span class="linenos"> 74</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># next available id</span>
<span class="linenos"> 75</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_elts</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the elements</span>
<span class="linenos"> 76</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_indx</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1">#  dict mapping elt -&gt; index in _elts</span>
<span class="linenos"> 77</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># parent: for the internal tree structure</span>
<span class="linenos"> 78</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># size of the component - correct only for roots</span>
<span class="linenos"> 79</span>
<span class="linenos"> 80</span>        <span class="k">if</span> <span class="n">elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 81</span>            <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos"> 82</span>        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
<span class="linenos"> 83</span>            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
<span class="linenos"> 84</span>
<span class="linenos"> 85</span>
<span class="linenos"> 86</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 87</span>        <span class="k">return</span>  <span class="p">(</span>
<span class="linenos"> 88</span>            <span class="s1">&#39;&lt;UnionFind:</span><span class="se">\n\t</span><span class="s1">elts=</span><span class="si">{}</span><span class="s1">,</span><span class="se">\n\t</span><span class="s1">siz=</span><span class="si">{}</span><span class="s1">,</span><span class="se">\n\t</span><span class="s1">par=</span><span class="si">{}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">n_elts=</span><span class="si">{}</span><span class="s1">,n_comps=</span><span class="si">{}</span><span class="s1">&gt;&#39;</span>
<span class="linenos"> 89</span>            <span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="linenos"> 90</span>                <span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">,</span>
<span class="linenos"> 91</span>                <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">,</span>
<span class="linenos"> 92</span>                <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">,</span>
<span class="linenos"> 93</span>                <span class="bp">self</span><span class="o">.</span><span class="n">n_elts</span><span class="p">,</span>
<span class="linenos"> 94</span>                <span class="bp">self</span><span class="o">.</span><span class="n">n_comps</span><span class="p">,</span>
<span class="linenos"> 95</span>            <span class="p">))</span>
<span class="linenos"> 96</span>
<span class="linenos"> 97</span>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 98</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elts</span>
<span class="linenos"> 99</span>
<span class="linenos">100</span>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="linenos">101</span>        <span class="k">return</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indx</span>
<span class="linenos">102</span>
<span class="linenos">103</span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="linenos">104</span>        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">:</span>
<span class="linenos">105</span>            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;index </span><span class="si">{}</span><span class="s1"> is out of bound&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
<span class="linenos">106</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="linenos">107</span>
<span class="linenos">108</span>    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="linenos">109</span>        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">:</span>
<span class="linenos">110</span>            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;index </span><span class="si">{}</span><span class="s1"> is out of bound&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
<span class="linenos">111</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
<span class="linenos">112</span>
<span class="linenos">113</span>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="linenos">114</span>        <span class="sd">&quot;&quot;&quot;Add a single disjoint element.</span>
<span class="linenos">115</span><span class="sd">        Parameters</span>
<span class="linenos">116</span><span class="sd">        ----------</span>
<span class="linenos">117</span><span class="sd">        x : immutable object</span>
<span class="linenos">118</span><span class="sd">        Returns</span>
<span class="linenos">119</span><span class="sd">        -------</span>
<span class="linenos">120</span><span class="sd">        None</span>
<span class="linenos">121</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">122</span>        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
<span class="linenos">123</span>            <span class="k">return</span>
<span class="linenos">124</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="linenos">125</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_indx</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span>
<span class="linenos">126</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">)</span>
<span class="linenos">127</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos">128</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="linenos">129</span>        <span class="bp">self</span><span class="o">.</span><span class="n">n_elts</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="linenos">130</span>        <span class="bp">self</span><span class="o">.</span><span class="n">n_comps</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="linenos">131</span>
<span class="linenos">132</span>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="linenos">133</span>        <span class="sd">&quot;&quot;&quot;Find the root of the disjoint set containing the given element.</span>
<span class="linenos">134</span><span class="sd">        Parameters</span>
<span class="linenos">135</span><span class="sd">        ----------</span>
<span class="linenos">136</span><span class="sd">        x : immutable object</span>
<span class="linenos">137</span><span class="sd">        Returns</span>
<span class="linenos">138</span><span class="sd">        -------</span>
<span class="linenos">139</span><span class="sd">        int</span>
<span class="linenos">140</span><span class="sd">            The (index of the) root.</span>
<span class="linenos">141</span><span class="sd">        Raises</span>
<span class="linenos">142</span><span class="sd">        ------</span>
<span class="linenos">143</span><span class="sd">        ValueError</span>
<span class="linenos">144</span><span class="sd">            If the given element is not found.</span>
<span class="linenos">145</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">146</span>        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indx</span><span class="p">:</span>
<span class="linenos">147</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not an element&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="linenos">148</span>
<span class="linenos">149</span>        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indx</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="linenos">150</span>        <span class="k">while</span> <span class="n">p</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">p</span><span class="p">]:</span>
<span class="linenos">151</span>            <span class="c1"># path compression</span>
<span class="linenos">152</span>            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
<span class="linenos">153</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
<span class="linenos">154</span>            <span class="n">p</span> <span class="o">=</span> <span class="n">q</span>
<span class="linenos">155</span>        <span class="k">return</span> <span class="n">p</span>
<span class="linenos">156</span>
<span class="linenos">157</span>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="linenos">158</span>        <span class="sd">&quot;&quot;&quot;Return whether the two given elements belong to the same component.</span>
<span class="linenos">159</span><span class="sd">        Parameters</span>
<span class="linenos">160</span><span class="sd">        ----------</span>
<span class="linenos">161</span><span class="sd">        x : immutable object</span>
<span class="linenos">162</span><span class="sd">        y : immutable object</span>
<span class="linenos">163</span><span class="sd">        Returns</span>
<span class="linenos">164</span><span class="sd">        -------</span>
<span class="linenos">165</span><span class="sd">        bool</span>
<span class="linenos">166</span><span class="sd">            True if x and y are connected, false otherwise.</span>
<span class="linenos">167</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">168</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="linenos">169</span>
<span class="linenos">170</span>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="linenos">171</span>        <span class="sd">&quot;&quot;&quot;Merge the components of the two given elements into one.</span>
<span class="linenos">172</span><span class="sd">        Parameters</span>
<span class="linenos">173</span><span class="sd">        ----------</span>
<span class="linenos">174</span><span class="sd">        x : immutable object</span>
<span class="linenos">175</span><span class="sd">        y : immutable object</span>
<span class="linenos">176</span><span class="sd">        Returns</span>
<span class="linenos">177</span><span class="sd">        -------</span>
<span class="linenos">178</span><span class="sd">        None</span>
<span class="linenos">179</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">180</span>        <span class="c1"># Initialize if they are not already in the collection</span>
<span class="linenos">181</span>        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
<span class="linenos">182</span>            <span class="k">if</span> <span class="n">elt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
<span class="linenos">183</span>                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
<span class="linenos">184</span>
<span class="linenos">185</span>        <span class="n">xroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="linenos">186</span>        <span class="n">yroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="linenos">187</span>        <span class="k">if</span> <span class="n">xroot</span> <span class="o">==</span> <span class="n">yroot</span><span class="p">:</span>
<span class="linenos">188</span>            <span class="k">return</span>
<span class="linenos">189</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">yroot</span><span class="p">]:</span>
<span class="linenos">190</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span> <span class="o">=</span> <span class="n">yroot</span>
<span class="linenos">191</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">yroot</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span>
<span class="linenos">192</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">193</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_par</span><span class="p">[</span><span class="n">yroot</span><span class="p">]</span> <span class="o">=</span> <span class="n">xroot</span>
<span class="linenos">194</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">xroot</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_siz</span><span class="p">[</span><span class="n">yroot</span><span class="p">]</span>
<span class="linenos">195</span>        <span class="bp">self</span><span class="o">.</span><span class="n">n_comps</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="linenos">196</span>
<span class="linenos">197</span>    <span class="k">def</span> <span class="nf">component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="linenos">198</span>        <span class="sd">&quot;&quot;&quot;Find the connected component containing the given element.</span>
<span class="linenos">199</span><span class="sd">        Parameters</span>
<span class="linenos">200</span><span class="sd">        ----------</span>
<span class="linenos">201</span><span class="sd">        x : immutable object</span>
<span class="linenos">202</span><span class="sd">        Returns</span>
<span class="linenos">203</span><span class="sd">        -------</span>
<span class="linenos">204</span><span class="sd">        set</span>
<span class="linenos">205</span><span class="sd">        Raises</span>
<span class="linenos">206</span><span class="sd">        ------</span>
<span class="linenos">207</span><span class="sd">        ValueError</span>
<span class="linenos">208</span><span class="sd">            If the given element is not found.</span>
<span class="linenos">209</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">210</span>        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
<span class="linenos">211</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not an element&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="linenos">212</span>        <span class="n">elts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">)</span>
<span class="linenos">213</span>        <span class="n">vfind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">)</span>
<span class="linenos">214</span>        <span class="n">roots</span> <span class="o">=</span> <span class="n">vfind</span><span class="p">(</span><span class="n">elts</span><span class="p">)</span>
<span class="linenos">215</span>        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">elts</span><span class="p">[</span><span class="n">roots</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
<span class="linenos">216</span>
<span class="linenos">217</span>    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">218</span>        <span class="sd">&quot;&quot;&quot;Return the list of connected components.</span>
<span class="linenos">219</span><span class="sd">        Returns</span>
<span class="linenos">220</span><span class="sd">        -------</span>
<span class="linenos">221</span><span class="sd">        list</span>
<span class="linenos">222</span><span class="sd">            A list of sets.</span>
<span class="linenos">223</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">224</span>        <span class="n">elts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">)</span>
<span class="linenos">225</span>        <span class="n">vfind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">)</span>
<span class="linenos">226</span>        <span class="n">roots</span> <span class="o">=</span> <span class="n">vfind</span><span class="p">(</span><span class="n">elts</span><span class="p">)</span>
<span class="linenos">227</span>        <span class="n">distinct_roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
<span class="linenos">228</span>        <span class="k">return</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">elts</span><span class="p">[</span><span class="n">roots</span> <span class="o">==</span> <span class="n">root</span><span class="p">])</span> <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">distinct_roots</span><span class="p">]</span>
<span class="linenos">229</span>        <span class="c1"># comps = []</span>
<span class="linenos">230</span>        <span class="c1"># for root in distinct_roots:</span>
<span class="linenos">231</span>        <span class="c1">#     mask = (roots == root)</span>
<span class="linenos">232</span>        <span class="c1">#     comp = set(elts[mask])</span>
<span class="linenos">233</span>        <span class="c1">#     comps.append(comp)</span>
<span class="linenos">234</span>        <span class="c1"># return comps</span>
<span class="linenos">235</span>
<span class="linenos">236</span>    <span class="k">def</span> <span class="nf">component_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">237</span>        <span class="sd">&quot;&quot;&quot;Return a dict mapping elements to their components.</span>
<span class="linenos">238</span><span class="sd">        The returned dict has the following semantics:</span>
<span class="linenos">239</span><span class="sd">            `elt -&gt; component containing elt`</span>
<span class="linenos">240</span><span class="sd">        If x, y belong to the same component, the comp(x) and comp(y)</span>
<span class="linenos">241</span><span class="sd">        are the same objects (i.e., share the same reference). Changing</span>
<span class="linenos">242</span><span class="sd">        comp(x) will reflect in comp(y).  This is done to reduce</span>
<span class="linenos">243</span><span class="sd">        memory.</span>
<span class="linenos">244</span><span class="sd">        But this behaviour should not be relied on.  There may be</span>
<span class="linenos">245</span><span class="sd">        inconsitency arising from such assumptions or lack thereof.</span>
<span class="linenos">246</span><span class="sd">        If you want to do any operation on these sets, use caution.</span>
<span class="linenos">247</span><span class="sd">        For example, instead of</span>
<span class="linenos">248</span><span class="sd">        ::</span>
<span class="linenos">249</span><span class="sd">            s = uf.component_mapping()[item]</span>
<span class="linenos">250</span><span class="sd">            s.add(stuff)</span>
<span class="linenos">251</span><span class="sd">            # This will have side effect in other sets</span>
<span class="linenos">252</span><span class="sd">        do</span>
<span class="linenos">253</span><span class="sd">        ::</span>
<span class="linenos">254</span><span class="sd">            s = set(uf.component_mapping()[item]) # or</span>
<span class="linenos">255</span><span class="sd">            s = uf.component_mapping()[item].copy()</span>
<span class="linenos">256</span><span class="sd">            s.add(stuff)</span>
<span class="linenos">257</span><span class="sd">        or</span>
<span class="linenos">258</span><span class="sd">        ::</span>
<span class="linenos">259</span><span class="sd">            s = uf.component_mapping()[item]</span>
<span class="linenos">260</span><span class="sd">            s = s | {stuff}  # Now s is different</span>
<span class="linenos">261</span><span class="sd">        Returns</span>
<span class="linenos">262</span><span class="sd">        -------</span>
<span class="linenos">263</span><span class="sd">        dict</span>
<span class="linenos">264</span><span class="sd">            A dict with the semantics: `elt -&gt; component contianing elt`.</span>
<span class="linenos">265</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">266</span>        <span class="n">elts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elts</span><span class="p">)</span>
<span class="linenos">267</span>        <span class="n">vfind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">)</span>
<span class="linenos">268</span>        <span class="n">roots</span> <span class="o">=</span> <span class="n">vfind</span><span class="p">(</span><span class="n">elts</span><span class="p">)</span>
<span class="linenos">269</span>        <span class="n">distinct_roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
<span class="linenos">270</span>        <span class="n">comps</span> <span class="o">=</span> <span class="p">{}</span>
<span class="linenos">271</span>        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">distinct_roots</span><span class="p">:</span>
<span class="linenos">272</span>            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">roots</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span>
<span class="linenos">273</span>            <span class="n">comp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">elts</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
<span class="linenos">274</span>            <span class="n">comps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">comp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">})</span>
<span class="linenos">275</span>            <span class="c1"># Change ^this^, if you want a different behaviour:</span>
<span class="linenos">276</span>            <span class="c1"># If you don&#39;t want to share the same set to different keys:</span>
<span class="linenos">277</span>            <span class="c1"># comps.update({x: set(comp) for x in comp})</span>
<span class="linenos">278</span>        <span class="k">return</span> <span class="n">comps</span>
</pre></div>
</div>
</div>
</section>
<section id="kruskal">
<h2><span class="section-number">22.6. </span>Kruskal 算法<a class="headerlink" href="#kruskal" title="Permalink to this headline"></a></h2>
<p>最小生成树算法中的 Kruskal 算法是基于并查集实现的。首先，将边集合放入优先队列，权重越小的边越靠近队首（小顶堆）；然后，边依次出队，如果边的两个顶点位于两个集合，则将它们合并，边权重累加；当合并两个集合之后得到的新集合已经包括了所有的顶点，表示已经得到一棵最小生成树。</p>
<div class="toggle docutils container">
<div class="header docutils container">
<p><span class="math notranslate nohighlight">\(\color{darkgreen}{Code}\)</span></p>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// NC159 最小生成树</span>
<span class="linenos"> 2</span><span class="c1">// https://www.nowcoder.com/practice/735a34ff4672498b95660f43b7fcd628?tpId=117&amp;&amp;tqId=37869&amp;rp=1&amp;ru=/ta/job-code-high&amp;qru=/ta/job-code-high/question-ranking</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="k">struct</span><span class="w"> </span><span class="nc">comparator</span><span class="w"></span>
<span class="linenos"> 5</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="c1">// 小顶堆</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">10</span><span class="p">};</span><span class="w"></span>
<span class="linenos">11</span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="w"></span>
<span class="linenos">12</span><span class="p">{</span><span class="w"></span>
<span class="linenos">13</span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="linenos">14</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">15</span><span class="cm">    * 返回最小的花费代价使得这 n 户人家连接起来</span>
<span class="linenos">16</span><span class="cm">    * @param n int n户人家的村庄</span>
<span class="linenos">17</span><span class="cm">    * @param cost intvector&lt;vector&lt;&gt;&gt; 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价</span>
<span class="linenos">18</span><span class="cm">    * @return int</span>
<span class="linenos">19</span><span class="cm">    */</span><span class="w"></span>
<span class="linenos">20</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">miniSpanningTree</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">cost</span><span class="p">)</span><span class="w"></span>
<span class="linenos">21</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos">22</span><span class="w">        </span><span class="c1">// write code here</span>
<span class="linenos">23</span><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">24</span><span class="w">        </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parents</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">25</span><span class="w">        </span><span class="n">iota</span><span class="p">(</span><span class="n">parents</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">parents</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">26</span><span class="w">        </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">27</span><span class="w">        </span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">comparator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">edges</span><span class="p">;</span><span class="w"></span>
<span class="linenos">28</span><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">edge</span><span class="o">:</span><span class="w"> </span><span class="n">cost</span><span class="p">)</span><span class="w"> </span><span class="n">edges</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span><span class="w"></span>
<span class="linenos">29</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">30</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">31</span><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">edges</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"></span>
<span class="linenos">32</span><span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="linenos">33</span><span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edges</span><span class="p">.</span><span class="n">top</span><span class="p">();</span><span class="w"></span>
<span class="linenos">34</span><span class="w">            </span><span class="n">edges</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="linenos">35</span><span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">union_</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span><span class="p">,</span><span class="w"> </span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="linenos">36</span><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="linenos">37</span><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// 已经得到最小生成树</span>
<span class="linenos">38</span><span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="linenos">39</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="linenos">40</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">41</span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="linenos">42</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">find_</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">parents</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="linenos">43</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos">44</span><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="linenos">45</span><span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="linenos">46</span><span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="linenos">47</span><span class="w">            </span><span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span><span class="w"> </span><span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">48</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="linenos">49</span><span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="linenos">50</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">51</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">union_</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">parents</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">capacity</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="linenos">52</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos">53</span><span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="linenos">54</span><span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="linenos">55</span><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="linenos">56</span><span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="linenos">57</span><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">capacity</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">capacity</span><span class="p">[</span><span class="n">y</span><span class="p">])</span><span class="w"></span>
<span class="linenos">58</span><span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="linenos">59</span><span class="w">                </span><span class="n">parents</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="linenos">60</span><span class="w">                </span><span class="n">capacity</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">capacity</span><span class="p">[</span><span class="n">y</span><span class="p">];</span><span class="w"></span>
<span class="linenos">61</span><span class="w">                </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capacity</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="linenos">62</span><span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="linenos">63</span><span class="w">            </span><span class="k">else</span><span class="w"></span>
<span class="linenos">64</span><span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="linenos">65</span><span class="w">                </span><span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="linenos">66</span><span class="w">                </span><span class="n">capacity</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">capacity</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="linenos">67</span><span class="w">                </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capacity</span><span class="p">[</span><span class="n">y</span><span class="p">];</span><span class="w"></span>
<span class="linenos">68</span><span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="linenos">69</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="linenos">70</span><span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="linenos">71</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="linenos">72</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">73</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
<section id="id9">
<h2><span class="section-number">22.7. </span>参考资料<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2>
<ol class="arabic simple">
<li><p>算法学习笔记(1) : 并查集</p></li>
</ol>
<blockquote>
<div><p><a class="reference external" href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>并查集</p></li>
</ol>
<blockquote>
<div><p><a class="reference external" href="https://oi-wiki.org/ds/dsu/">https://oi-wiki.org/ds/dsu/</a></p>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>并查集入门</p></li>
</ol>
<blockquote>
<div><p><a class="reference external" href="https://segmentfault.com/a/1190000004023326">https://segmentfault.com/a/1190000004023326</a></p>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>github</p></li>
</ol>
<blockquote>
<div><p><a class="reference external" href="https://github.com/deehzee/unionfind/blob/master/unionfind.py">https://github.com/deehzee/unionfind/blob/master/unionfind.py</a></p>
<p><a class="reference external" href="https://github.com/wjakob/dset">https://github.com/wjakob/dset</a></p>
<p><a class="reference external" href="https://github.com/angusb/Union-Find">https://github.com/angusb/Union-Find</a></p>
</div></blockquote>
<ol class="arabic simple" start="5">
<li><p>Disjoint-set data structure</p></li>
</ol>
<blockquote>
<div><p><a class="reference external" href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a></p>
</div></blockquote>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="21_rand.html" class="btn btn-neutral float-left" title="21. 随机数" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="23_kmp.html" class="btn btn-neutral float-right" title="23. 前缀函数与 KMP 算法" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018-2023, fong.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
<script type="text/javascript">
    $(document).ready(function() {
     $(".toggle > *").hide();
     $(".toggle .header").show();
     $(".toggle .header").click(function() {
      $(this).parent().children().not(".header").toggle(400);
      $(this).parent().children(".header").toggleClass("open");
     })
    });
</script>


</body>
</html>