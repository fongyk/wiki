强制类型转换
================

static_cast<type> (expr)
---------------------------------

**1**. ``static_cast`` 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。

**2**. 用于基本数据类型之间的转换，如把 ``int`` 转换成 ``char`` ，把 ``int`` 转换成 ``enum`` 。这种转换的安全性需要开发者来维护。

**3**. C++ 的任何的隐式转换都是使用 ``static_cast`` 来实现。

**4**. 基类和子类之间转换：其中子类指针转换成父类指针是安全的；但父类指针转换成子类指针是不安全的。(基类和子类之间的动态类型转换建议用dynamic_cast)

**5**. 把空指针转换成目标类型的空指针。

**6**. 把任何类型的表达式转换成void类型。

dynamic_cast<type> (expr)
---------------------------------

有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)：

**1**. 安全的基类和子类之间转换。

**2**. 必须要有虚函数。

**3**. 相同基类不同子类之间的交叉转换。但结果是NULL。


const_cast<type> (expr)
--------------------------------

**1**. 去掉类型的const、volitale属性;

**2**. 常量指针被转化成非常量的指针，并且仍然指向原来的对象；

**3**. 常量引用被转换成非常量的引用，并且仍然指向原来的对象；

**4**. const_cast一般用于修改指针。如const char \*p形式。


reinterpret_cast<type> (expr)
-------------------------------------

**1**. reinterpret_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差。

**2**. reinterpret_cast可以将整型转换为指针，也可以把指针转换为数组。

**3**. reinterpret_cast可以在指针和引用里进行肆无忌惮的转换。


参考资料
---------------

1. C++中四种强制类型转换区别详解

  https://www.cnblogs.com/cauchy007/p/4968707.html

2. c++ 四种强制类型转换介绍

  https://blog.csdn.net/ydar95/article/details/69822540
